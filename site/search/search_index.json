{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"QuadControl","text":""},{"location":"basic_concepts/aerodynamics/","title":"Aerodin\u00e2mica","text":"<p>Esta se\u00e7\u00e3o introduz alguns conceitos b\u00e1sicos sobre aerodin\u00e2mica que s\u00e3o essenciais para entender a f\u00edsica de um drone.</p>"},{"location":"basic_concepts/aerodynamics/#aerofolio","title":"\u2708\ufe0f Aerof\u00f3lio","text":"<p>O modelo matem\u00e1tico de um drone, qualquer que seja seu tipo, cont\u00e9m diversos par\u00e2metros aerodin\u00e2micos. No entanto, para obter o conhecimento necess\u00e1rio, come\u00e7aremos examinando as for\u00e7as aerodin\u00e2micas em um aerof\u00f3lio.</p>"},{"location":"basic_concepts/aerodynamics/#forcas-aerodinamicas","title":"For\u00e7as aerodin\u00e2micas","text":"<p>A figura abaixo mostra a sec\u00e7\u00e3o transversal de um aerof\u00f3lio, um corpo te\u00f3rico moldado para produzir sustenta\u00e7\u00e3o quando colocado em um fluxo de ar.</p> <p></p> <p>Apesar de um aerof\u00f3lio ser projetado para produzir uma for\u00e7a desejada de sustenta\u00e7\u00e3o \\(f_l\\) (perpendicular \u00e0 velocidade \\(v\\)), ele tamb\u00e9m produz uma for\u00e7a indesejada de arrasto \\(f_d\\) (paralela \u00e0 velocidade \\(v\\)): $$     f_l = \\frac{1}{2} \\rho A C_l v^2      \\qquad     f_d = \\frac{1}{2} \\rho A C_d v^2  $$</p> <p>Onde:</p> <ul> <li>\\(\\rho\\) - Densidade do ar (\\(kg/m^3\\))</li> <li>\\(A\\) - \u00c1rea de superf\u00edcie (\\(m^2\\))</li> <li>\\(C_l\\) - Coeficiente de sustenta\u00e7\u00e3o (adimensional)</li> <li>\\(C_d\\) - Coeficiente de arrasto (adimensional)</li> <li>\\(v\\) - Velocidade linear do aerof\u00f3lio (\\(m/s\\))</li> </ul>"},{"location":"basic_concepts/aerodynamics/#coeficientes-aerodinamicos","title":"Coeficientes aerodin\u00e2micos","text":"<p>Os coeficientes de sustenta\u00e7\u00e3o e arrasto n\u00e3o s\u00e3o constantes, eles variam conforme as seguintes condi\u00e7\u00f5es aerodin\u00e2micas:</p> <ul> <li>\u00c2ngulo de ataque (\\(\\alpha\\)), que \u00e9 o \u00e2ngulo que a linha m\u00e9dia do aerof\u00f3lio (tamb\u00e9m chamada de ``corda'') faz com o vetor velocidade</li> <li>N\u00famero de Reynolds (\\(\\frac{\\rho v D}{\\mu}\\)), que \u00e9 uma medida adimensional e define o regime de escoamento do ar (laminar ou turbulento)</li> <li>N\u00famero Mach (\\(\\frac{v}{v_s}\\)), que \u00e9 a raz\u00e3o entre a velocidade e a velocidade do som e define o regime de velocidade (subs\u00f4nica, supers\u00f4nica e hipers\u00f4nica)</li> </ul> <p>Para aerof\u00f3lios que se movem a velocidades subs\u00f4nicas (\\(&lt;1.000km/h\\)), apenas o \u00e2ngulo de ataque \\(\\alpha\\), representado na figura abaixo, acaba apresentando uma influ\u00eancia significativa.</p> <p></p> <p>H\u00e1 diversos perfils diferentes para um aerfof\u00f3lio. Um bastante conhecido e utilizado \u00e9 o perfil Clark Y, cujos coeficientes de arrasto e sustenta\u00e7\u00e3o em fun\u00e7\u00e3o do \u00e2ngulo de ataque s\u00e3o bem conhecidos e dados<sup>1</sup> pelo gr\u00e1fico abaixo.</p> <p></p> <p>Enquanto o coeficiente de arrasto s\u00f3 aumenta com o \u00e2ngulo de ataque, o coeficiente de sustenta\u00e7\u00e3o tem um ponto m\u00e1ximo (\\(\\alpha=18^{\\circ}\\)). Esse ponto \u00e9 conhecido como \"estol\" ou simplesmente \"perda de sustenta\u00e7\u00e3o\", e ele ocorre quando o fluxo de ar descola da asa (deixa de seguir o contorno superior da asa gerando uma turbul\u00eancia). Note que o coeficiente de sustenta\u00e7\u00e3o \u00e9 nulo com uma leve inclina\u00e7\u00e3o negativa (\\(\\alpha=-5^{\\circ}\\)), e negativo abaixo disso.</p> <p>Exerc\u00edcio 1</p> <p>Para consolidar esses conceitos, considere um drone de asas fixas (asa voadora) em cruzeiro, isto \u00e9, voando no plano com velocidade constante e as seguintes caracter\u00edsticas<sup>2</sup>:</p> <ul> <li>Massa de \\(40g\\) e comprimento de \\(10cm\\)</li> <li>Asas perfil Clark Y com \\(10cm\\) de envergadura</li> <li>Propulsores com \\(60\\%\\) de efici\u00eancia </li> <li>Bateria de \\(3,7V\\) e \\(350mAh\\)</li> </ul> a) Desenhe o diagrama de corpo livre das for\u00e7as que atuam nesse drone b) Determine a \u00e1rea total das asas do drone assumindo que seu corpo \u00e9 triangular \\[ \\begin{align*}     A &amp;= \\frac{10 \\cdot 10}{2} \\\\     A &amp;= 50 \\text{cm}^2 \\end{align*} \\] c) Determine os coeficientes de arrasto e sustenta\u00e7\u00e3o das asas do drone \\[ \\begin{align*}     C_l &amp;= 0,35 \\\\     C_d &amp;= 0,02 \\end{align*} \\] d) Determine a velocidade do drone \\[ \\begin{align*}     \\sum f_y &amp;= 0 \\\\     f_l - f_p &amp;= 0 \\\\     \\frac{1}{2} \\rho A C_l v^2 - mg &amp;= 0 \\\\     v &amp;= \\sqrt{\\frac{2mg}{\\rho AC_l}} \\\\     v &amp;= \\sqrt{\\frac{2 \\cdot 0,04 \\cdot 9,81}{1,225 \\cdot 50 \\times 10^{-4} \\cdot 0,35}} \\\\     v &amp;= 19,13 \\text{m/s} \\quad (\\approx 69\\text{km/h}) \\end{align*} \\] e) Determine a for\u00e7a de empuxo dos propulsores do drone \\[ \\begin{align*}     \\sum f_x &amp;= 0 \\\\     f_e - f_d &amp;= 0 \\\\     f_e - \\frac{1}{2} \\rho A C_d v^2  &amp;= 0 \\\\     f_e &amp;= \\frac{1}{2} \\rho A C_d v^2 \\\\     f_e &amp;= \\frac{1}{2} 1,225 \\cdot 50 \\times 10^{-4} \\cdot 0,02 \\cdot 19,13^2 \\\\     f_e &amp;= 0,0224 \\text{N} \\end{align*} \\] f) Determine o consumo energ\u00e9tico do drone \\[ \\begin{align*}     P_m &amp;= f_e v \\\\     P_m &amp;= 0,0224 \\cdot 19,13 \\\\     P_m &amp;= 0,429 \\text{W} \\end{align*} \\] \\[ \\begin{align*}     \\eta &amp;= \\frac{P_m}{P_e} \\\\     P_e &amp;= \\frac{P_m}{\\eta} \\\\     P_e &amp;= \\frac{0,429}{0,6} \\\\     P_e &amp;= 0,715 \\text{W} \\end{align*} \\] g) Determine quanto tempo que o drone consegue permanecer no ar \\[ \\begin{align*}     E &amp;= P_e \\Delta t \\\\     e_s i_s &amp;= P_e \\Delta t \\\\     \\Delta t &amp;= \\frac{e_s i_s}{P_e} \\\\     \\Delta t &amp;= \\frac{3,7 \\cdot ( 0,35 \\cdot 3600)}{0,715} \\\\     \\Delta t &amp;= 6.519 \\text{s} \\quad (\\approx 1\\text{h}49\\text{min}) \\end{align*} \\]"},{"location":"basic_concepts/aerodynamics/#helice","title":"\ud83d\ude81 H\u00e9lice","text":"<p>Uma h\u00e9lice \u00e9 composta por \\(n\\) p\u00e1s, onde cada p\u00e1 pode ser interpretada como um aerof\u00f3lio.</p>"},{"location":"basic_concepts/aerodynamics/#forcas-e-torques-aerodinamicos","title":"For\u00e7as e torques aerodin\u00e2micos","text":"<p>Quando a h\u00e9lice rotaciona, surgem for\u00e7as de sustenta\u00e7\u00e3o e arrasto em cada uma de suas p\u00e1s, conforme a figura abaixo.</p> <p></p> <p>Onde:</p> <ul> <li>\\(d\\) - Dist\u00e2ncia do centro de press\u00e3o ao eixo de rota\u00e7\u00e3o (\\(m\\))</li> <li>\\(\\omega\\) - Velocidade angular da h\u00e9lice (\\(rad/s\\))</li> </ul> <p>Exerc\u00edcio 2</p> <p>Determine as for\u00e7as de sustenta\u00e7\u00e3o \\(f_l\\) e arrasto \\(f_d\\) nas p\u00e1s da h\u00e9lice em fun\u00e7\u00e3o de sua velocidade angular</p> Resposta \\[ \\begin{align*}     f_l &amp;= \\frac{1}{2} \\rho A C_l v^2 \\\\      f_l &amp;= \\frac{1}{2} \\rho A C_l (\\omega d )^2 \\\\     f_l &amp;= \\frac{1}{2} \\rho A C_l d^2 \\omega^2  \\end{align*} \\] \\[ \\begin{align*}     f_d &amp;= \\frac{1}{2} \\rho A C_d v^2 \\\\      f_d &amp;= \\frac{1}{2} \\rho A C_d (\\omega d )^2 \\\\     f_d &amp;= \\frac{1}{2} \\rho A C_d d^2 \\omega^2  \\end{align*} \\] <p>As for\u00e7as de sustenta\u00e7\u00e3o e arrasto em cada uma das p\u00e1s podem ser representadas por uma \u00fanica for\u00e7a de sustenta\u00e7\u00e3o e torque de arrasto da h\u00e9lice, conforme a figura abaixo.</p> <p></p> <p>Exerc\u00edcio 3</p> <p>Determine a for\u00e7a de sustenta\u00e7\u00e3o \\(f\\) e torque de arrasto \\(\\tau\\) da h\u00e9lice</p> Resposta \\[ \\begin{align*}     f &amp;= 2 f_l \\\\     f &amp;= 2 \\left( \\frac{1}{2} \\rho A C_l d^2 \\omega^2  \\right) \\\\     f &amp;= \\rho A C_l d^2 \\omega^2  \\end{align*} \\] \\[ \\begin{align*}     \\tau &amp;= 2 \\left( d f_d \\right) \\\\      \\tau &amp;= 2 \\left( d \\left( \\frac{1}{2} \\rho A C_d d^2 \\omega^2 \\right) \\right) \\\\     \\tau &amp;= \\rho A C_d d^3 \\omega^2  \\end{align*} \\] <p>Como todos os par\u00e2metros s\u00e3o constantes e apenas a velocidade angular \\(\\omega\\) varia, a for\u00e7a de sustenta\u00e7\u00e3o e torque de arrasto de uma h\u00e9lice podem ser simplificados por:</p> \\[ f = \\underbrace{\\rho A C_l d^2}_{k_l} \\omega^2  \\qquad \\tau = \\underbrace{\\rho A C_d d^3}_{k_d} \\omega^2  \\] <p>Onde:</p> <ul> <li>\\(k_l\\) - Coeficiente de sustenta\u00e7\u00e3o da h\u00e9lice (\\(N.s^2/rad^2\\))</li> <li>\\(k_d\\) - Coeficiente de arrasto da h\u00e9lice (\\(N.m.s^2/rad^2\\))</li> </ul>"},{"location":"basic_concepts/aerodynamics/#constantes-aerodinamicas","title":"Constantes aerodin\u00e2micas","text":"<p>Ou seja, apenas dois par\u00e2metros definem a for\u00e7a e o torque que uma h\u00e9lice produz, que dependem do quadrado de sua velocidade angular:</p> <p></p> \\[ f = k_l \\omega^2  \\qquad \\tau = k_d \\omega^2  \\] <p>Exerc\u00edcio 4</p> <p>Com o aux\u00edlio de uma r\u00e9gua, estime<sup>3</sup> as constantes aerodin\u00e2micas das h\u00e9lices do Bitcraze Crazyflie e anote elas abaixo. Assuma que a h\u00e9lice pode ser aproximada a um perfil Clark Y com \u00e2ngulo de ataque \\(\\alpha = 5^\\circ\\), sendo a constante de sustenta\u00e7\u00e3o igual, por\u00e9m a constante de arrasto 10x maior<sup>4</sup>. </p> Resposta \\[ \\left\\{     \\begin{align*}         \\rho &amp;= 1,225 kg/m^3 \\\\         A &amp;= 2,5 \\cdot 0,5 = 1,25 cm^2 \\\\         d &amp;= 1,5 cm \\\\         C_l &amp;= 0,7 \\\\         C_d &amp;= 0,04 \\cdot 10 = 0,4      \\end{align*} \\right. \\] \\[ \\begin{align*}     k_l &amp;= \\rho A C_l d^2\\\\     k_l &amp;= 1,225 \\cdot (1,25 \\cdot 10^{-4}) \\cdot 0,7 \\cdot (1,5 \\times 10^{-2})^2 \\\\     k_l &amp;= 2,41 \\times10^{-8} \\text{N.s}^2\\text{/rad}^2 \\end{align*} \\] \\[ \\begin{align*}     k_d &amp;= \\rho A C_d d^3 \\\\     k_d &amp;= 1,225 \\cdot (1,25 \\cdot 10^{-4}) \\cdot 0,4 \\cdot (1,5 \\times 10^{-2})^3 \\\\     k_d &amp;= 2,07 \\times10^{-10} \\text{N.m.s}^2\\text{/rad}^2 \\end{align*} \\] <p>Esses dois par\u00e2metros ser\u00e3o determinados experimentalmente (\\(k_l\\) e \\(k_d\\)), e voc\u00ea ver\u00e1 que a chegar\u00e1 em valores muito pr\u00f3ximos aos estimados acima.</p> <p>Exerc\u00edcio 5</p> <p>Para consolidar esses conceitos, considere um drone multi-rotor (quadricoptero) pairando no ar, isto \u00e9, parado no espa\u00e7o com as seguintes caracter\u00edsticas<sup>2</sup>:</p> <ul> <li>Massa de \\(40g\\)</li> <li>H\u00e9lices com constante de sustenta\u00e7\u00e3o de \\(2,0\\times10^{-8} \\text{N}.\\text{s}^2/\\text{rad}^2\\) e constante de arrasto de \\(2,0\\times10^{-10} \\text{N}.\\text{m}.\\text{s}^2\\text{/rad}^2\\)</li> <li>Motores el\u00e9tricos com \\(90\\%\\) de efici\u00eancia </li> <li>Bateria de \\(3,7V\\) e \\(350mAh\\)</li> </ul> a) Desenhe o diagrama de corpo livre das for\u00e7as que atuam nesse drone b) Determine a velocidade angular das h\u00e9lices do drone \\[ \\begin{align*}     \\sum f_y &amp;= 0 \\\\     4 f - f_w &amp;= 0 \\\\     4 k_l \\omega^2 - mg &amp;= 0 \\\\     \\omega &amp;= \\sqrt{\\frac{mg}{4 k_l}} \\\\     \\omega &amp;= \\sqrt{\\frac{0,04 \\cdot 9,81}{4 \\cdot (2,0\\times10^{-8})}} \\\\     \\omega &amp;= 2.215 \\text{rad/s} \\quad (\\approx 21.149\\text{rpm}) \\end{align*} \\] c) Determine o torque dos motores do drone \\[ \\begin{align*}     \\sum \\tau &amp;= 0 \\\\     \\tau_m - \\tau_d &amp;= 0 \\\\     \\tau_m - k_d \\omega^2 &amp;= 0 \\\\     \\tau_m &amp;= k_d \\omega^2 \\\\     \\tau_m &amp;= 2,0 \\times 10 ^{-10} \\cdot 2215^2 \\\\     \\tau_m &amp;= 0,000981 \\text{N.m} \\\\ \\end{align*} \\] d) Determine o consumo energ\u00e9tico do drone \\[ \\begin{align*}     P_m &amp;= 4 \\tau_m \\omega \\\\     P_m &amp;= 4 \\cdot 0,000981 \\cdot 2215 \\\\     P_m &amp;= 8,69 \\text{W} \\end{align*}    \\] \\[ \\begin{align*}     \\eta &amp;= \\frac{P_m}{P_e} \\\\     P_e &amp;= \\frac{P_m}{\\eta} \\\\     P_e &amp;= \\frac{8,69}{0,9} \\\\     P_e &amp;= 9,66 \\text{W} \\end{align*} \\] e) Determine quanto tempo que o drone consegue permanecer no ar \\[ \\begin{align*}     E &amp;= P_e \\Delta t \\\\     e_s i_s &amp;= P_e \\Delta t \\\\     \\Delta t &amp;= \\frac{e_s i_s}{P_e} \\\\     \\Delta t &amp;= \\frac{3,7 (\\cdot 0,35 \\cdot 3600)}{9,66} \\\\     \\Delta t &amp;= 483\\text{s} \\quad (\\approx 8\\text{min}) \\end{align*} \\] <p>Compare este resultado, do drone multi rotor, com o anterior, do drone de asas fixa. Note como o drone de asa fixa consegue permanecer muito mais tempo no ar (&gt;10x), com a desvatagem de n\u00e3o conseguir permanecer parado e nem decolar/pousar na vertical como um drone multi-rotor.</p> <ol> <li> <p>Assumindo que o n\u00famero de Reynolds e o n\u00famero Mach permane\u00e7am dentro de uma determinada faixa de valores.\u00a0\u21a9</p> </li> <li> <p>Considere \\(g = 9,81\\text{m/s}^2\\) e \\(\\rho = 1,225\\text{kg/m}^3\\) \u21a9\u21a9</p> </li> <li> <p>Estamos preocupados apenas com a ordem de grandeza dos resultados.\u00a0\u21a9</p> </li> <li> <p>Devido \u00e0 turbul\u00eancia gerada pela h\u00e9lice.\u00a0\u21a9</p> </li> </ol>"},{"location":"basic_concepts/mixer/","title":"Mixer","text":"<p>Esta se\u00e7\u00e3o descreve as for\u00e7as e torques que atuam em um quadric\u00f3ptero e como elas influenciam o seu comportamento din\u00e2mico.</p>"},{"location":"basic_concepts/mixer/#movimentos-basicos-de-um-quadricoptero","title":"\u2195\ufe0f Movimentos b\u00e1sicos de um quadric\u00f3ptero","text":"<p>Um quadric\u00f3ptero possui 4 h\u00e9lices que, uma vez em movimento com velocidades angulares \\(\\omega_1\\), \\(\\omega_2\\), \\(\\omega_3\\) e \\(\\omega_4\\), produzem 4 for\u00e7as de sustenta\u00e7\u00e3o \\(f_1\\), \\(f_2\\), \\(f_3\\) e \\(f_4\\) e 4 torques de arrasto \\(\\tau_1\\), \\(\\tau_2\\), \\(\\tau_3\\) e \\(\\tau_4\\), conforme a figura abaixo.</p> <p></p> <p>Para um quadric\u00f3ptero se movimentar verticalmente, basta variar as velocidades angulares das 4 h\u00e9lices simultaneamente, conforme a figura abaixo.</p> <p>Enquanto que, para um quadric\u00f3ptero rotacionar em torno de seus eixos, basta variar as velocidades angulares de 2 h\u00e9lices simultaneamente, conforme a figura abaixo.</p> <p>Exerc\u00edcio 1</p> <p>Sobre os movimentos de um quadric\u00f3ptero, determine as respostas a seguir. </p> a) Quantas formas diferentes \u00e9 poss\u00edvel transladar um quadric\u00f3ptero <p>3 (ao longo dos eixos \\(x\\), \\(y\\) e \\(z\\))</p> b) Quantas formas diferentes \u00e9 poss\u00edvel rotacionar um quadric\u00f3ptero <p>3 (em torno dos eixos \\(x\\), \\(y\\) e \\(z\\)) </p> c) Quantos graus de liberdade possui um quadric\u00f3ptero <p>6 (3 de transla\u00e7\u00e3o + 3 de rota\u00e7\u00e3o) </p> d) Como o quadric\u00f3ptero realiza movimentos de transla\u00e7\u00e3o no plano (eixos \\(x\\) e \\(y\\)) <p>Atrav\u00e9s de uma composi\u00e7\u00e3o de movimentos de transla\u00e7\u00e3o (ao longo do eixo \\(z\\)) e rota\u00e7\u00e3o (em torno dos eixos \\(x\\) e \\(y\\)) </p>"},{"location":"basic_concepts/mixer/#transformacao-de-entradas","title":"\ud83d\udd22 Transforma\u00e7\u00e3o de entradas","text":"<p>As 4 for\u00e7as \\(f_i\\) e 4 torques \\(\\tau_i\\) das h\u00e9lices podem ser representadas por 1 \u00fanica for\u00e7a de propuls\u00e3o total \\(f_t\\) e 3 torques \\(\\tau_x\\), \\(\\tau_y\\) e \\(\\tau_z\\), um em torno de cada eixo do quadric\u00f3ptero, conforme a figura abaixo.</p> <p></p> <p>Na sec\u00e7\u00e3o de aerodin\u00e2mica verificamos que as for\u00e7as e torques das h\u00e9lices s\u00e3o proporcionais ao quadrado de suas velocidades angulares:</p> \\[ \\left\\{ \\begin{array}{l}     f_i = k_l \\omega_i^2 \\\\     \\tau_i = k_d \\omega_i^2 \\\\ \\end{array} \\right. \\] <p>Isso significa que as 4 equa\u00e7\u00f5es determinadas anteriormente podem ser escritas no formato matricial:</p> \\[ \\begin{bmatrix}     f_t \\\\     \\tau_x \\\\     \\tau_y \\\\     \\tau_z \\end{bmatrix} = M  \\begin{bmatrix}     \\omega_1^2 \\\\     \\omega_2^2 \\\\     \\omega_3^2 \\\\     \\omega_4^2 \\end{bmatrix} \\] <p>Onde \\(M\\) \u00e9 uma matriz \\(4\\times4\\) que transforma as velocidades angulares das h\u00e9lices na for\u00e7a total e nos torques de um quadric\u00f3ptero.</p> <p>Exerc\u00edcio 2</p> <p>Determine a matriz \\(M\\) em fun\u00e7\u00e3o das constantes de sustenta\u00e7\u00e3o e arrasto da h\u00e9lice \\(k_l\\) e \\(k_d\\) e do comprimento \\(l\\). </p> Resposta \\[ M =  \\begin{bmatrix}      k_l &amp; k_l &amp; k_l &amp; k_l \\\\      -k_l l &amp; -k_l l &amp; k_l l &amp; k_l l \\\\      -k_l l &amp; k_l l &amp; k_l l &amp; -k_l l  \\\\      -k_d &amp; k_d &amp; -k_d &amp; k_d  \\end{bmatrix} \\] <p>Para obter as velocidades angulares das h\u00e9lices em fun\u00e7\u00e3o da for\u00e7a total e dos torques, basta multiplicar a equa\u00e7\u00e3o anterior pela matriz inversa \\(M^{-1}\\):</p> \\[ \\begin{bmatrix}     \\omega_1^2 \\\\     \\omega_2^2 \\\\     \\omega_3^2 \\\\     \\omega_4^2 \\end{bmatrix} = M^{-1}  \\begin{bmatrix}     f_t \\\\     \\tau_x \\\\     \\tau_y \\\\     \\tau_z \\end{bmatrix} \\] <p>Exerc\u00edcio 3</p> <p>Determine a matriz inversa \\(M^{-1}\\) (dica: utilize o Symbolic Math Toolbox do MATLAB).</p> Resposta \\[ M^{-1} =  \\begin{bmatrix}      \\frac{1}{4 k_l} &amp; - \\frac{1}{4 k_l l} &amp; - \\frac{1}{4 k_l l} &amp; - \\frac{1}{4 k_d}  \\\\      \\frac{1}{4 k_l} &amp; - \\frac{1}{4 k_l l} &amp; \\frac{1}{4 k_l l} &amp; \\frac{1}{4 k_d} \\\\      \\frac{1}{4 k_l} &amp; \\frac{1}{4 k_l l} &amp; \\frac{1}{4 k_l l} &amp; - \\frac{1}{4 k_d} \\\\      \\frac{1}{4 k_l} &amp; \\frac{1}{4 k_l l} &amp; - \\frac{1}{4 k_l l} &amp; \\frac{1}{4 k_d}  \\end{bmatrix} \\]"},{"location":"identification/drag_constant/","title":"Identifica\u00e7\u00e3o da constante de arrasto","text":"<p>Nesta sec\u00e7\u00e3o, voc\u00ea ir\u00e1 determinar experimentalmente a constante de arrasto das h\u00e9lices \\(k_d\\).</p>"},{"location":"identification/drag_constant/#fundamentos-teoricos","title":"Fundamentos te\u00f3ricos","text":"<p>As h\u00e9lices de um quadricoptero atuam como superf\u00edcies aerodin\u00e2micas, acelerando o fluxo de ar atrav\u00e9s delas. Isso consome energia das baterias e produz for\u00e7as de sustenta\u00e7\u00e3o e torques de arrasto no quadricoptero. J\u00e1 deduzimos que o torque de arrasto de uma h\u00e9lice \\(\\tau\\) \u00e9 proporcional \u00e0 velocidade angular da h\u00e9lice \\(\\omega\\) ao quadrado.</p> <p></p> \\[     \\tau = k_d \\omega^2 \\] <p>Onde:</p> <ul> <li>\\(k_d\\) - Constante de arrasto (\\(N.m.s^2\\))   </li> </ul>"},{"location":"identification/drag_constant/#procedimento-experimental","title":"Procedimento experimental","text":""},{"location":"identification/lift_constant/","title":"Identifica\u00e7\u00e3o da constante de sustenta\u00e7\u00e3o","text":"<p>Nesta sec\u00e7\u00e3o, voc\u00ea ir\u00e1 determinar experimentalmente a constante de sustenta\u00e7\u00e3o das h\u00e9lices \\(k_l\\).</p>"},{"location":"identification/lift_constant/#fundamentos-teoricos","title":"\ud83d\udcda Fundamentos te\u00f3ricos","text":"<p>As h\u00e9lices de um quadricoptero atuam como superf\u00edcies aerodin\u00e2micas, acelerando o fluxo de ar atrav\u00e9s delas. Isso consome energia das baterias e produz for\u00e7as de sustenta\u00e7\u00e3o e torques de arrasto no quadricoptero. J\u00e1 deduzimos que a for\u00e7a de sustenta\u00e7\u00e3o de uma h\u00e9lice \\(f\\) \u00e9 proporcional \u00e0 velocidade angular da h\u00e9lice \\(\\omega\\) ao quadrado.</p> <p></p> \\[     \\tau = k_l \\omega^2 \\] <p>Onde:</p> <ul> <li>\\(k_l\\) - Constante de sustenta\u00e7\u00e3o (\\(N.s^2\\))   </li> </ul>"},{"location":"identification/lift_constant/#procedimento-experimental","title":"\ud83e\uddea Procedimento experimental","text":"<p>Para medir a for\u00e7a de de sustenta\u00e7\u00e3o \\(f\\) da h\u00e9lice, voc\u00ea pode utilizar um suporte e uma balan\u00e7a. Para prender o quadcoptero no suporte, voc\u00ea precisa encaix\u00e1-lo pela lateral e depois prender dois parafusos. </p> <p>O suporte possui um im\u00e3 em sua base que deixa ele bem firma na balan\u00e7a. Voc\u00ea pode zerar a balan\u00e7a com o quadcoptero apertando o bot\u00e3o <code>T</code>, assim, qualquer for\u00e7a de sustenta\u00e7\u00e3o que as h\u00e9lices produzirem vai gerar uma leitura negativa na balan\u00e7a.</p> <p>Voc\u00ea deve carregar no drone um programa que ligue os quatro motores com um determinado valor de velocidade angular \\(\\omega\\). Ser\u00e3o levantados dados de peso na balan\u00e7a para 10 valores distintos de \\(omega\\) (\\(200rad/s\\) at\u00e9 \\(2.000rad/s\\)), e, para cada valor de \\(\\omega\\), voc\u00ea dever\u00e1 realizar o experimento 3 vezes e tirar uma m\u00e9dia. Para facilitar o experimento, voc\u00ea pode controlar o valor de \\(\\omega\\) com os bot\u00f5es <code>Up</code> e <code>Down</code> do Command Based Flight Control atrav\u00e9s do CFClient.</p> <p></p> <p>O c\u00f3digo abaixo possui um exemplo de programa que faz exatamente isso.</p> lab3_experiment.c<pre><code>#include \"FreeRTOS.h\"      // FreeRTOS core definitions (needed for task handling and timing)\n#include \"task.h\"          // FreeRTOS task functions (e.g., vTaskDelay)\n#include \"supervisor.h\"    // Functions to check flight status (e.g., supervisorIsArmed)\n#include \"commander.h\"     // Access to commanded setpoints (e.g., commanderGetSetpoint)\n#include \"motors.h\"        // Low-level motor control interface (e.g., motorsSetRatio)\n#include \"debug.h\"         // Debug printing functions (e.g., DEBUG_PRINT)\n\n// Motor constants (derived in Lab 2)\n// These represent coefficients of the quadratic model: PWM = a_2 * omega^2 + a_1 * omega\nconst float a_2 = 6.18e-8;\nconst float a_1 = 2.34e-4;\n\n// Global variables to store the desired setpoint, the current state (not used here), \n// the computed PWM value, and the desired angular velocity (omega)\nsetpoint_t setpoint;\nstate_t state;\nfloat pwm;\nfloat omega;\n\n// Main application\nvoid appMain(void *param)\n{\n    // Infinite loop (runs forever)\n    while (true)\n    {\n        // Check if the drone is armed (i.e., ready to fly)\n        if (supervisorIsArmed())\n        {\n            // Fetch the latest setpoint from the commander and also fetch the current estimated state (not used here)\n            commanderGetSetpoint(&amp;setpoint, &amp;state);\n\n            // Compute an angular velocity value proportional to the commanded altitude (Z axis position)\n            // The altitude command increases in 0.5 m steps, and we want the angular velocity to increase \n            // by 200 rad/s for each step. Therefore, we multiply Z by 400.0 so that: 0.5 m \u2192 200 rad/s\n            omega = (setpoint.position.z) * 400.0f;\n\n            // Print the computed omega value to the debug console (rounded to nearest integer)\n            DEBUG_PRINT(\"Omega (rad/s): %.0f\\n\", (double)omega);\n\n            // Convert angular velocity to PWM using the motor model: PWM = a_2 * omega^2 + a_1 * omega\n            pwm = a_2 * omega * omega + a_1 * omega;\n        }\n        else\n        {\n            // If not armed, stop the motors (set PWM to zero)\n            pwm = 0.0f;\n        }\n\n        // Send the PWM signal to all four motors (M1\u2013M4), scaling it to match the expected range [0, UINT16_MAX]\n        motorsSetRatio(MOTOR_M1, pwm * UINT16_MAX);\n        motorsSetRatio(MOTOR_M2, pwm * UINT16_MAX);\n        motorsSetRatio(MOTOR_M3, pwm * UINT16_MAX);\n        motorsSetRatio(MOTOR_M4, pwm * UINT16_MAX);\n\n        // Wait for 100 milliseconds before running the next iteration (10 Hz control loop)\n        vTaskDelay(pdMS_TO_TICKS(100));\n    }\n}\n</code></pre> <p>As etapas para coletar um dado s\u00e3o as seguintes:</p> <ol> <li>Garanta que a bateria do drone est\u00e1 carregada </li> <li>Prenda o drone no dispositivo e zere a balan\u00e7a presionando o bot\u00e3o <code>T</code></li> <li>Arme o drone apertando o bot\u00e3o <code>Arm</code> no CFClient</li> <li>Ligue o motor com um valor espec\u00edfico de velocidade angular \\(\\omega\\) com o Command Based Flight Control do CFClient</li> <li>Anote o n\u00famero que aparece na tela</li> <li>Repita as etapas 4-5 para outros valores de sinal PWM</li> </ol> <p>Ap\u00f3s o experimento, voc\u00ea dever\u00e1 coletar dados para preencher a tabela abaixo.</p> \\(\\omega(rad/s)\\) \\(W_1(g)\\) \\(W_2(g)\\) \\(W_3(g)\\) \\(200\\) \\(400\\) \\(600\\) \\(800\\) \\(1200\\) \\(1400\\) \\(1600\\) \\(1800\\) \\(2000\\)"},{"location":"identification/lift_constant/#analise-de-dados","title":"\ud83d\udcc8 An\u00e1lise de Dados","text":"<p>Utilizando os dados coletados, voc\u00ea dever\u00e1 ajustar uma curva que correlacione a velocidade angular \\(\\omega\\) com a for\u00e7a de sustenta\u00e7\u00e3o \\(f\\) da h\u00e9lice (note que voc\u00ea precisa converter a a leitura da balan\u00e7a de \\(g\\) para \\(N\\) e devidir por 4, dado que estamos interessados na for\u00e7a de uma \u00fanica h\u00e9lice).</p> <p>Voc\u00ea j\u00e1 sabe que o melhor ajuste para esta curva \u00e9 uma fun\u00e7\u00e3o polinomial de 2\u00ba grau cujos termos de ordem um e zero s\u00e3o nulos:</p> \\[     f = k_l \\omega^2 \\] <p>Determine o valor de \\(k_l\\) fazendo esse ajuste de curva (dica: utilize o Curve Fitting Toolbox do MATLAB). Anote o valor obtido em algum lugar pois ele ser\u00e1 utilizado em breve.</p>"},{"location":"identification/lift_constant/#validacao-dos-resultados","title":"\u2705 Valida\u00e7\u00e3o dos resultados","text":"<p>Compare o resultado obtido com o estimado anteriormente. \u00c9 esperado que a constante de sustenta\u00e7\u00e3o \\(k_l\\) seja da ordem de grandeza de \\(10^{-8}N.s^2\\). </p>"},{"location":"identification/motor_coeficients/","title":"Identifica\u00e7\u00e3o dos coeficientes do motor","text":"<p>Nesta sec\u00e7\u00e3o, voc\u00ea ir\u00e1 determinar experimentalmente os coeficientes do motor el\u00e9trico.</p>"},{"location":"identification/motor_coeficients/#fundamentos-teoricos","title":"Fundamentos te\u00f3ricos","text":"<p>O PWM (\"pulse width modulation\") \u00e9 uma t\u00e9cnica para controlar a pot\u00eancia de um sinal utilizando uma comuta\u00e7\u00e3o digital. Ao mudar rapidamente o sinal entre o m\u00e1ximo e zero (\"on-off\"), e variando a fra\u00e7\u00e3o de tempo que o sinal est\u00e1 no m\u00e1ximo, pode-se controlar a pot\u00eancia transmitida (isto \u00e9, modulando a largura do pulso).</p> <p> </p> <p>Este \u00e9 o mecanismo utilizado pelo Crazyflie para acionar seus motores. J\u00e1 sabemos que no c\u00f3digo \u00e9 poss\u00edvel definir um valor real entre <code>0.0</code> e <code>1.0</code> que corresponde ao sinal PWM do motor. </p> <p>Voc\u00ea ir\u00e1 implementar uma fun\u00e7\u00e3o que, dada uma velocidade angular desejada \\(\\omega\\), determine o sinal PWM correspondente. </p>"},{"location":"identification/motor_coeficients/#procedimento-experimental","title":"Procedimento experimental","text":"<p>Para medir a velocidade angular \\(\\omega\\) da h\u00e9lice, voc\u00ea pode utilizar um instrumento de medi\u00e7\u00e3o do n\u00famero de rota\u00e7\u00f5es chamado tac\u00f4metro. Para utiliz\u00e1-lo, voc\u00ea deve fixar um pequeno peda\u00e7o de fita refletora em uma das h\u00e9lices. Certifique-se de usar apenas um pequeno peda\u00e7o de fita e aplicar suavemente na h\u00e9lice, caso contr\u00e1rio voc\u00ea interferir\u00e1 no fluxo de ar e obter\u00e1 dados ruins. </p> <p></p> <p>O tac\u00f4metro pode detectar quando a tira passa pelo seu feixe de luz, assim, a velocidade de rota\u00e7\u00e3o \u00e9 calculada contando quantas vezes a tira passa em um determinado per\u00edodo de tempo. O tac\u00f4metro DT-2234C+ registra a velocidade angular enquanto voc\u00ea pressiona o bot\u00e3o <code>TEST</code> e, uma vez que este bot\u00e3o \u00e9 liberado, ele armazena os valores m\u00ednimo, m\u00e1ximo e m\u00e9dio, que voc\u00ea pode conferir apertando o bot\u00e3o <code>MEM</code>.</p> <p></p> <p>Voc\u00ea deve carregar no drone um programa que ligue apenas o motor cuja h\u00e9lice est\u00e1 com o peda\u00e7o de fita refletora com um determinado valor de sinal PWM. Ser\u00e3o levantados dados de velocidade angular da h\u00e9lice para 10 valores distintos de sinal PWM (<code>0.1</code> at\u00e9 <code>1.0</code>), e, para cada valor de sinal PWM, voc\u00ea dever\u00e1 realizar o experimento 3 vezes e tirar uma m\u00e9dia. Para facilitar o experimento, voc\u00ea pode controlar o valor do PWM com os bot\u00f5es <code>Up</code> e <code>Down</code> do Command Based Flight Control atrav\u00e9s do CFClient.</p> <p></p> <p>O c\u00f3digo abaixo possui um exemplo de programa que faz exatamente isso.</p> lab2_experiment.c<pre><code>#include \"FreeRTOS.h\"      // FreeRTOS core definitions (needed for task handling and timing)\n#include \"task.h\"          // FreeRTOS task functions (e.g., vTaskDelay)\n#include \"supervisor.h\"    // Functions to check flight status (e.g., supervisorIsArmed)\n#include \"commander.h\"     // Access to commanded setpoints (e.g., commanderGetSetpoint)\n#include \"motors.h\"        // Low-level motor control interface (e.g., motorsSetRatio)\n\n// Global variables to store the desired setpoint, the current state (not used here) and the computed PWM value.\nsetpoint_t setpoint;\nstate_t state;\nfloat pwm;\n\n// Main application\nvoid appMain(void *param)\n{\n    // Infinite loop (runs forever)\n    while (true)\n    {\n        // Check if the drone is armed (i.e., ready to fly)\n        if (supervisorIsArmed())\n        {\n            // Fetch the latest setpoint from the commander and also fetch the current estimated state (not used here)\n            commanderGetSetpoint(&amp;setpoint, &amp;state);\n\n            // Compute a PWM value proportional to the commanded altitude (Z axis position)\n            // The altitude command increases in 0.5 m steps, and we want the PWM to increase by 0.1 for each step.\n            // Therefore, we divide Z by 5.0 so that: 0.5 m \u2192 0.1 PWM\n            pwm = (setpoint.position.z) / 5.0f;\n        }\n        else\n        {\n            // If not armed, stop the motor (set PWM to zero)\n            pwm = 0.0f;\n        }\n        // Send the PWM signal to motor M1, scaling it to match the expected range [0, UINT16_MAX]\n        motorsSetRatio(MOTOR_M1, pwm * UINT16_MAX);\n        // Wait for 100 milliseconds before running the next iteration (10 Hz control loop)\n        vTaskDelay(pdMS_TO_TICKS(100));\n    }\n}\n</code></pre> <p>As etapas para coletar um dado s\u00e3o as seguintes:</p> <ol> <li>Garanta que a bateria do drone est\u00e1 carregada </li> <li>Prenda o drone na mesa com uma fita crepe</li> <li>Arme o drone apertando o bot\u00e3o <code>Arm</code> no CFClient</li> <li>Ligue o motor com um valor espec\u00edfico de sinal PWM com o Command Based Flight Control do CFClient</li> <li>Aponte o tac\u00f4metro para a h\u00e9lice segurando a aproximadamente \\(30cm\\) de dist\u00e2ncia e, em seguida, pressione o bot\u00e3o <code>TEST</code> </li> <li>Mantenha o bot\u00e3o <code>TEST</code> pressionado o tempo todo, certificando-se de que o feixe aponta para onde a faixa refletora passa  </li> <li>Mantenha essa posi\u00e7\u00e3o por alguns segundos e solte o bot\u00e3o <code>TEST</code> </li> <li>Pressione o bot\u00e3o <code>MEM</code> uma vez e espere aparecer a segunda leitura, que corresponde \u00e0 velocidade m\u00e1xima (em \\(rpm\\)) observada durante o experimento  </li> <li>Anote o n\u00famero que aparece na tela</li> <li>Repita as etapas 4-9 para outros valores de sinal PWM</li> </ol> <p>Ap\u00f3s o experimento, voc\u00ea dever\u00e1 coletar dados para preencher a tabela abaixo.</p> PWM N1 (rpm) N2 (rpm) N3 (rpm) <code>0.1</code> <code>0.2</code> <code>0.3</code> <code>0.4</code> <code>0.5</code> <code>0.6</code> <code>0.7</code> <code>0.8</code> <code>0.9</code> <code>1.0</code>"},{"location":"identification/motor_coeficients/#analise-de-dados","title":"An\u00e1lise de Dados","text":"<p>Utilizando os dados coletados, voc\u00ea dever\u00e1 ajustar uma curva que correlacione a velocidade angular das h\u00e9lice \\(\\omega\\) com o sinal PWM correspondente do motor (note que voc\u00ea precisa converter a velocidade angular de \\(rpm\\) para \\(rad/s\\)).</p> <p>H\u00e1 diversos tipos de fun\u00e7\u00f5es de ajuste para esta curva (linear, exponencial, polinomial, etc.):</p> \\[     \\text{PWM} = f(\\omega) \\] <p>Para definir qual \u00e9 melhor para este caso, \u00e9 necess\u00e1rio se aprofundar na din\u00e2mica do sistema. O esquema eletromec\u00e2nico de um motor el\u00e9trico com uma h\u00e9lice pode ser visto no diagrama abaixo<sup>1</sup>.</p> <p></p> <p>Onde:</p> <ul> <li>\\(e_a\\) - Tens\u00e3o de armadura (\\(V\\))</li> <li>\\(i_a\\) - Corrente de armadura (\\(A\\))</li> <li>\\(R_a\\) - Resist\u00eancia de armadura (\\(\\Omega\\))</li> <li>\\(L_a\\) - Indut\u00e2ncia de armadura (\\(H\\))</li> <li>\\(e_b\\) - Tens\u00e3o contra-eletromotriz (\\(V\\))</li> <li>\\(\\omega\\) - Velocidade angular do motor/h\u00e9lice (\\(rad/s\\))</li> <li>\\(\\tau_m\\) - Torque do motor (\\(N.m\\))</li> <li>\\(k_d\\) - Constante de arrasto da h\u00e9lice (\\(N.m.s^2/rad^2\\))</li> <li>\\(b\\) - Coeficiente de atrito viscoso do motor (\\(N.m.s/rad\\))</li> <li>\\(I\\) - Momento de in\u00e9rcia do motor/h\u00e9lice (\\(kg.m^2\\))</li> </ul> <p>Exerc\u00edcio 1</p> <p>Aplique a lei de Kirchoff das tens\u00f5es no circuito de armadura.</p> Resposta \\[ \\begin{align*}     \\sum_{i=1}^n e_i &amp;= 0 \\\\     e_a - R_a i_a - L_a \\frac{d}{dt} i_a - e_b &amp;= 0 \\end{align*} \\] <p>Exerc\u00edcio 2</p> <p>Aplique a 2\u00ba lei de Newton em torno do eixo do motor.</p> Resposta \\[ \\begin{align*}     \\sum_{i=1}^n \\tau_i &amp;= I \\frac{d}{dt} \\omega \\\\     \\tau_m - k_d \\omega^2 - b \\omega &amp;= I \\frac{d}{dt} \\omega \\end{align*} \\] <p>Em um motor de corrente cont\u00ednua, o torque do motor \\(\\tau_m\\) \u00e9 diretamente proporcional \u00e0 corrente de armadura \\(i_a\\), e a tens\u00e3o contra-eletromotriz \\(e_b\\) \u00e9 diretamente proporcional \u00e0 velocidade angular \\(\\omega\\):</p> \\[ \\tau_m = K_m i_a  \\qquad e_b = K_m \\omega    \\] <p>Onde:</p> <ul> <li>\\(K_m\\) - Constante de torque do motor (\\(N.m/A\\) ou \\(V.s/rad\\)).</li> </ul> <p>Exerc\u00edcio 3</p> <p>Substitua o torque do motor \\(\\tau_m\\) e a tens\u00e3o contra-eletromotriz \\(e_b\\) nas duas equa\u00e7\u00f5es diferenciais obtidas anteriormente.</p> Resposta \\[ \\left\\{     \\begin{array}{l}         L_a \\dfrac{d}{dt} i_a + R_a i_a + K_m \\omega = e_a \\\\ \\\\         I \\dfrac{d}{dt} \\omega + k_d \\omega^2 + b \\omega - K_m i_a = 0     \\end{array} \\right. \\] <p>Quando o motor entra em regime, a corrente de armadura \\(i_a\\) e a velocidade angular \\(\\omega\\) tornam-se constantes (essa \u00e9 a defini\u00e7\u00e3o de ``regime''):</p> \\[     \\dfrac{d}{dt} i_a = 0 \\qquad \\dfrac{d}{dt} \\omega = 0 \\] <p>Exerc\u00edcio 4</p> <p>Iguale as derivadas da corrente de armadura \\(i_a\\) e da velocidade angular \\(\\omega\\) a zero e isole a corrente de armadura \\(i_a\\) nas duas equa\u00e7\u00f5es.</p> Resposta \\[ \\begin{align*}         L_a \\cancelto{0}{\\dfrac{d}{dt} i_a} + R_a i_a + K_m \\omega &amp;= e_a \\\\         R_a i_a &amp;= e_a - K_m \\omega \\\\         i_a &amp;= \\dfrac{1}{R_a} e_a - \\dfrac{K_m}{R_a} \\omega \\end{align*} \\] \\[ \\begin{align*}     I \\cancelto{0}{\\dfrac{d}{dt} \\omega} + k_d \\omega^2 + b \\omega - K_m i_a &amp;= 0 \\\\     K_m i_a &amp;= k_d \\omega^2 + b \\omega \\\\     i_a &amp;= \\dfrac{k_d}{K_m} \\omega^2 + \\dfrac{b}{K_m} \\omega \\end{align*} \\] <p>Exerc\u00edcio 5</p> <p>Iguale a corrente de armadura \\(i_a\\) obtida em cada uma das equa\u00e7\u00f5es e isole a tens\u00e3o de armadura \\(e_a\\) na equa\u00e7\u00e3o.</p> Resposta \\[ \\begin{align*}     \\dfrac{1}{R_a} e_a - \\dfrac{K_m}{R_a} \\omega &amp;= \\dfrac{k_d}{K_m} \\omega^2 + \\dfrac{b}{K_m} \\omega\\\\     \\dfrac{1}{R_a} e_a &amp;= \\dfrac{k_d}{K_m} \\omega^2 + \\dfrac{b}{K_m} \\omega + \\dfrac{K_m}{R_a} \\omega \\\\     e_a &amp;= \\dfrac{R_a k_d}{K_m} \\omega^2 + \\dfrac{R_a b + K_m^2}{K_m} \\omega \\end{align*} \\] <p>O sinal PWM \u00e9 a raz\u00e3o entre a tens\u00e3o de armadura \\(e_a\\) e a tens\u00e3o da bateria \\(e_s\\):</p> \\[     \\text{PWM} = \\frac{e_a}{e_s} \\] <p>Exerc\u00edcio 6</p> <p>Substitua a tens\u00e3o de armadura \\(e_a\\) na equa\u00e7\u00e3o anterior e isole o sinal PWM na equa\u00e7\u00e3o.</p> Resposta \\[ \\begin{align*}     e_a &amp;= \\dfrac{R_a k_d}{K_m} \\omega^2 + \\dfrac{R_a b + K_m^2}{K_m} \\omega \\\\     e_s \\text{PWM} &amp;= \\dfrac{R_a k_d}{K_m} \\omega^2 + \\dfrac{R_a b + K_m^2}{K_m} \\omega \\\\     \\text{PWM} &amp;= \\dfrac{R_a k_d}{K_me_s} \\omega^2 + \\dfrac{R_a b + K_m^2}{K_me_s} \\omega \\end{align*} \\] <p>Voc\u00ea deve ter chegado a:</p> \\[     \\text{PWM} =\\dfrac{R_a k_d}{K_me_s} \\omega^2 + \\dfrac{R_a b + K_m^2}{K_me_s} \\omega \\] <p>Como \\(R_a\\), \\(k_d\\), \\(b\\), \\(K_m\\) e \\(e_s\\) s\u00e3o par\u00e2metros constantes, podemos agrup\u00e1-los em duas constantes:</p> \\[     \\text{PWM} = \\underbrace{\\dfrac{R_a k_d}{K_me_s}}_{a_2} \\omega^2 + \\underbrace{\\dfrac{R_a b + K_m^2}{K_me_s}}_{a_1} \\omega \\] <p>Ou seja, o tipo de fun\u00e7\u00e3o mais adequado para realizar esse ajuste de curva \u00e9 uma fun\u00e7\u00e3o polinomial de 2\u00ba grau cujo termo de ordem zero \u00e9 nulo:</p> \\[     \\text{PWM} = a_2 \\omega^2 + a_1 \\omega + \\cancelto{0}{a_0}   \\] <p>Dessa forma, ao inv\u00e9s de determinar os valores de cada par\u00e2metro (\\(R_a\\), \\(k_d\\), \\(b\\), \\(K_m\\) e \\(e_s\\)), voc\u00ea ir\u00e1 determinar experimentalmente apenas os valores das constantes \\(a_2\\) e \\(a_1\\) (dica: utilize o Curve Fitting Toolbox do MATLAB).</p>"},{"location":"identification/motor_coeficients/#validacao-dos-resultados","title":"Valida\u00e7\u00e3o dos resultados","text":"<p>Uma vez determinadas as constantes \\(a_2\\) e \\(a_1\\), declare os seus valores no c\u00f3digo (linhas 10 e 11) e modifique seu programa para que, dada uma velocidade angular \\(\\omega\\) comandada (linhas 30 e 35), ele determine o sinal PWM correspondente (linha 41) e envie isso ao motor M1 (linha 50).</p> lab2_validation.c<pre><code>#include \"FreeRTOS.h\"      // FreeRTOS core definitions (needed for task handling and timing)\n#include \"task.h\"          // FreeRTOS task functions (e.g., vTaskDelay)\n#include \"supervisor.h\"    // Functions to check flight status (e.g., supervisorIsArmed)\n#include \"commander.h\"     // Access to commanded setpoints (e.g., commanderGetSetpoint)\n#include \"motors.h\"        // Low-level motor control interface (e.g., motorsSetRatio)\n#include \"debug.h\"         // Debug printing functions (e.g., DEBUG_PRINT)\n\n// Motor constants (derived in Lab 2)\n// These represent coefficients of the quadratic model: PWM = a_2 * omega^2 + a_1 * omega\nconst float a_2 = 0.0f;\nconst float a_1 = 0.0f;\n\n// Global variables to store the desired setpoint, the current state (not used here), \n// the computed PWM value, and the desired angular velocity (omega)\nsetpoint_t setpoint;\nstate_t state;\nfloat pwm;\nfloat omega;\n\n// Main application\nvoid appMain(void *param)\n{\n    // Infinite loop (runs forever)\n    while (true)\n    {\n        // Check if the drone is armed (i.e., ready to fly)\n        if (supervisorIsArmed())\n        {\n            // Fetch the latest setpoint from the commander and also fetch the current estimated state (not used here)\n            commanderGetSetpoint(&amp;setpoint, &amp;state);\n\n            // Compute an angular velocity value proportional to the commanded altitude (Z axis position)\n            // The altitude command increases in 0.5 m steps, and we want the angular velocity to increase \n            // by 200 rad/s for each step. Therefore, we multiply Z by 400.0 so that: 0.5 m \u2192 200 rad/s\n            omega = (setpoint.position.z) * 400.0f;\n\n            // Print the computed omega value to the debug console (rounded to nearest integer)\n            DEBUG_PRINT(\"Omega (rad/s): %.0f\\n\", (double)omega);\n\n            // Convert angular velocity to PWM using the motor model: PWM = a_2 * omega^2 + a_1 * omega\n            pwm = a_2 * omega * omega + a_1 * omega;\n        }\n        else\n        {\n            // If not armed, stop the motors (set PWM to zero)\n            pwm = 0.0f;\n        }\n\n        // Send the PWM signal to motors M1, scaling it to match the expected range [0, UINT16_MAX]\n        motorsSetRatio(MOTOR_M1, pwm * UINT16_MAX);\n\n        // Wait for 100 milliseconds before running the next iteration (10 Hz control loop)\n        vTaskDelay(pdMS_TO_TICKS(100));\n    }\n}\n</code></pre> <p>O c\u00f3digo acima faz uso do Command Based Flight Control para comandar a velocidade angular \\(\\omega\\) em incrementos de \\(200rad/s\\). Voc\u00ea deve test\u00e1-lo verificando se a velocidade angular comandada est\u00e1 pr\u00f3xima<sup>2</sup> da leitura do tac\u00f4metro.</p> <ol> <li> <p>Embora o Crazyflie utilize um motor el\u00e9trico de corrente cont\u00ednua sem escovas e n\u00e3o com escovas, a equa\u00e7\u00e3o matem\u00e1tica de ambos \u00e9 equivalente.\u00a0\u21a9</p> </li> <li> <p>Ela n\u00e3o vai bater na v\u00edrgula, pois fizemos um ajuste de curva. No entanto, essa diverg\u00eancia n\u00e3o ser\u00e1 um problema pois ainda vamos fechar a malha de controle em um n\u00edvel superior.\u00a0\u21a9</p> </li> </ol>"}]}