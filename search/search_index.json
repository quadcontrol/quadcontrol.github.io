{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Bem-vindo!","text":"<p>Este site re\u00fane toda a documenta\u00e7\u00e3o da eletiva de Drones do Insper \u2014 uma esp\u00e9cie de apostila online, cuidadosamente organizada com:</p> <ul> <li>\ud83d\udcda Explica\u00e7\u00f5es te\u00f3ricas e f\u00f3rmulas fundamentais</li> <li>\ud83d\udcbb C\u00f3digos em C, Python e MATLAB</li> <li>\ud83d\uddbc\ufe0f Figuras, diagramas e v\u00eddeos demonstrativos</li> <li>\ud83d\udef8 Exemplos de aplica\u00e7\u00f5es pr\u00e1ticas</li> </ul> <p>Nosso objetivo \u00e9 ensinar conceitos de controle e programa\u00e7\u00e3o embarcada de forma pr\u00e1tica e acess\u00edvel, usando um quadricoptero real. Explore os t\u00f3picos no menu lateral \u2014 e boa jornada! \ud83d\ude80</p>"},{"location":"#sobre-a-eletiva","title":"Sobre a eletiva","text":"<p>Nesta eletiva, os alunos desenvolvem do zero todo o algoritmo de estima\u00e7\u00e3o e controle de um quadric\u00f3ptero \u2014 o Bitcraze Crazyflie 2.1 Brushless.</p> <p></p> <p>A jornada come\u00e7a com os cl\u00e1ssicos <code>led_blink.c</code> e <code>hello_world.c</code>, e termina com o drone voando sozinho. Ao longo do curso, o aluno:</p> <ul> <li>\ud83e\udde0 Programa um microcontrolador ARM(1) usando FreeRTOS(2)</li> <li>\ud83d\udce1 Trabalha com sensores embarcados (IMU(3), proximidade e fluxo \u00f3ptico) via I\u00b2C(4) e SPI(5)</li> <li>\ud83d\udd27 Controla motores BLDC(6) por meio de ESCs(7)</li> <li>\ud83d\udcbb Implementa em C(8) algoritmos de estima\u00e7\u00e3o e controle</li> </ul> <ol> <li>Chips compactos e eficientes, usados como \"c\u00e9rebro\" de muitos dispositivos embarcados, como drones, celulares e eletrodom\u00e9sticos.</li> <li>Sistema operacional leve e em tempo real (Real-Time Operating System), que permite rodar v\u00e1rias tarefas no microcontrolador de forma organizada e com alta precis\u00e3o de tempo.</li> <li>Unidade de Medi\u00e7\u00e3o Inercial (Inertial Measurement Unit), composta por aceler\u00f4metros e girosc\u00f3pios, usada para medir a orienta\u00e7\u00e3o.</li> <li>Protocolo de comunica\u00e7\u00e3o digital simples, que conecta sensores ao microcontrolador usando apenas dois fios.</li> <li>Protocolo de comunica\u00e7\u00e3o digital mais r\u00e1pido que o I\u00b2C, usado quando h\u00e1 necessidade de maior desempenho mas necessitando de quatro fios.</li> <li>Motores el\u00e9trico sem escovas (Brushless DC Motor), mais eficientes e dur\u00e1veis.</li> <li>Controlador Eletr\u00f4nico de Velocidade (Electronic Speed Controller), que regula a pot\u00eancia enviada aos motores e faz a comuta\u00e7\u00e3o eletr\u00f4nica na frequ\u00eancia correta.</li> <li>Linguagem de programa\u00e7\u00e3o de baixo n\u00edvel, muito utilizada em sistemas embarcados.</li> </ol> <p>A avalia\u00e7\u00e3o \u00e9 100% pr\u00e1tica: ao final do curso, o drone deve voar at\u00e9 um dos helipontos, cada um com uma nota associada \u00e0 sua dificuldade - quanto mais longe ou de dif\u00edcil acesso o heliponto, maior sua m\u00e9dia final na disciplina.</p> <p></p> <p>Quer ver um pouco disso na pr\u00e1tica? Assista o v\u00eddeo abaixo!</p> <ul> <li> <p> Pr\u00e9-requisitos</p> <p>Hardware, software e firmware necess\u00e1rios.</p> </li> <li> <p> Interface</p> <p>Atuadores e sensores.</p> </li> <li> <p> Fundamentos</p> <p>Conceitos te\u00f3ricos fundamentais.</p> </li> <li> <p> Identifica\u00e7\u00e3o</p> <p>Experimentos para identifica\u00e7\u00e3o de par\u00e2metros do sistema.</p> </li> <li> <p> Modelagem</p> <p>Modelagem matem\u00e1tica do sistema.</p> </li> <li> <p> Controle</p> <p>Arquitetura de estima\u00e7\u00e3o e controle.</p> </li> </ul>"},{"location":"pages/control/architecture/architecture/","title":"Arquitetura","text":"<p>Para controlar um drone, precisamos de uma arquitetura bem definida. Essa arquitetura estabelece como as informa\u00e7\u00f5es dos sensores s\u00e3o processadas por estimadores, comparadas com as refer\u00eancias pelos controladores e, por fim, enviadas como comandos aos atuadores.</p> <p>O diagrama abaixo resume essa sequ\u00eancia em blocos:</p> <p></p> <p>No diagrama:</p> <ul> <li>Os blocos representam as fun\u00e7\u00f5es que ser\u00e3o chamadas no loop principal.</li> <li>As setas representam as vari\u00e1veis que fluem de um bloco a outro.</li> </ul> <p>A passagem dessas informa\u00e7\u00f5es entre as fun\u00e7\u00f5es ser\u00e1 feita por meio de vari\u00e1veis globais(1), que atuar\u00e3o como o \u201cfio\u201d que conecta os m\u00f3dulos do sistema.</p> <ol> <li>Embora vari\u00e1veis globais n\u00e3o sejam a melhor pr\u00e1tica em programa\u00e7\u00e3o, aqui adotamos essa solu\u00e7\u00e3o para manter o c\u00f3digo em C mais direto, evitando o excesso de ponteiros e sem\u00e1foros. Como o foco do curso est\u00e1 na teoria de controle \u2014 e n\u00e3o em engenharia de software \u2014 essa escolha facilita a compreens\u00e3o sem comprometer o aprendizado.</li> </ol>"},{"location":"pages/control/architecture/architecture/#variaveis-globais","title":"Vari\u00e1veis globais","text":"<p>Logo no in\u00edcio do c\u00f3digo, declararemos as vari\u00e1veis que representam os atuadores, sensores, entradas, estados e refer\u00eancias \u2014 espelhando o diagrama.</p> <pre><code>// Actuators\nfloat pwm1, pwm2, pwm3, pwm4; // Motors PWM\n\n// Sensors\nfloat ax, ay, az;             // Accelerometer [m/s^2]\nfloat gx, gy, gz;             // Gyroscope [rad/s]\nfloat d;                      // Range [m]\nfloat px, py;                 // Optical flow [pixels]\n\n// System inputs\nfloat ft;                     // Thrust force [N]\nfloat tx, ty, tz;             // Roll, pitch and yaw torques [N.m]\n\n// System states\nfloat phi, theta, psi;        // Euler angles [rad]\nfloat wx, wy, wz;             // Angular velocities [rad/s]\nfloat x, y, z;                // Positions [m]\nfloat vx, vy, vz;             // Velocities [m/s]\n\n// System references\nfloat phi_r, theta_r, psi_r; // Euler angles reference [rad]\nfloat x_r, y_r, z_r;         // Positions reference [m]\n</code></pre>"},{"location":"pages/control/architecture/architecture/#loop-principal","title":"Loop principal","text":"<p>Toda a l\u00f3gica de controle ser\u00e1 implementada dentro de um loop que roda a 200 Hz (ou seja, a cada 5 ms). Dentro desse loop, chamamos as fun\u00e7\u00f5es na sequ\u00eancia do diagrama: refer\u00eancias \u2192 sensores \u2192 estimadores \u2192 controladores \u2192 atuadores.</p> <pre><code>// Main application task\nvoid appMain(void *param)\n{\n    // Infinite loop (runs at 200Hz)\n    while (true)\n    {\n        reference();                  // Read reference setpoints (from Crazyflie Client)\n        sensors();                    // Read raw sensor measurements\n        attitudeEstimator();          // Estimate orientation (roll/pitch/yaw) from IMU sensor\n        verticalEstimator();          // Estimate vertical position/velocity from range sensor\n        horizontalEstimator();        // Estimate horizontal positions/velocities from optical flow sensor\n        horizontalController();       // Compute desired roll/pitch angles\n        verticalController();         // Compute desired thrust force\n        attitudeController();         // Compute desired roll/pitch/yaw torques\n        mixer();                      // Convert desired force/torques into motor PWM\n        motors();                     // Send commands to motors\n        vTaskDelay(pdMS_TO_TICKS(5)); // Loop delay (5 ms)\n    }\n}\n</code></pre>"},{"location":"pages/control/architecture/architecture/#implementacao","title":"Implementa\u00e7\u00e3o","text":"<p>A implementa\u00e7\u00e3o ser\u00e1 feita passo a passo, uma fun\u00e7\u00e3o por vez. Dessa forma, voc\u00ea poder\u00e1 entender o papel de cada bloco isoladamente antes de ver o sistema completo em a\u00e7\u00e3o.</p> <p></p> <p>Nos pr\u00f3ximos cap\u00edtulos, come\u00e7aremos pelo mixer e, em seguida, avan\u00e7aremos para os blocos de estimadores e controladores. Cada subsistema ser\u00e1 estudado em pares \u2014 estimador e controlador de atitude, vertical (altura) e horizontal (posi\u00e7\u00e3o no plano). Ao final, voc\u00ea ter\u00e1 constru\u00eddo, passo a passo, a arquitetura de controle completa de um drone.</p>"},{"location":"pages/control/attitude/controller/attitude_controller/","title":"Controlador de atitude","text":"<p>Nesta sec\u00e7\u00e3o voc\u00ea ir\u00e1 implementar o controlador de atitude, que comanda os torques \\(\\tau_x\\), \\(\\tau_y\\) e \\(\\tau_z\\) a partir da diferen\u00e7a entre os \u00e2ngulos de Euler de refer\u00eancia \\(\\phi_r\\), \\(\\theta_r\\) e \\(\\psi_r\\) e estimados \\(\\phi\\), \\(\\theta\\) e \\(\\psi\\).</p> <p></p> <p>Para isto, ser\u00e1 implementada uma nova fun\u00e7\u00e3o:</p> <ul> <li><code>attitudeController()</code></li> </ul> <p>Al\u00e9m de uma altera\u00e7\u00e3o em uma fun\u00e7\u00e3o j\u00e1 previamente implementada:</p> <ul> <li><code>reference()</code></li> </ul>"},{"location":"pages/control/attitude/controller/attitude_controller/#implementacao","title":"Implementa\u00e7\u00e3o","text":"<p>Para come\u00e7ar, copie e cole o arquivo <code>attitude_estimator.c</code> e renomeie ele para <code>attitude_controller.c</code>.</p>"},{"location":"pages/control/attitude/controller/attitude_controller/#definicoes","title":"Defini\u00e7\u00f5es","text":""},{"location":"pages/control/attitude/controller/attitude_controller/#variaveis-globais","title":"Vari\u00e1veis globais","text":"<p>Declare mais algumas vari\u00e1veis globais, que s\u00e3o as refer\u00eancias dos \u00e2ngulos de Euler que entram na fun\u00e7\u00e3o do controlador de atitude.</p> <pre><code>// System references\nfloat phi_r, theta_r, psi_r; // Euler angles reference [rad]\n</code></pre>"},{"location":"pages/control/attitude/controller/attitude_controller/#loop-principal","title":"Loop principal","text":"<p>Inclua no seu loop principal a chamada da fun\u00e7\u00e3o <code>attitudeController()</code> entre as fun\u00e7\u00f5es <code>attitudeEstimator()</code> e <code>mixer()</code>.</p> <pre><code>// Main application task\nvoid appMain(void *param)\n{\n    // Infinite loop (runs at 200Hz)\n    while (true)\n    {\n        reference();                  // Read reference setpoints (from Crazyflie Client)\n        sensors();                    // Read raw sensor measurements\n        attitudeEstimator();          // Estimate orientation (roll/pitch/yaw) from IMU sensor\n        attitudeController();         // Compute desired roll/pitch/yaw torques\n        mixer();                      // Convert desired force/torques into motor PWM\n        actuators();                  // Send commands to motors\n        vTaskDelay(pdMS_TO_TICKS(5)); // Loop delay (5 ms)\n    }\n}\n</code></pre>"},{"location":"pages/control/attitude/controller/attitude_controller/#funcoes","title":"Fun\u00e7\u00f5es","text":""},{"location":"pages/control/attitude/controller/attitude_controller/#referencia","title":"Refer\u00eancia","text":"<p>Os \u00e2ngulos de Euler de refer\u00eancia \\(\\phi_r\\) e \\(\\theta_r\\) ser\u00e3o comandados pelo Command Based Flight Control do Crazyflie Client.</p> <p></p> <p>Conforme vimos anteriormente: </p> <ul> <li>Os bot\u00f5es Up e Down alteram a vari\u00e1vel <code>setpoint.position.z</code> em incrementos de \\(0,5\\)</li> <li>Os bot\u00f5es \u2190 e \u2192 alteram a vari\u00e1vel <code>setpoint.position.y</code> em incrementos de \\(0,5\\)</li> <li>Os bot\u00f5es \u2191 e \u2193 alteram a vari\u00e1vel <code>setpoint.position.x</code> em incrementos de \\(0,5\\)</li> </ul> <p>Vamos continuar utilizando os bot\u00f5es <code>Up</code> / <code>Down</code> para comandar a for\u00e7a total \\(f_t\\) em incrementos de \\(0,01\\,N\\), mas agora os bot\u00f5es <code>\u2191</code> / <code>\u2193</code> e <code>\u2190</code> / <code>\u2192</code> v\u00e3o comandar, respectivamente, os \u00e2ngulos de Euler de refer\u00eancia \\(\\theta_r\\) e \\(\\phi_r\\) em incrementos de \\(\\frac{\\pi}{4} \\text{rad}\\) (\\(45^{\\circ}\\)). Para tal, precisamos ajustar as escalas da seguinte forma:</p> <p></p> <p>Abaixo temos um exemplo de fun\u00e7\u00e3o <code>reference()</code> que faz isso:</p> <pre><code>// Get reference setpoints from commander module\nvoid reference()\n{\n    // Declare variables that store the most recent setpoint and state from commander\n    static setpoint_t setpoint;\n    static state_t state;\n\n    // Retrieve the current commanded setpoints and state from commander module\n    commanderGetSetpoint(&amp;setpoint, &amp;state);\n\n    // Extract position references from the received setpoint\n    ft =  (setpoint.position.z * 2.0f) / 100.0f;      // Thrust force command [N] (maps 0.5m -&gt; 0.01N)\n    phi_r = (setpoint.position.y * 2.0f) * pi/4.0f;   // Roll reference command [rad] (maps 0.5m -&gt; pi/4 rad)\n    theta_r = (setpoint.position.y * 2.0f) * pi/4.0f; // Pitch reference command [rad] (maps 0.5m -&gt; pi/4 rad)\n    psi_r = 0.0f;                                     // Yaw reference command [rad]\n}\n</code></pre>"},{"location":"pages/control/attitude/controller/attitude_controller/#controlador-de-atitude_1","title":"Controlador de atitude","text":"<p>A fun\u00e7\u00e3o <code>attitudeController()</code> \u00e9 quem comanda os torques a partir da diferen\u00e7a entre os \u00e2ngulos de Euler de refer\u00eancia e estimados.</p> <pre><code>// Compute desired torques\nvoid attitudeController()\n{ \n}\n</code></pre> <p>Para projetar um controlador, precisamos de um modelo da planta que ser\u00e1 controlada. J\u00e1 vimos que a din\u00e2mica linearizada de um quadric\u00f3ptero pode ser representada pelo diagrama de blocos abaixo:</p> <p></p> <p>Como a din\u00e2mica de atitude de cada \u00e2ngulo est\u00e1 desacoplada, \u00e9 poss\u00edvel controlar cada um deles individualmente. Toda a t\u00e9cnica de controle explorada aqui ser\u00e1 realizada para o \u00e2ngulo de inclina\u00e7\u00e3o \\(\\theta\\), e a mesma ser\u00e1 replicada depois para os \u00e2ngulos de rolagem \\(\\phi\\) e guinagem \\(\\psi\\).</p> <p>A din\u00e2mica de inclina\u00e7\u00e3o pode ser representada pelo diagrama de blocos abaixo:</p> <p></p> <p>Podemos cancelar o momento de in\u00e9rcia da planta de modo que a vari\u00e1vel de controle seja a acelera\u00e7\u00e3o angular, conforme abaixo:</p> <p></p> <p>Isso reduz o sistema a ser controlado a um integrador duplo. Vamos detalhar tr\u00eas poss\u00edveis controladores para um sistema como esse, ficando a seu crit\u00e9rio qual utilizar.</p> PDP-PLQR <p>O controlador proporcional derivativo (PD) combina a\u00e7\u00f5es proporcional e derivativa para reagir tanto ao erro quanto \u00e0 sua varia\u00e7\u00e3o, oferecendo boa resposta e bom amortecimento. \u00c9 simples de implementar e eficaz para o integrador duplo, mas sua sensibilidade ao ru\u00eddo na derivada pode limitar o desempenho.</p> <p></p> Defini\u00e7\u00e3o dos ganhos \\(k_p\\) e \\(k_d\\) <p>O diagrama de blocos acima pode ser representado por uma fun\u00e7\u00e3o de transfer\u00eancia do controlador \\(C(s)\\) e outra da planta \\(G(s)\\):</p> <p></p> a) Escreva as fun\u00e7\u00f5es de transfer\u00eancia do controlador \\(C(s)\\) e da planta $G(s) \\[ C(s) = I_{yy} \\left( k_p + k_d s \\right) \\qquad \\qquad G(s) = \\dfrac{1}{I_{yy}s^2} \\] b) Determine a fun\u00e7\u00e3o de transfer\u00eancia em malha fechada \\(T(s)\\) \\[ \\begin{align}     T(s) &amp;= \\dfrac{G(s)C(s)}{1+G(s)C(s)} \\\\     T(s) &amp;= \\dfrac{\\frac{1}{\\cancel{I_{yy}}s^2} \\cancel{I_{yy}} \\left( k_p + k_d s \\right)}{1+ \\frac{1}{\\cancel{I_{yy}}s^2} \\cancel{I_{yy}} \\left( k_p + k_d s \\right)} \\\\      T(s) &amp;= \\dfrac{\\frac{k_p + k_d s}{s^2}}{\\frac{s^2}{s^2}+\\frac{k_p + k_d s}{s^2}} \\\\       T(s) &amp;= \\dfrac{\\frac{k_p + k_d s}{\\cancel{s^2}}}{\\frac{s^2 + k_p + k_d s}{\\cancel{s^2}}} \\\\         T(s) &amp;= \\dfrac{k_d s + k_p}{s^2 + k_d s + k_p} \\end{align} \\] c) Escreva os ganhos \\(k_p\\) e \\(k_d\\) em fun\u00e7\u00e3o da frequ\u00eancia natural \\(\\omega_n\\) e do fator de amortecimento \\(\\zeta\\) do sistema em malha fechada \\[ T(s) = k \\frac{\\omega_n^2}{s^2 + 2 \\zeta \\omega_n s + \\omega_n^2} \\quad \\longrightarrow \\quad \\left\\{ \\begin{array}{l}         k_p = \\omega_n^2 \\\\         k_d = 2 \\zeta \\omega_n  \\end{array} \\right. \\] d) Calcule os ganhos \\(k_p\\) e \\(k_d\\) para que a din\u00e2mica de atitude do quadric\u00f3ptero tenha um tempo de acomoda\u00e7\u00e3o de \\(0,3s\\) e uma ultrapassagem percentual de \\(0,5\\%\\) \\[ \\begin{align}     \\zeta &amp;= \\dfrac{|\\ln(OS)|}{\\sqrt{\\ln^2(OS)+\\pi^2}} \\\\     \\zeta &amp;= \\dfrac{|\\ln(0,005)|}{\\sqrt{\\ln^2(0,005)+\\pi^2}} \\\\     \\zeta &amp;= 0,86 \\end{align}  \\] \\[ \\begin{align}     k_p &amp;= \\omega_n^2 \\\\     k_p &amp;= 15,50^2 \\\\     k_p &amp;= 240,28 \\end{align} \\] \\[ \\begin{align}     \\omega_n &amp;= \\dfrac{4}{\\zeta T_s} \\\\     \\omega_n &amp;= \\dfrac{4}{0,86 \\cdot 0,3} \\\\     \\omega_n &amp;= 15,50 \\text{rad/s} \\end{align}  \\] \\[ \\begin{align}     k_d &amp;= 2 \\zeta \\omega_n \\\\     k_d &amp;= 2 \\cdot 0,86 \\cdot 15,50 \\\\     k_d &amp;= 26,67 \\end{align} \\] <p>O controlador proporcional derivativo insere um zero no sistema, assim um dos polos da origem vai at\u00e9 o zero e o outro at\u00e9 menos infinito, conforme o diagrama de lugar das ra\u00edzes abaixo:</p> <p> </p> <p>Olhando o controlador isoladamente, temos o seguinte diagrama de blocos:</p> <p></p> <p>Que se traduz nas equa\u00e7\u00f5es abaixo:</p> \\[ \\left\\{ \\begin{array}{l}     \\theta_e = {\\color{var(--c3)}\\theta_r} -{\\color{var(--c1)}\\theta} \\\\     {\\color{var(--c2)}\\tau_y} = I_{yy} \\left( k_p \\theta_e + k_d \\dfrac{d \\theta_e}{dt} \\right) \\\\ \\end{array} \\right. \\] <p>Inclua na fun\u00e7\u00e3o <code>attitudeController()</code> duas vari\u00e1veis locais \\(k_p\\) e \\(k_d\\), que correspondem aos ganhos do controlador, e, em seguida, calcule o torque comandado \\({\\color{var(--c2)}\\tau_y}\\)(1).</p> <ol> <li>O termo derivativo \\(z_d = \\dfrac{d \\theta_e}{dt}\\) pode ser calculado com uma vari\u00e1vel auxiliar conforme exemplo abaixo.</li> </ol> <pre><code>// Compute desired torques\nvoid attitudeController()\n{\n    // Controller parameters (settling time of 0.3s and overshoot of 0,05%)\n    static const float kp = \n    static const float kd = \n\n    // Compute angle error\n    float theta_e = \n\n    // Calculate derivative term with auxiliary variable of previous error (static to retain value amoung function calls)\n    static float theta_e_prev;\n    theta_d = (theta_e-theta_e_prev)/dt;\n    theta_e_prev = theta_e;\n\n    // Compute desired torque\n    ty = \n}\n</code></pre> <p>O controlador proporcional em cascata (P-P) utiliza duas malhas hier\u00e1rquicas \u2014 uma interna e outra externa \u2014 o que melhora a estabilidade e o tempo de resposta. \u00c9 intuitivo e robusto, mas requer ajuste cuidadoso entre as duas malhas para evitar oscila\u00e7\u00f5es.</p> <p></p> Defini\u00e7\u00e3o dos ganhos \\(k_p\\) e \\(k_d\\) <p>O diagrama de blocos acima pode ser representado por duas fun\u00e7\u00f5es de transfer\u00eancia do controlador \\(C_1(s)\\) e \\(C_2(s)\\) e outras duas da planta \\(G_1(s)\\) e \\(G_2(s)\\):</p> <p></p> a) Escreva as fun\u00e7\u00f5es de transfer\u00eancia do controlador \\(C_1(s)\\) e \\(C_2(s)\\) e da planta \\(G_1(s)\\) e \\(G_2(s)\\) \\[                        C_1(s) = I_{yy} k_d \\qquad \\qquad C_2(s) = k_p \\qquad \\qquad G_1(s) = \\dfrac{1}{I_{yy}s} \\qquad \\qquad G_2(s) = \\dfrac{1}{s} \\] b) Determine a fun\u00e7\u00e3o de transfer\u00eancia em malha fechada \\(T_1(s)\\) \\[ \\begin{align}     T_1(s) &amp;= \\dfrac{G_1(s)C_1(s)}{1+G_1(s)C_1(s)} \\\\     T_1(s) &amp;= \\dfrac{\\frac{1}{\\cancel{I_{yy}}s} \\cancel{I_{yy}}k_d }{1+\\frac{1}{\\cancel{I_{yy}}s} \\cancel{I_{yy}}k_d} \\\\      T_1(s) &amp;= \\dfrac{\\frac{k_d}{s}}{\\frac{s}{s}+\\frac{k_d}{s}} \\\\      T_1(s) &amp;= \\dfrac{\\frac{k_d}{\\cancel{s}}}{\\frac{s + k_d}{\\cancel{s}}} \\\\      T_1(s) &amp;= \\dfrac{k_d}{s + k_d} \\end{align} \\] c) Determine a fun\u00e7\u00e3o de transfer\u00eancia em malha fechada \\(T_2(s)\\) \\[ \\begin{align}     T_2(s) &amp;= \\dfrac{G_2(s)T_1(s)C_2(s)}{1+G_2(s)T_1(s)C_2(s)} \\\\     T_2(s) &amp;= \\dfrac{\\frac{1}{s}\\frac{k_d}{s + k_d}k_p}{1+\\frac{1}{s}\\frac{k_d}{s + k_d}k_p} \\\\      T_2(s) &amp;= \\dfrac{\\frac{k_d k_p}{s^2 + k_ds}}{\\frac{s^2 + k_ds}{s^2 + k_ds}+\\frac{k_d k_p}{s^2 + k_ds}} \\\\      T_2(s) &amp;= \\dfrac{\\frac{k_d k_p}{\\cancel{s^2 + k_ds}}}{\\frac{s^2 + k_ds + k_d k_p}{\\cancel{s^2 + k_ds}}} \\\\      T_2(s) &amp;= \\dfrac{k_d k_p}{s^2 + k_d s + k_d k_p} \\end{align} \\] d) Escreva os ganhos \\(k_p\\) e \\(k_d\\) em fun\u00e7\u00e3o da frequ\u00eancia natural \\(\\omega_n\\) e do fator de amortecimento \\(\\zeta\\) do sistema em malha fechada \\[ T(s) = k \\frac{\\omega_n^2}{s^2 + 2 \\zeta \\omega_n s + \\omega_n^2} \\quad \\longrightarrow \\quad \\left\\{ \\begin{array}{l}         k_p = \\dfrac{\\omega_n}{2\\zeta} \\\\         k_d = 2 \\zeta \\omega_n  \\end{array} \\right. \\] e) Calcule os ganhos \\(k_p\\) e \\(k_d\\) para que a din\u00e2mica de atitude do quadric\u00f3ptero tenha um tempo de acomoda\u00e7\u00e3o de \\(0,3s\\) e uma ultrapassagem percentual de \\(0,5\\%\\) \\[ \\begin{align}     \\zeta &amp;= \\dfrac{|\\ln(OS)|}{\\sqrt{\\ln^2(OS)+\\pi^2}} \\\\     \\zeta &amp;= \\dfrac{|\\ln(0,005)|}{\\sqrt{\\ln^2(0,005)+\\pi^2}} \\\\     \\zeta &amp;= 0,86 \\end{align}  \\] \\[ \\begin{align}     k_p &amp;= \\frac{\\omega_n}{2\\zeta} \\\\     k_p &amp;= \\frac{15,50}{2\\cdot0,86} \\\\     k_p &amp;= 9,01 \\end{align} \\] \\[ \\begin{align}     \\omega_n &amp;= \\dfrac{4}{\\zeta T_s} \\\\     \\omega_n &amp;= \\dfrac{4}{0,86 \\cdot 0,3} \\\\     \\omega_n &amp;= 15,50 \\text{rad/s} \\end{align}  \\] \\[ \\begin{align}     k_d &amp;= 2 \\zeta \\omega_n \\\\     k_d &amp;= 2 \\cdot 0,86 \\cdot 15,50 \\\\     k_d &amp;= 26,67 \\end{align} \\] <p>O ganho \\(k_d\\) determina a localiza\u00e7\u00e3o do polo da malha de controle interna:</p> <p></p> <p>J\u00e1 o ganho \\(k_p\\) determina a localiza\u00e7\u00e3o dos polos da malha de controle externa:</p> <p></p> <p>Caso o ganho \\(k_d\\) seja suficientemente maior (\\(&gt;5\\times\\)) que o ganho \\(k_p\\) , o polo em \\(-k_d\\) \u00e9 desprez\u00edvel e a malha de controle externa se comporta como um sistema de 1\u00aa ordem cuja constante de tempo \u00e9 dada apenas pelo polo em \\(-k_p\\):</p> <p></p> <p>A ideia de um controlador em cascata \u00e9 projetar malhas de controle sucessivamente mais lentas de modo que as malhas internas possam ser aproximadas a um ganho unit\u00e1rio constante. No entanto, \u00e9 preciso tomar cuidado. Se o ganho da malha de controle interna for muito alto, isso pode gerar satura\u00e7\u00e3o dos atuadores.</p> f) Calcule os ganhos \\(k_p\\) e \\(k_d\\) para que o a din\u00e2mica de atitude do quadric\u00f3ptero tenha um tempo de acomoda\u00e7\u00e3o de \\(0,3s\\) e que o polo mais r\u00e1pido seja desprez\u00edvel \\[ \\begin{align}     \\tau &amp;= \\dfrac{T_s}{4} \\\\     \\tau &amp;= \\dfrac{0,3}{4} \\\\     \\tau &amp;= 0,075 \\end{align} \\] \\[ \\begin{align}     k_p &amp;= \\dfrac{1}{\\tau} \\\\     k_p &amp;= \\dfrac{1}{0,075} \\\\     k_p &amp;= 13,33 \\end{align} \\] \\[ \\begin{align}     k_d &amp;= 5 k_p \\\\     k_d &amp;= 5 \\cdot 13,33 \\\\     k_d &amp;= 66,65 \\end{align}  \\] <p>Olhando o controlador isoladamente, temos o seguinte diagrama de blocos:</p> <p></p> <p>Que se traduz na equa\u00e7\u00e3o abaixo(1):</p> <ol> <li>No sistema linearizado temos que \\({\\color{var(--c1)}\\dot{\\theta}} = {\\color{var(--c1)}\\omega_y}\\)</li> </ol> \\[ {\\color{var(--c2)}\\tau_y} = I_{yy} \\left( k_d \\left( k_p \\left( {\\color{var(--c3)}\\theta_r} - {\\color{var(--c1)}\\theta} \\right)  - {\\color{var(--c1)}\\omega_y} \\right)  \\right)  \\] <p>Inclua na fun\u00e7\u00e3o <code>attitudeController()</code> duas vari\u00e1veis locais \\(k_p\\) e \\(k_d\\), que correspondem aos ganhos do controlador, e, em seguida, calcule o torque comandado \\({\\color{var(--c2)}\\tau_y}\\).</p> <pre><code>// Compute desired torques\nvoid attitudeController()\n{\n    // Controller parameters (settling time of 0.3s and overshoot of 0,05%)\n    static const float kp = \n    static const float kd = \n\n    // Compute desired torque\n    ty = \n}\n</code></pre> <p>O regulador quadr\u00e1tico linear (LQR) realimenta todas as vari\u00e1veis do sistema e permite posicionar os polos em locais desejados do plano complexo, atendendo diretamente aos requisitos din\u00e2micos de desempenho. \u00c9 o mais simples e preciso dos tr\u00eas em termos de sintonia e resposta, mas exige dom\u00ednio do formalismo de espa\u00e7o de estados.</p> <p></p> Defini\u00e7\u00e3o dos ganhos \\(k_p\\) e \\(k_d\\) <p>A din\u00e2mica de atitude pode ser representada pelo seguinte sistema de equa\u00e7\u00f5es diferenciais:</p> \\[ \\left\\{ \\begin{array}{l}     \\begin{bmatrix}     \\dot{\\theta} \\\\     \\ddot{\\theta}     \\end{bmatrix}     =     \\begin{bmatrix}         0 &amp; 1 \\\\         0 &amp; 0      \\end{bmatrix}     \\begin{bmatrix}         \\theta \\\\         \\dot{\\theta}     \\end{bmatrix}     +     \\begin{bmatrix}         0 \\\\         \\frac{1}{I_{yy}}     \\end{bmatrix}     \\tau_{\\theta} \\\\ \\\\     \\theta =      \\begin{bmatrix}         1 &amp; 0     \\end{bmatrix}     \\begin{bmatrix}         \\theta \\\\         \\dot{\\theta}     \\end{bmatrix} \\end{array} \\right. \\] <p>Ou atrav\u00e9s da representa\u00e7\u00e3o no espa\u00e7o dos estados:</p> <p></p> <p>Onde: </p> \\[ u = \\tau_{\\theta} \\qquad x =  \\begin{bmatrix}     \\theta \\\\     \\dot{\\theta} \\end{bmatrix} \\qquad y = \\theta \\qquad A =  \\begin{bmatrix}     0 &amp; 1 \\\\     0 &amp; 0  \\end{bmatrix} \\qquad B =  \\begin{bmatrix}     0 \\\\     \\frac{1}{I_{yy}} \\end{bmatrix} \\qquad C =  \\begin{bmatrix}     1 &amp; 0  \\end{bmatrix} \\] <p>Um regulador de estados consiste em realimentar todos os estados do sistema simultaneamente ao inv\u00e9s de apenas a sa\u00edda(1), conforme o diagrama de blocos abaixo:</p> <ol> <li> <p>Para fazer uma analogia entre controle por realimenta\u00e7\u00e3o do estados (controle moderno) e controle por realimenta\u00e7\u00e3o da sa\u00edda (controle cl\u00e1ssico), vamos considerar um m\u00e9dico tratando um doente com febre alta:</p> <ul> <li>Se o m\u00e9dico tratar o doente segundo os conceitos de controle cl\u00e1ssico, ele vai medir a temperatura do paciente e vai dar um rem\u00e9dio para abaixar a febre quando ela estiver alta e n\u00e3o fazer nada quando a febre estiver baixa.</li> <li>Se o m\u00e9dico tratar o doente segundo os conceitos de controle moderno, ele vai examinar o paciente, identificar a causa da febre e dar um rem\u00e9dio para a doen\u00e7a e n\u00e3o para a febre (ou seja, o m\u00e9dico vai tratar a doen\u00e7a eliminando a causa da febre e n\u00e3o somente o sintoma da doen\u00e7a).</li> </ul> <p>O grande problema do controle por realimenta\u00e7\u00e3o dos estados \u00e9 exigir que os estados do sistema estejam dispon\u00edveis para serem realimentados, ou seja, \u00e9 necess\u00e1rio medir todos os estados do sistema ou pelo menos estim\u00e1-los.</p> </li> </ol> <p></p> <p>Onde:</p> \\[ x_r =  \\begin{bmatrix}     \\theta_r \\\\     \\dot{\\theta}_r \\end{bmatrix} \\qquad K = I_{yy} \\begin{bmatrix}     k_p &amp; k_d  \\end{bmatrix} \\] <p>Como estamos aplicando um realimenta\u00e7\u00e3o de estados do tipo:</p> \\[     u = K \\left( x_r - x \\right) \\] <p>A din\u00e2mica em malha fechada fica:</p> \\[ \\begin{align}     \\dot{x} &amp;= Ax + Bu \\\\     \\dot{x} &amp;= Ax + BK(x_r - x) \\\\     \\dot{x} &amp;= \\underbrace{(A-BK)}_{A_{mf}}x + \\underbrace{BK}_{B_{mf}}x_r \\end{align} \\] a) Determine a matriz de transmiss\u00e3o dos estados em malha fechada \\(A_{mf}\\) \\[ \\begin{align}     A_{mf} &amp;= A - BK \\\\     A_{mf} &amp;=      \\begin{bmatrix}         0 &amp; 1 \\\\         0 &amp; 0      \\end{bmatrix}     -      \\begin{bmatrix}         0 \\\\         \\frac{1}{\\cancel{I_{yy}}}     \\end{bmatrix}     \\cancel{I_{yy}}     \\begin{bmatrix}         k_p &amp; k_d     \\end{bmatrix} \\\\     A_{mf} &amp;=      \\begin{bmatrix}         0 &amp; 1 \\\\         0 &amp; 0      \\end{bmatrix}     -      \\begin{bmatrix}         0 &amp; 0 \\\\         k_p &amp; k_d      \\end{bmatrix} \\\\     A_{mf} &amp;=      \\begin{bmatrix}         0 &amp; 1 \\\\         -k_p &amp; -k_d      \\end{bmatrix} \\end{align}  \\] b) Determine o polin\u00f4mio caracter\u00edstica do sistema em malha fechada \\(p(s) = \\det \\left( sI - A_{mf} \\right)\\) \\[ \\begin{align}     p(s) &amp;= \\det \\left( sI - A_{mf} \\right) \\\\     p(s) &amp;=  \\det \\left( s     \\begin{bmatrix}         1 &amp; 0 \\\\         0 &amp; 1      \\end{bmatrix}     -      \\begin{bmatrix}         0 &amp; 1 \\\\         -k_p &amp; -k_d      \\end{bmatrix}     \\right) \\\\     p(s) &amp;=  \\det     \\begin{bmatrix}         s &amp; -1 \\\\         k_p &amp; s+k_d      \\end{bmatrix} \\\\     p(s) &amp;=  s \\left( s + K_k \\right) - k_p \\left( -1 \\right) \\\\     p(s) &amp;= s^2 + k_d s + k_p  \\end{align}  \\] c) Escreva os ganhos \\(k_p\\) e \\(k_d\\) em fun\u00e7\u00e3o da frequ\u00eancia natural \\(\\omega_n\\) e do fator de amortecimento \\(\\zeta\\) do sistema em malha fechada \\[ p(s) = s^2 + 2 \\zeta \\omega_n s + \\omega_n^2  \\quad \\longrightarrow \\quad \\left\\{ \\begin{array}{l}         k_p = \\omega_n^2 \\\\         k_d = 2 \\zeta \\omega_n  \\end{array} \\right. \\] d) Calcule os ganhos \\(k_p\\) e \\(k_d\\) para que a din\u00e2mica de atitude do quadric\u00f3ptero tenha um tempo de acomoda\u00e7\u00e3o de \\(0,3s\\) e uma ultrapassagem percentual de \\(0,5\\%\\) \\[ \\begin{align}     \\zeta &amp;= \\dfrac{|\\ln(OS)|}{\\sqrt{\\ln^2(OS)+\\pi^2}} \\\\     \\zeta &amp;= \\dfrac{|\\ln(0,005)|}{\\sqrt{\\ln^2(0,005)+\\pi^2}} \\\\     \\zeta &amp;= 0,86 \\end{align}  \\] \\[ \\begin{align}     k_p &amp;= \\omega_n^2 \\\\     k_p &amp;= 15,50^2 \\\\     k_p &amp;= 240,28 \\end{align} \\] \\[ \\begin{align}     \\omega_n &amp;= \\dfrac{4}{\\zeta T_s} \\\\     \\omega_n &amp;= \\dfrac{4}{0,86 \\cdot 0,3} \\\\     \\omega_n &amp;= 15,50 \\text{rad/s} \\end{align}  \\] \\[ \\begin{align}     k_d &amp;= 2 \\zeta \\omega_n \\\\     k_d &amp;= 2 \\cdot 0,86 \\cdot 15,50 \\\\     k_d &amp;= 26,67 \\end{align} \\] <p>Olhando o controlador isoladamente, temos o seguinte diagrama de blocos:</p> <p></p> <p>Que se traduz na equa\u00e7\u00e3o abaixo(1):</p> <ol> <li> <p>No sistema linearizado temos que \\({\\color{var(--c1)}\\dot{\\theta}} = {\\color{var(--c1)}\\omega_y}\\). Al\u00e9m disso, como o objetivo \u00e9 deixar o quadric\u00f3ptero estacion\u00e1rio, a velocidade angular de refer\u00eancia \\({\\color{var(--c3)}\\dot{\\theta}_r}\\) pode ser assumida como sendo zero, o que reduz o segundo termo:</p> \\[ k_d \\left( \\cancelto{0}{{\\color{var(--c3)}\\dot{\\theta}_r}} - {\\color{var(--c1)}\\dot{\\theta}} \\right) = - k_d  {\\color{var(--c1)}\\omega_y} \\] </li> </ol> \\[ {\\color{var(--c2)}\\tau_y} = I_{yy} \\left( k_p \\left( {\\color{var(--c3)}\\theta_r} - {\\color{var(--c1)}\\theta} \\right) - k_d  {\\color{var(--c1)}\\omega_y} \\right)  \\] <p>Inclua na fun\u00e7\u00e3o <code>attitudeController()</code> duas vari\u00e1veis locais \\(k_p\\) e \\(k_d\\), que correspondem aos ganhos do controlador, e, em seguida, calcule o torque comandado \\({\\color{var(--c2)}\\tau_y}\\).</p> <pre><code>// Compute desired torques\nvoid attitudeController()\n{\n    // Controller parameters (settling time of 0.3s and overshoot of 0,05%)\n    static const float kp = \n    static const float kd = \n\n    // Compute desired torque\n    ty = \n}\n</code></pre> <p>Note que, ao inv\u00e9s de realimentar os \u00e2ngulos e velocidades angulares reais, voc\u00ea est\u00e1 realimentando os \u00e2ngulos e velocidades angulares estimados. Ou seja, voc\u00ea est\u00e1 supondo que o estimador de atitude desenvolvido anteriormente \u00e9 perfeito. Isso \u00e9 chamado de \"observed-based control\" e \u00e9 um m\u00e9todo muito t\u00edpico para estruturar sistemas de controle.      </p>"},{"location":"pages/control/attitude/controller/attitude_controller/#validacao","title":"Valida\u00e7\u00e3o","text":"<p>Para validar o seu controlador voc\u00ea ir\u00e1 realizar dois experimentos. Em ambos os experimentos voc\u00ea deve colocar um pequeno valor de for\u00e7a de empuxo \\(f_t\\).</p>"},{"location":"pages/control/attitude/controller/attitude_controller/#controle-de-um-grau-de-liberdade","title":"Controle de um grau de liberdade","text":"<p>O primeiro experimento consiste em controlar o drone em apenas um grau de liberdade. Voc\u00ea ir\u00e1 utilizar um dispositivo criado especificamente para isso, que restringe todos os graus de liberdade do drone deixando apenas o \u00e2ngulo de inclina\u00e7\u00e3o \\(\\theta\\) livre.</p> <p></p> <p>Para testar o controlador voc\u00ea pode aplicar dist\u00farbios no quadric\u00f3ptero (dando um \"tapinha\" na parta inferior de seus motores) e verificar se o mesmo retorna ao \u00e2ngulo de refer\u00eancia \\(\\theta_r=0^{\\circ}\\). Voc\u00ea pode tamb\u00e9m alterar o \u00e2ngulo de refer\u00eancia para, por exemplo, \\(\\theta_r=45^{\\circ}\\), atrav\u00e9s do Crazyflie Client, e ver se o quadricoptero se inclina sozinho.</p>"},{"location":"pages/control/attitude/controller/attitude_controller/#controle-de-tres-graus-de-liberdade","title":"Controle de tr\u00eas graus de liberdade","text":"<p>O outro experimento consiste em controlar o drone em tr\u00eas graus de liberdade. No entanto, como os m\u00f3dulos dos controladores vertical e horizontal ainda n\u00e3o foram implementados, voc\u00ea ir\u00e1 realizar isso atrav\u00e9s de uma queda livre controlada. </p> <p>Altere a fun\u00e7\u00e3o <code>attitudeController()</code> de modo que ela comande n\u00e3o s\u00f3 o torque \\(\\tau_y\\) como tamb\u00e9m os torques \\(\\tau_x\\) e \\(\\tau_z\\)(1).</p> <ol> <li>Por conta da simetria do drone, voc\u00ea deve utilizar os mesmos ganhos \\(k_p\\) e \\(k_d\\) para o \u00e2ngulo de rolagem \\(\\phi\\) e inclina\u00e7\u00e3o \\(\\theta\\). No entanto, para o \u00e2ngulo de guinagem \\(\\psi\\), recomenda-se utilizar um ganho \\(k_p\\) 4x menor e um ganho \\(k_d\\) 2x menor, que corresponde \u00e0 mesma ultrapassagem percentual de \\(0,5\\%\\) mas a um tempo de acomoda\u00e7\u00e3o 2x maior (\\(0,3s \\rightarrow 0,6s\\)). </li> </ol> <pre><code>// Compute desired torques\nvoid attitudeController()\n{\n    // Controller parameters (settling time of 0.3s and overshoot of 0,05%)\n    static const float kp = \n    static const float kd = \n\n    // Compute desired torques\n    tx = \n    ty = \n    tz = \n}\n</code></pre> <p>Segure o quadric\u00f3ptero a uma dist\u00e2ncia de aproximadamente \\(50\\text{cm}\\) do ch\u00e3o e, assim que os motores come\u00e7arem a girar, solte ele. Ele dever\u00e1 cair devagar (comparado a uma queda livre) e sem rotacionar em torno de nenhum eixo.</p>"},{"location":"pages/control/attitude/estimator/attitude_estimator/","title":"Estimador de atitude","text":"<p>Nesta sec\u00e7\u00e3o voc\u00ea ir\u00e1 implementar o estimador de atitude, que estima os \u00e2ngulos de Euler \\(\\phi\\), \\(\\theta\\) e \\(\\psi\\) e velocidades angulares \\(\\omega_x\\), \\(\\omega_y\\) e \\(\\omega_z\\) a partir das leituras do aceler\u00f4metro \\(a_x\\), \\(a_y\\) e \\(a_z\\) e do girosc\u00f3pio \\(g_x\\), \\(g_y\\) e \\(g_z\\).</p> <p></p> <p>Para isto, ser\u00e3o implementadas duas novas fun\u00e7\u00f5es:</p> <ul> <li><code>sensors()</code></li> <li><code>attitudeEstimator()</code></li> </ul>"},{"location":"pages/control/attitude/estimator/attitude_estimator/#implementacao","title":"Implementa\u00e7\u00e3o","text":"<p>Para come\u00e7ar, copie e cole o arquivo <code>mixer.c</code> e renomeie ele para <code>attitude_estimator.c</code>.</p>"},{"location":"pages/control/attitude/estimator/attitude_estimator/#definicoes","title":"Defini\u00e7\u00f5es","text":""},{"location":"pages/control/attitude/estimator/attitude_estimator/#variaveis-globais","title":"Vari\u00e1veis globais","text":"<p>Declare mais algumas vari\u00e1veis globais, que s\u00e3o as vari\u00e1veis que entram e saem da fun\u00e7\u00e3o do estimador de atitude.</p> <pre><code>// Sensors\nfloat ax, ay, az;             // Accelerometer [m/s^2]\nfloat gx, gy, gz;             // Gyroscope [rad/s]\n\n// System states\nfloat phi, theta, psi;        // Euler angles [rad]\nfloat wx, wy, wz;             // Angular velocities [rad/s]\n</code></pre>"},{"location":"pages/control/attitude/estimator/attitude_estimator/#variaveis-de-registro","title":"Vari\u00e1veis de registro","text":"<p>Declare tamb\u00e9m algumas vari\u00e1veis que ser\u00e3o utilizados para registrar os valores dos \u00e2ngulos de Euler e enviar eles ao Crazyflie Client, para que seja poss\u00edvel visualizar nossa estimativa em tempo real(1).</p> <ol> <li>N\u00f3s n\u00e3o utilizamos as pr\u00f3prias vari\u00e1veis declaradas anteriormente pois o Crazyflie Client trabalha com \u00e2ngulos em graus e n\u00e3o em radianos.</li> </ol> <pre><code>// Auxiliary variables for logging Euler angles (CFClient uses degrees and not radians)\nfloat log_phi, log_theta, log_psi;\n\n// Logging group that stream variables to CFClient.\nLOG_GROUP_START(stateEstimate)\nLOG_ADD_CORE(LOG_FLOAT, roll, &amp;log_phi)\nLOG_ADD_CORE(LOG_FLOAT, pitch, &amp;log_theta)\nLOG_ADD_CORE(LOG_FLOAT, yaw, &amp;log_psi)\nLOG_GROUP_STOP(stateEstimate)\n</code></pre>"},{"location":"pages/control/attitude/estimator/attitude_estimator/#loop-principal","title":"Loop principal","text":"<p>Inclua no seu loop principal a chamada das fun\u00e7\u00f5es <code>sensors()</code> e <code>attitudeEstimator()</code>(1).</p> <ol> <li>Apesar dessas fun\u00e7\u00f5es serem detalhadas a seguir, no c\u00f3digo elas devem ser implementadas antes do loop principal.</li> </ol> <pre><code>// Main application task\nvoid appMain(void *param)\n{\n    // Infinite loop (runs at 200Hz)\n    while (true)\n    {\n        reference();                  // Read reference setpoints (from Crazyflie Client)\n        sensors();                    // Read raw sensor measurements\n        attitudeEstimator();          // Estimate orientation (roll/pitch/yaw) from IMU sensor\n        mixer();                      // Convert desired force/torques into motor PWM\n        actuators();                  // Send commands to motors\n        vTaskDelay(pdMS_TO_TICKS(5)); // Loop delay (5 ms)\n    }\n}\n</code></pre>"},{"location":"pages/control/attitude/estimator/attitude_estimator/#funcoes","title":"Fun\u00e7\u00f5es","text":""},{"location":"pages/control/attitude/estimator/attitude_estimator/#sensores","title":"Sensores","text":"<p>A fun\u00e7\u00e3o <code>sensors()</code> pega as leituras do aceler\u00f4metro e girosc\u00f3pio e armazena elas nas vari\u00e1veis globais previamente declaradas.</p> <pre><code>// Get sensor readings from estimator module\nvoid sensors()\n{\n    // Declare variable that store the most recent measurement from estimator\n    static measurement_t measurement;\n\n    // Retrieve the current measurement from estimator module\n    while (estimatorDequeue(&amp;measurement))\n    {\n        switch (measurement.type)\n        {\n        // Get accelerometer sensor readings and convert [G's -&gt; m/s^2]\n        case MeasurementTypeAcceleration:\n            ax = -measurement.data.acceleration.acc.x * g;\n            ay = -measurement.data.acceleration.acc.y * g;\n            az = -measurement.data.acceleration.acc.z * g;\n            break;\n        // Get gyroscope sensor readings and convert [deg/s -&gt; rad/s]\n        case MeasurementTypeGyroscope:\n            gx = measurement.data.gyroscope.gyro.x * pi / 180.0f;\n            gy = measurement.data.gyroscope.gyro.y * pi / 180.0f;\n            gz = measurement.data.gyroscope.gyro.z * pi / 180.0f;\n            break;\n        default:\n            break;\n        }\n    }\n}\n</code></pre> <p>Voc\u00ea pode simplesmente copiar e colar o c\u00f3digo acima. Se quiser entender ele melhor, volte na sec\u00e7\u00e3o dos sensores.</p>"},{"location":"pages/control/attitude/estimator/attitude_estimator/#estimador-de-atitude_1","title":"Estimador de atitude","text":"<p>A fun\u00e7\u00e3o <code>attitudeEstimator()</code> \u00e9 quem estima os \u00e2ngulos de Euler e velocidades angulares a partir das leituras do aceler\u00f4metro e do girosc\u00f3pio.</p> <pre><code>// Estimate orientation from IMU sensor\nvoid attitudeEstimator()\n{ \n}\n</code></pre> <p>Ela est\u00e1 em branco pois ser\u00e1 implementada em etapas a seguir. Inicialmente, voc\u00ea ir\u00e1 considerar apenas a din\u00e2mica 2D e estimar um \u00fanico \u00e2ngulo de Euler. S\u00f3 no final voc\u00ea ir\u00e1 considerar a din\u00e2mica 3D e estimar todos os \u00e2ngulos de Euler e velocidades angulares.</p> <p>A IMU (\"Inertial Measurement Unit\") do Crazyflie 2.1 Brushless \u00e9 a BMI088 da Bosch. Ela fica localizada na parte superior do drone, escondida embaixo da bateria.</p> <p></p> <p>Esse sensor utiliza tecnologia MEMS (``Micro-Electro-Mechanical Systems''), que permite medir acelera\u00e7\u00e3o linear e velocidade angular atrav\u00e9s do movimento de min\u00fasculos elementos mec\u00e2nicos integrados ao chip. Essas medi\u00e7\u00f5es s\u00e3o obtidas de forma totalmente eletr\u00f4nica e com alta taxa de amostragem, possibilitando estimar o movimento e a orienta\u00e7\u00e3o do drone em tempo real.</p> <p>Voc\u00ea come\u00e7ar\u00e1 implementando um estimador baseado apenas no aceler\u00f4metro, seguido de outro que utiliza apenas o girosc\u00f3pio. Ap\u00f3s compreender as vantagens e limita\u00e7\u00f5es de cada sensor isoladamente, ambos ser\u00e3o combinados de forma inteligente \u2014 resultando em um estimador mais robusto e preciso, que explorar\u00e1 o melhor dos dois mundos.</p>"},{"location":"pages/control/attitude/estimator/attitude_estimator/#acelerometro","title":"Aceler\u00f4metro","text":"<p>Aceler\u00f4metros inerciais s\u00e3o sensores que medem acelera\u00e7\u00e3o linear. Eles s\u00e3o compostos por um corpo de prova conectada a um inv\u00f3lucro atrav\u00e9s de uma mola e um amortecedor:</p> <p></p> <p>Quando o inv\u00f3lucro sofre uma acelera\u00e7\u00e3o \\({\\color{magenta}\\ddot{x}}\\), o corpo dentro do inv\u00f3lucro sofre um deslocamento \\({\\color{cyan}x'}\\). Medindo o deslocamento do corpo \\({\\color{cyan}x'}\\), \u00e9 poss\u00edvel inferir a acelera\u00e7\u00e3o sofrida pelo inv\u00f3lucro \\({\\color{magenta}\\ddot{x}}\\). </p> <p></p> <p>Ao montarmos tr\u00eas aceler\u00f4metros perpendiculares entre si, ou seja, um alinhado com cada eixo, temos o que \u00e9 chamado de aceler\u00f4metro de 3 eixos, que consegue medir a acelera\u00e7\u00e3o linear em todas as dire\u00e7\u00f5es.</p>"},{"location":"pages/control/attitude/estimator/attitude_estimator/#trigonometria","title":"Trigonometria","text":"<p>O aceler\u00f4metro est\u00e1 fixo no sistema de coordenadas m\u00f3vel do drone. Como h\u00e1 sempre a acelera\u00e7\u00e3o da gravidade apontando para baixo no sistema de coordenadas inercial, as acelera\u00e7\u00f5es \\(a_y\\) e \\(a_z\\) em fun\u00e7\u00e3o da gravidade \\(g\\) e do \u00e2ngulo \\(\\phi\\) s\u00e3o dadas por:</p> <p></p> \\[ \\begin{align}     \\begin{bmatrix}         a_y \\\\         a_z      \\end{bmatrix} &amp;= R \\vec{g} \\\\     \\begin{bmatrix}         a_y \\\\         a_z      \\end{bmatrix}     &amp;=     \\begin{bmatrix}          \\cos \\phi &amp; \\sin \\phi \\\\         -\\sin \\phi &amp; \\cos \\phi     \\end{bmatrix}     \\begin{bmatrix}         0 \\\\         -g     \\end{bmatrix} \\\\     \\begin{bmatrix}         a_y \\\\         a_z      \\end{bmatrix}     &amp;=     \\begin{bmatrix}         -g\\sin\\phi  \\\\         -g\\cos\\phi     \\end{bmatrix} \\end{align} \\] <p>Dividindo uma equa\u00e7\u00e3o pela outra, podemos medir o \u00e2ngulo \\(\\phi_a\\)(1) em fun\u00e7\u00e3o das leituras do aceler\u00f4metro \\(a_y\\) e \\(a_z\\)(2):</p> <ol> <li>Usamos o subescrito \\(_a\\) para deixar claro que esse \u00e2ngulo foi medido a partir das leituras do aceler\u00f4metro. </li> <li>Os sinais negativos n\u00e3o foram cortados pois voc\u00ea dever\u00e1 utilizar a fun\u00e7\u00e3o <code>atan2f</code> em seu c\u00f3digo, para saber em qual quadrante est\u00e1 o seu \u00e2ngulo. </li> </ol> \\[ \\begin{align}     \\frac{a_y}{a_z} &amp;= \\frac{-\\cancel{g}\\sin\\phi_a}{-\\cancel{g}\\cos\\phi_a} \\\\     \\frac{-a_y}{-a_z} &amp;= \\tan\\phi_a \\\\     \\phi_a &amp;= \\tan^{-1} \\left( \\dfrac{-a_y}{-a_z} \\right) \\end{align} \\] <p>Vamos come\u00e7ar implementando um estimador de atitude bem simples, cujo \u00e2ngulo estimado \\(\\phi\\) \u00e9 dado simplesmente pelo \u00e2ngulo \\(\\phi_a\\) medido a partir das leituras do aceler\u00f4metro \\(a_y\\) e \\(a_z\\), conforme o diagrama de blocos abaixo:</p> <p></p> <p>Inclua na fun\u00e7\u00e3o <code>attitudeEstimator()</code> uma vari\u00e1vel local \\(\\phi_a\\), que corresponde ao \u00e2ngulo medido a partir das leituras do aceler\u00f4metro \\(a_y\\) e \\(a_z\\) e, em seguida, atribua ela ao \u00e2ngulo estimado \\(\\phi\\). Tamb\u00e9m vamos armazenar o valor dessa estimativa numa vari\u00e1vel de registro, para que seja poss\u00edvel visualiz\u00e1-la no Crazyflie Client.</p> <pre><code>// Estimate orientation from IMU sensor\nvoid attitudeEstimator()\n{\n    // Measured angle from accelerometer\n    float phi_a = \n\n    // Estimated angle (accelerometer)\n    phi = \n\n    // Auxiliary variables for logging Euler angles (CFClient uses degrees and not radians)\n    log_phi = phi * 180.0f / pi;\n}\n</code></pre> <p>Verifique como est\u00e1 sua estimativa, para isso carregue esse programa no drone e utilize o Crazyflie Client para visualizar o resultado.</p> <p>Resultado esperado</p> <p>Voc\u00ea deve notar que o estimador implementado \u00e9 adequado somente para condi\u00e7\u00f5es est\u00e1ticas (baixas frequ\u00eancias). Isso se deve ao fato de que, ao movimentar o drone, surgem outras acelera\u00e7\u00f5es al\u00e9m da acelera\u00e7\u00e3o da gravidade. Essas acelera\u00e7\u00f5es acabam sendo um ru\u00eddo para o nosso estimador, e uma forma de remov\u00ea-las \u00e9 atrav\u00e9s de um filtro passa-baixas.</p>"},{"location":"pages/control/attitude/estimator/attitude_estimator/#filtro-passa-baixas","title":"Filtro passa-baixas","text":"<p>Um filtro passa-baixas \u00e9 um filtro que atenua sinais superiores a uma determinada frequ\u00eancia de corte \\(\\omega_c\\). Ele \u00e9 muito utilizado para filtrar ru\u00eddos, dado que os mesmos geralmente possuem uma frequ\u00eancia superior ao sinal que est\u00e1 sendo medido. </p> <p>Dessa forma, para obtermos um \u00e2ngulo estimado \\(\\phi\\) sem ru\u00eddos, vamos passar o \u00e2ngulo medido pelo aceler\u00f4metro \\(\\phi_a\\) por um filtro passa-baixas. No dom\u00ednino da frequ\u00eancia, isso pode ser representado pelo seguinte diagrama de blocos:</p> <p></p> <p>Dado que vamos implementar este filtro em um microcontrolador, torna-se necess\u00e1rio determinar o equivalente discreto do mesmo. Primeiro, vamos obter a equa\u00e7\u00e3o diferencial correspondente, utilizando a transformada inversa de Laplace:</p> \\[ \\begin{align*}     \\frac{\\phi(s)}{\\phi_a(s)} &amp;= \\frac{\\omega_c}{s+\\omega_c} \\\\     \\left( s + \\omega_c \\right) \\phi(s) &amp;= \\omega_c\\phi_a(s) \\\\     s\\phi(s) + \\omega_c\\phi(s) &amp;= \\omega_c\\phi_a(s) \\\\     &amp;\\Downarrow ^\\text{Transformada inversa}_\\text{de Laplace} \\\\     \\frac{d}{dt}{\\phi}(t) + \\omega_c\\phi(t) &amp;= \\omega_c\\phi_a(t) \\end{align*} \\] <p>Em seguida, vamos discretizar a equa\u00e7\u00e3o diferencial, utilizando o m\u00e9todo de Euler impl\u00edcito(1):</p> <ol> <li>O m\u00e9todo de Euler expl\u00edcito (\"pra frente\") utiliza a aproxima\u00e7\u00e3o \\(\\frac{d}{dt}x(t) \\approx \\frac{x(t+\\Delta t)-x(t)}{\\Delta t}\\), equanto que o m\u00e9todo de Euler impl\u00edcito (\"pra tr\u00e1s\") utiliza a aproxima\u00e7\u00e3o \\(\\frac{d}{dt}x(t) \\approx \\frac{x(t)-x(t-\\Delta t)}{\\Delta t}\\)</li> </ol> \\[ \\begin{align*}     \\frac{d}{dt}{\\phi}(t) + \\omega_c\\phi(t) &amp;= \\omega_c\\phi_a(t) \\\\     &amp;\\Downarrow ^\\text{Euler}_\\text{impl\u00edcito} \\\\     \\frac{\\phi[k]-\\phi[k-1]}{\\Delta t} + \\omega_c\\phi[k] &amp;= \\omega_c\\phi_a[k] \\\\     \\phi[k]-\\phi[k-1] + \\omega_c\\Delta t\\phi[k] &amp;= \\omega_c\\Delta t\\phi_a[k] \\\\     \\left( 1+\\omega_c\\Delta t\\right) \\phi[k] &amp;= \\phi[k-1] + \\omega_c\\Delta t\\phi_a[k] \\\\     \\phi[k] &amp;= \\underbrace{\\frac{1}{1+\\omega_c\\Delta t}}_{\\left(1-\\alpha\\right)} \\phi[k-1] + \\underbrace{\\frac{\\omega_c\\Delta t}{1+\\omega_c\\Delta t}}_{\\alpha} \\phi_a[k] \\\\     \\phi[k] &amp;= \\left( 1-\\alpha \\right)\\phi[k-1]+\\alpha\\phi_a[k] \\end{align*} \\] <p>Note que um filtro passa-baixas discretizado nada mais \u00e9 do que uma m\u00e9dia ponderada entre o valor antigo de \\(\\phi\\) e o valor medido \\(\\phi_a\\), e a vari\u00e1vel \\(\\alpha\\) \u00e9 exatamente esse fator de pondera\u00e7\u00e3o. O mesmo pode ser representado pelo seguinte diagrama de blocos:</p> <p></p> <p>A vari\u00e1vel \\(\\alpha\\) \u00e9 chamada de fator de suaviza\u00e7\u00e3o, ela depende da frequ\u00eancia de corte \\(\\omega_c\\) e do intervalo de tempo \\(\\Delta t\\) entre medi\u00e7\u00f5es:</p> \\[ \\alpha = \\frac{\\omega_c\\Delta t}{1+\\omega_c\\Delta t} \\] <ul> <li>Quanto maior for a frequ\u00eancia de corte \\(\\omega_c\\), mais pr\u00f3ximo de 1 estar\u00e1 o fator de suaviza\u00e7\u00e3o \\(\\alpha\\) e, consequentemente, mais peso ser\u00e1 dado aos valores medidos. Isso \u00e9 vantajoso pois garante que o sinal estimado convirja mais r\u00e1pido, no entanto, tamb\u00e9m deixa passar mais ru\u00eddo.</li> <li>Quanto menor for a frequ\u00eancia de corte \\(\\omega_c\\), mais pr\u00f3ximo de 0 estar\u00e1 o fator de suaviza\u00e7\u00e3o \\(\\alpha\\) e, consequentemente, mais peso ser\u00e1 dado aos valores antigos. Isso \u00e9 vantajoso pois deixa passar menos ru\u00eddo, no entanto, faz com que o sinal estimado convirja mais devagar.</li> </ul> <p>Determinar a frequ\u00eancia de corte \\(\\omega_c\\) ideal, que garante um bom compromisso entre redu\u00e7\u00e3o de ru\u00eddo e atraso, \u00e9 o maior desafio na implementa\u00e7\u00e3o de um filtro passa-baixas.</p> <p>Modifique a sua fun\u00e7\u00e3o <code>attitudeEstimator()</code> de modo que agora o \u00e2ngulo estimado \\(\\phi\\) seja dado por um filtro passa-baixas da medida do aceler\u00f4metro \\(\\phi_a\\).</p> <pre><code>// Estimate orientation from IMU sensor\nvoid attitudeEstimator()\n{\n    // Estimator parameters\n    static const float wc = \n    static const float alpha = \n\n    // Measured angle from accelerometer\n    float phi_a = \n\n    // Estimated angle (accelerometer with low pass filter)\n    phi = \n\n    // Auxiliary variables for logging Euler angles (CFClient uses degrees and not radians)\n    log_phi = phi * 180.0f / pi;\n}\n</code></pre> <p>Experimente valores de 1rad/s, 10rad/s e 100rad/s para a frequ\u00eancia de corte \\(\\omega_c\\) e verifique como isso influencia na sua estimativa. Para isso, carregue esse programa no drone e utilize o Crazyflie Client para visualizar o resultado.</p> <p>Resultado esperado</p> <p>Voc\u00ea deve notar que, mesmo no melhor dos casos, o estimador implementado n\u00e3o \u00e9 adequado para condi\u00e7\u00f5es din\u00e2micas (altas frequ\u00eancias). Vamos agora esquecer o aceler\u00f4metro por um instante e utilizar apenas o girosc\u00f3pio para estima\u00e7\u00e3o de atitude.</p>"},{"location":"pages/control/attitude/estimator/attitude_estimator/#giroscopio","title":"Girosc\u00f3pio","text":"<p>Girosc\u00f3pios inericiais s\u00e3o sensores que medem velocidade angular. Eles s\u00e3o compostos por um corpo de prova conectada a um inv\u00f3lucro atrav\u00e9s de duas molas e dois amortecedores:</p> <p></p> <p>No eixo \\({\\color{cyan}x'}\\) \u00e9 for\u00e7ada uma vibra\u00e7\u00e3o \\({\\color{#65DD18}f}=f_0\\sin(\\omega_0t)\\). Quando o inv\u00f3lucro possui uma velocidade angular \\({\\color{magenta}\\dot{\\theta}}\\), devido \u00e0 acelera\u00e7\u00e3o de Coriolis, \u00e9 induzida uma vibra\u00e7\u00e3o no eixo \\({\\color{cyan}y'}\\). Medindo a amplitude da vibra\u00e7\u00e3o em \\({\\color{cyan}y'}\\) \u00e9 poss\u00edvel inferir a velocidade angular do inv\u00f3lucro \\({\\color{magenta}\\dot{\\theta}}\\).</p> <p></p> <p>Ao montarmos tr\u00eas girosc\u00f3pios perpendiculares entre si, ou seja, um alinhado com cada eixo, temos o que \u00e9 chamado de girosc\u00f3pio de 3 eixos, que consegue medir a velocidade angular em todas as dire\u00e7\u00f5es.</p>"},{"location":"pages/control/attitude/estimator/attitude_estimator/#integracao","title":"Integra\u00e7\u00e3o","text":"<p>O girosc\u00f3pio est\u00e1 fixo no sistema de coordenadas m\u00f3vel drone e mede a velocidade angular, portanto o deslocamento angular pode ser obtido simplesmente integrando sua leitura(1):</p> <ol> <li>Usamos o subescrito \\(_g\\) para deixar claro que esse \u00e2ngulo foi medido a partir das leituras do girosc\u00f3pio. </li> </ol> <p></p> \\[ \\phi_g(t) = \\int g_x(t) dt \\\\ \\] <p>No dom\u00ednio da frequ\u00eancia, isso pode ser representado pelo seguinte diagrama de blocos:</p> <p></p> <p>Novamente, para determinar o correspondente discreto, primeiro obtemos a equa\u00e7\u00e3o diferencial correspondente:</p> \\[     \\begin{align*}     \\frac{\\phi_g(s)}{g_x(s)} &amp;= \\frac{1}{s} \\\\     s \\phi_g(s) &amp;= g_x(s) \\\\     &amp;\\Downarrow ^\\text{Transformada inversa}_\\text{de Laplace} \\\\     \\frac{d}{dt} \\phi_g(t) &amp;= g_x(t) \\end{align*} \\] <p>E em seguida discretizamos a equa\u00e7\u00e3o diferencial:</p> \\[ \\begin{align*}     \\frac{d}{dt} \\phi_g(t) &amp;= g_x(t) \\\\     &amp;\\Downarrow ^\\text{Euler}_\\text{impl\u00edcito} \\\\     \\frac{\\phi_g[k]-\\phi_g[k-1]}{\\Delta t} &amp;= g_x[k] \\\\     \\phi_g[k]-\\phi_g[k-1] &amp;= g_x[k] \\Delta t \\\\      \\phi_g[k] &amp;= \\phi_g[k-1] + g_x[k] \\Delta t  \\end{align*} \\] <p>Vamos implementar agora um estimador de atitude cujo \u00e2ngulo estimado \\(\\phi\\) \u00e9 dado pelo \u00e2ngulo medido a partir das leituras do girosc\u00f3pio \\(\\phi_g\\), que por sua vez \u00e9 dado pela integra\u00e7\u00e3o da leitura do girosc\u00f3pio \\(g_x\\), conforme o diagrama de blocos abaixo:</p> <p></p> <p>Inclua na fun\u00e7\u00e3o <code>attitudeEstimator()</code> uma vari\u00e1vel local \\(\\phi_g\\), que corresponde ao \u00e2ngulo medido a partir da integra\u00e7\u00e3o da leitura do girosc\u00f3pio \\(g_x\\) e, em seguida, atribua ela ao \u00e2ngulo estimado \\(\\phi\\).</p> <pre><code>// Estimate orientation from IMU sensor\nvoid attitudeEstimator()\n{\n    // Measured angle from gyroscope\n    float phi_g =\n\n    // Estimated angle (gyroscope)\n    phi =\n\n    // Auxiliary variables for logging Euler angles (CFClient uses degrees and not radians)\n    log_phi = phi * 180.0f / pi;\n}\n</code></pre> <p>Verifique como est\u00e1 sua estimativa, para isso carregue esse programa no drone e utilize o Crazyflie Client para visualizar o resultado.</p> <p>Resultado esperado</p> <p>Voc\u00ea deve notar que o estimador implementado \u00e9 adequado somente para condi\u00e7\u00f5es din\u00e2micas (altas frequ\u00eancias). Isso se deve ao fato de que, em condi\u00e7\u00f5es est\u00e1ticas (baixas frequ\u00eancias), o girosc\u00f3pio possui erros sistem\u00e1ticos constantes (\"bias\"), que, mesmo pequenos, acabam sendo integrados e fazendo com que a atitude divirja ao longo do tempo. \u00c9 o problema inverso do aceler\u00f4metro, e uma forma de remov\u00ea-lo \u00e9 atrav\u00e9s de um filtro passa-altas.</p>"},{"location":"pages/control/attitude/estimator/attitude_estimator/#filtro-passa-altas","title":"Filtro passa-altas","text":"<p>Um filtro passa-altas \u00e9 um filtro que atenua sinais inferiores a uma determinada frequ\u00eancia de corte \\(\\omega_c\\). Ou seja, ele faz o inverso de um filtro passa-baixas.</p> <p>Para se obter o \u00e2ngulo estimado \\(\\phi\\), basta passar o \u00e2ngulo medido \\(\\phi_g\\) por um filtro passa-altas. No dom\u00ednio da frequ\u00eancia, isso pode ser representado pelo seguinte diagrama de blocos:</p> <p></p> <p>Note que, como a velocidade angular est\u00e1 sendo integrada antes de passar pelo filtro, o diagrama de blocos pode ser reduzido:</p> <p></p> <p>Novamente, primeiro obtemos a equa\u00e7\u00e3o diferencial:</p> \\[ \\begin{align}     \\frac{\\phi(s)}{g_x(s)} &amp;= \\frac{1}{s+\\omega_c} \\\\     s\\phi(s) + \\omega_c\\phi(s) &amp;= g_x(s) \\\\     &amp;\\Downarrow ^\\text{Transformada inversa}_\\text{de Laplace} \\\\     \\frac{d}{dt}{\\phi}(t) + \\omega_c\\phi(t) &amp;= g_x(t) \\end{align} \\] <p>E, em seguida, realizamos a discretiza\u00e7\u00e3o:</p> \\[ \\begin{align}     \\frac{d}{dt}{\\phi}(t) + \\omega_c\\phi(t) &amp;= g_x(t) \\\\     &amp;\\Downarrow ^\\text{Euler}_\\text{impl\u00edcito} \\\\     \\frac{\\phi[k]-\\phi[k-1]}{\\Delta t} + \\omega_c\\phi[k] &amp;= g_x[k] \\\\     \\phi[k]-\\phi[k-1] - \\omega_c\\Delta t\\phi[k] &amp;= g_x[k]\\Delta t \\\\     \\left( 1+\\omega_c\\Delta t \\right) \\phi[k] &amp;= \\phi[k-1] + g_x[k]\\Delta t \\\\     \\phi[k] &amp;= \\underbrace{\\frac{1}{1+\\omega_c\\Delta t}}_{\\left(1-\\alpha\\right)} \\underbrace{\\left(\\phi[k-1] + g_x[k]\\Delta t\\right)}_{\\phi_g[k]} \\\\     \\phi[k] &amp;= \\left(1-\\alpha\\right) \\phi_g[k] \\end{align} \\] <p>Dessa forma, a integra\u00e7\u00e3o do girosc\u00f3pio com um filtro passa-altas pode ser representado pelo diagrama de blocos abaixo:</p> <p></p> <p>Modifique a sua fun\u00e7\u00e3o <code>attitudeEstimator()</code> de modo que agora o \u00e2ngulo estimado \\(\\phi\\) seja dado por um filtro passa-altas da medida do girosc\u00f3pio \\(\\phi_g\\).</p> <pre><code>// Estimate orientation from IMU sensor\nvoid attitudeEstimator()\n{\n    // Estimator parameters\n    static const float wc = \n    static const float alpha = \n\n    // Measured angle from gyroscope\n    float phi_g = \n\n    // Estimated angle (gyroscope with high pass filter)\n    phi = \n\n    // Auxiliary variables for logging Euler angles (CFClient uses degrees and not radians)\n    log_phi = phi * 180.0f / pi;\n}\n</code></pre> <p>Experimente valores de 0,1rad/s, 1rad/s e 10rad/s para a frequ\u00eancia de corte \\(\\omega_c\\) e verifique como isso influencia na sua estimativa. Para isso, carregue esse programa no drone e utilize o Crazyflie Client para visualizar o resultado.</p> <p>Resultado esperado</p> <p>Voc\u00ea deve notar que a atitude do drone sempre converge para zero, o que \u00e9 bom pois n\u00e3o estamos mais integrando os erros sistem\u00e1ticos, mas ruim quando o drone fica parado em uma atitude que n\u00e3o seja zero.</p>"},{"location":"pages/control/attitude/estimator/attitude_estimator/#acelerometro-giroscopio","title":"Aceler\u00f4metro + Girosc\u00f3pio","text":"<p>Conforme vimos, o aceler\u00f4metro nos fornece boas estimativas para condi\u00e7\u00f5es est\u00e1ticas (baixas frequ\u00eancias), enquanto o girosc\u00f3pio nos fornece boas estimativas para condi\u00e7\u00f5es din\u00e2micas (altas frequ\u00eancias). Um tem sucesso exatamente onde o outro falha. Por que ent\u00e3o n\u00e3o combinar os dois para ter boas estimativas durante condi\u00e7\u00f5es est\u00e1ticas e din\u00e2micas? Essa \u00e9 a ideia por tr\u00e1s de um filtro complementar!</p>"},{"location":"pages/control/attitude/estimator/attitude_estimator/#filtro-complementar","title":"Filtro complementar","text":"<p>A ideia desse filtro \u00e9 passar o \u00e2ngulo medido pelo aceler\u00f4metro por um filtro passa-baixas e o \u00e2ngulo medido pelo girosc\u00f3pio por um filtro passa-altas, conforme a o diagrama de blocos abaixo:</p> <p></p> <p>Como a somat\u00f3ria desses dois filtros gera um ganho unit\u00e1rio, eles podem simplesmente ser somados(1):</p> <ol> <li>\u00c9 da\u00ed que vem o nome \"complementar\"</li> </ol> \\[     \\underbrace{\\frac{\\omega_c}{s+\\omega_c}}_{\\begin{array}{c} \\text{ Filtro} \\\\ \\text{passa-baixas} \\end{array}} + \\underbrace{\\frac{s}{s+\\omega_c}}_{\\begin{array}{c} \\text{Filtro} \\\\ \\text{passa-altas} \\end{array}} = 1 \\] <p>Dado que a velocidade angular est\u00e1 sendo integrada antes de passar pelo filtro passa-altas e, tanto o filtro passa-baixas como o filtro passa-altas possuem o mesmo denominador da fun\u00e7\u00e3o de transfer\u00eancia, o diagrama de blocos pode ser reduzido:</p> <p></p> <p>Note que agora n\u00f3s s\u00f3 temos uma \u00fanica fun\u00e7\u00e3o de transfer\u00eancia, que \u00e9 a fun\u00e7\u00e3o de transfer\u00eancia de um filtro passa-baixas. Como j\u00e1 deduzimos o correspondente discreto deste filtro, tem-se que:</p> \\[ \\begin{align}     \\phi[k] &amp;= \\left( 1-\\alpha \\right)\\phi[k-1]+\\alpha \\left( \\frac{1}{\\omega_c} g_x[k] + \\phi_a[k] \\right) \\\\     \\phi[k] &amp;= \\left( 1-\\alpha \\right)\\phi[k-1]+ \\underbrace{\\alpha\\frac{1}{\\omega_c}}_{(1-\\alpha)\\Delta t} g_x[k] + \\alpha \\phi_a[k]  \\\\     \\phi[k] &amp;= \\left( 1-\\alpha \\right)\\phi[k-1]+ (1-\\alpha) g_x[k]\\Delta t + \\alpha \\phi_a[k]  \\\\     \\phi[k] &amp;= \\left( 1-\\alpha \\right)\\underbrace{\\left(\\phi[k-1]+g_x[k] \\Delta t \\right)}_{\\phi_g[k]} + \\alpha \\phi_a[k] \\\\     \\phi[k] &amp;= \\left( 1-\\alpha \\right)\\phi_g[k] + \\alpha \\phi_a[k]  \\end{align} \\] <p>Ou seja, um filtro complementar discretizado nada mais \u00e9 do que uma m\u00e9dia ponderada entre o \u00e2ngulo medido pelo girosc\u00f3pio \\(\\phi_g\\) e o \u00e2ngulo medido pelo aceler\u00f4metro \\(\\phi_a\\). Isso pode ser representando pelo seguinte diagrama de blocos:</p> <p></p> <p>Modifique a sua fun\u00e7\u00e3o <code>attitudeEstimator()</code> de modo que agora o \u00e2ngulo estimado \\(\\phi\\) seja dado por um filtro complementar das medidas do aceler\u00f4metro \\(\\phi_a\\) e girosc\u00f3pio \\(\\phi_g\\).</p> <pre><code>// Estimate orientation from IMU sensor\nvoid attitudeEstimator()\n{\n    // Estimator parameters\n    static const float wc = \n    static const float alpha = \n\n    // Measured angle from accelerometer\n    float phi_a = \n\n    // Measured angle from gyroscope\n    float phi_g = \n\n    // Estimated angle (accelerometer and gyroscope with complementary filter)\n    phi = \n\n    // Auxiliary variables for logging Euler angles (CFClient uses degrees and not radians)\n    log_phi = phi * 180.0f / pi;\n}\n</code></pre> <p>Experimente valores de 0,1rad/s, 1rad/s e 10rad/s para a frequ\u00eancia de corte \\(\\omega_c\\) e verifique como isso influencia na sua estimativa. Para isso, carregue esse programa no drone e utilize o Crazyflie Client para visualizar o resultado.</p> <p>Resultado esperado</p> <p>Agora sim a estimativa ficou legal!</p>"},{"location":"pages/control/attitude/estimator/attitude_estimator/#dinamica-completa","title":"Din\u00e2mica completa","text":"<p>Por fim, voc\u00ea deve replicar o estimador de atitude desenvolvido para os demais \u00e2ngulos de Euler e tamb\u00e9m velocidades angulares:</p> \\[ \\left\\{ \\begin{array}{l}     \\phi =  \\left( 1 - \\alpha \\right) \\phi_g + \\alpha \\phi_a \\\\      \\theta = \\left( 1 - \\alpha \\right) \\theta_g + \\alpha \\theta_a  \\\\     \\psi = \\psi_g  \\end{array} \\right. \\qquad \\qquad \\qquad \\left\\{ \\begin{array}{l}     \\omega_x = g_x \\\\      \\omega_y = g_y \\\\     \\omega_z = g_z  \\end{array} \\right. \\] <p>Note que n\u00e3o conseguimos estimar o \u00e2ngulo de guinagem \\(\\psi\\) a partir das leituras do aceler\u00f4metro, portanto, neste caso, utilizaremos apenas o girosc\u00f3pio. Ou seja, \u00e9 esperado que o \u00e2ngulo de guinagem \\(\\psi\\) divirja com o tempo, mas esse \u00e2ngulo n\u00e3o \u00e9 essencial para garantir a estabilidade do drone(1).</p> <ol> <li>Sistemas de refer\u00eancia de atitude e dire\u00e7\u00e3o (AHRS) utilizam um magnet\u00f4metro para complementar a estimativa de guinagem \\(\\psi\\) do girosc\u00f3pio, dessa forma evitando que esse \u00e2ngulo tamb\u00e9m divirja.</li> </ol> <p>Os \u00e2ngulos de Euler \\(\\phi_a\\) e \\(\\theta_a\\) medidos a partir das leituras do aceler\u00f4metro \\(a_x\\), \\(a_y\\) e \\(a_z\\) s\u00e3o dados por:</p> <p></p> \\[ \\left\\{ \\begin{array}{l}     \\phi_a = \\tan^{-1} \\left( \\dfrac{-a_y}{-a_z} \\right) \\\\     \\theta_a = \\tan^{-1} \\left( \\dfrac{a_x}{\\sqrt{a_y^2+a_z^2}} \\right) \\end{array} \\right. \\] Dedu\u00e7\u00e3o <p>As acelera\u00e7\u00f5es \\(a_x\\), \\(a_y\\) e \\(a_z\\) em fun\u00e7\u00e3o da gravidade \\(g\\) e dos \u00e2ngulo \\(\\phi\\) e \\(\\theta\\) s\u00e3o dadas por:</p> \\[ \\begin{align}     \\begin{bmatrix}         a_x \\\\         a_y \\\\         a_z \\\\     \\end{bmatrix} &amp;= R \\vec{g} \\\\     \\begin{bmatrix}         a_x \\\\         a_y \\\\         a_z \\\\     \\end{bmatrix}     &amp;=     \\begin{bmatrix}          \\cos\\theta\\cos\\psi &amp; \\cos\\theta\\sin\\psi &amp; -\\sin\\theta \\\\          - \\cos\\phi\\sin\\psi + \\sin\\phi\\sin\\theta\\cos\\psi  &amp; \\cos\\phi\\cos\\psi + \\sin\\phi\\sin\\theta\\sin\\psi &amp; \\sin\\phi\\cos\\theta \\\\          \\sin\\phi\\sin\\psi + \\cos\\phi\\sin\\theta\\cos\\psi &amp; - \\sin\\phi\\cos\\psi + \\cos\\phi\\sin\\theta\\sin\\psi  &amp; \\cos\\phi\\cos\\theta      \\end{bmatrix}     \\begin{bmatrix}         0 \\\\         0 \\\\         -g \\\\     \\end{bmatrix} \\\\     \\begin{bmatrix}         a_x \\\\         a_y \\\\         a_z \\\\     \\end{bmatrix}     &amp;=     \\begin{bmatrix}         g\\sin\\theta \\\\         -g\\sin\\phi\\cos\\theta \\\\         -g\\cos\\phi\\cos\\theta     \\end{bmatrix} \\end{align} \\] <p>Dividindo a segunda equa\u00e7\u00e3o pela terceira, podemos medir o \u00e2ngulo \\(\\phi_a\\) em fun\u00e7\u00e3o das leituras do aceler\u00f4metro \\(a_y\\) e \\(a_z\\):</p> \\[ \\begin{align}     \\frac{a_y}{a_z} &amp;= \\frac{-\\cancel{g}\\sin\\phi_a\\cancel{\\cos\\theta}}{-\\cancel{g}\\cos\\phi_a\\cancel{\\cos\\theta}} \\\\     \\frac{-a_y}{-a_z} &amp;= \\tan\\phi_a \\\\     \\phi_a &amp;= \\tan^{-1} \\left( \\dfrac{-a_y}{-a_z} \\right) \\end{align} \\] <p>J\u00e1 a medi\u00e7\u00e3o do \u00e2ngulo \\(\\theta_a\\) depende das leituras do aceler\u00f4metro \\(a_x\\), \\(a_y\\) e \\(a_z\\), e a dedu\u00e7\u00e3o \u00e9 um pouco mais complexa:</p> \\[ \\begin{align}     \\frac{a_x^2}{a_y^2+a_z^2} &amp;= \\frac{(g\\sin\\theta_a)^2}{(-g\\sin\\phi_a\\cos\\theta_a)^2+(-g\\cos\\phi_a\\cos\\theta_a)^2} \\\\     \\frac{a_x^2}{a_y^2+a_z^2} &amp;= \\frac{g^2\\sin^2\\theta_a}{g^2\\sin^2\\phi_a\\cos^2\\theta_a+g^2\\cos^2\\phi_a\\cos^2\\theta_a} \\\\     \\frac{a_x^2}{a_y^2+a_z^2} &amp;= \\frac{\\cancel{g^2}\\sin^2\\theta_a}{\\cancel{g^2}\\cos^2\\cancelto{1}{(\\sin^2\\phi_a+\\cos^2\\phi_a)}} \\\\     \\frac{a_x^2}{a_y^2+a_z^2} &amp;= \\frac{\\sin^2\\theta_a}{\\cos^2\\theta_a} \\\\     \\frac{a_x^2}{a_y^2+a_z^2} &amp;= \\tan^2\\theta_a \\\\     \\sqrt{\\frac{a_x^2}{a_y^2+a_z^2}} &amp;= \\tan\\theta_a \\\\     \\frac{a_x}{\\sqrt{a_y^2+a_z^2}} &amp;= \\tan\\theta_a \\\\     \\theta_a &amp;= \\tan^{-1} \\left( \\frac{a_x}{\\sqrt{a_y^2+a_z^2}} \\right) \\end{align} \\] <p>Os \u00e2ngulos de Euler \\(\\phi_g\\), \\(\\theta_g\\) e \\(\\psi_g\\) medidos a partir das leituras do girosc\u00f3pio \\(g_x\\), \\(g_y\\) e \\(g_z\\) s\u00e3o dados por:</p> <p></p> \\[ \\left\\{ \\begin{array}{l}     \\phi_g = \\phi + \\left( g_x + g_y \\sin\\phi\\tan\\theta + g_z \\cos\\phi\\tan\\theta \\right) \\Delta t \\\\     \\theta_g = \\theta + \\left( g_y \\cos\\phi - g_z \\sin\\phi \\right) \\Delta t \\\\     \\psi_g = \\psi + \\left( g_y \\sin\\phi\\sec\\theta + g_z \\cos\\phi\\sec\\theta \\right) \\Delta t \\end{array} \\right. \\] Dedu\u00e7\u00e3o <p>As derivadas dos \u00e2ngulos de Euler em fun\u00e7\u00e3o das velocidades angulares s\u00e3o dadas pela equa\u00e7\u00e3o cinem\u00e1tica de rota\u00e7\u00e3o:</p> \\[ \\begin{bmatrix}     \\dot{\\phi} \\\\     \\dot{\\theta} \\\\     \\dot{\\psi} \\end{bmatrix} =  \\begin{bmatrix}      1 &amp; \\sin\\phi\\tan\\theta &amp; \\cos\\phi\\tan\\theta \\\\     0 &amp; \\cos\\phi &amp; - \\sin\\phi\\\\     0 &amp; \\sin\\phi\\sec\\theta &amp; \\cos\\phi\\sec\\theta  \\end{bmatrix} \\begin{bmatrix}     \\omega_x \\\\     \\omega_z \\\\     \\omega_y \\end{bmatrix} \\] <p>Como:</p> \\[ \\begin{bmatrix}     g_x \\\\     g_z \\\\     g_y \\end{bmatrix} = \\begin{bmatrix}     \\omega_x \\\\     \\omega_z \\\\     \\omega_y \\end{bmatrix} \\] <p>Logo, substituindo e integrando ao longo do tempo:</p> \\[ \\begin{align*}     \\begin{bmatrix}         \\phi_g \\\\         \\theta_g \\\\         \\psi_g     \\end{bmatrix}     &amp;=     \\begin{bmatrix}         \\phi \\\\         \\theta \\\\         \\psi     \\end{bmatrix}     +     \\begin{bmatrix}         \\dot{\\phi}  \\\\         \\dot{\\theta} \\\\         \\dot{\\psi}     \\end{bmatrix} \\Delta t \\\\     \\begin{bmatrix}         \\phi_g  \\\\         \\theta_g  \\\\         \\psi_g      \\end{bmatrix}     &amp;=     \\begin{bmatrix}         \\phi \\\\         \\theta \\\\         \\psi     \\end{bmatrix}     +     \\begin{bmatrix}         1 &amp; \\sin\\phi\\tan\\theta &amp; \\cos\\phi\\tan\\theta \\\\         0 &amp; \\cos\\phi &amp; -\\sin\\phi \\\\         0 &amp; \\sin\\phi\\sec\\theta &amp; \\cos\\phi\\sec\\theta     \\end{bmatrix}     \\begin{bmatrix}         g_x  \\\\         g_y  \\\\         g_z      \\end{bmatrix} \\Delta t \\end{align*}  \\] <p>Modifique a sua fun\u00e7\u00e3o <code>attitudeEstimator()</code> de modo que agora os \u00e2ngulos estimados \\(\\phi\\), \\(\\theta\\) e \\(\\psi\\) sejam dados por um filtro complementar entre as medidas do aceler\u00f4metro \\(\\phi_a\\) e \\(\\theta_a\\) e girosc\u00f3pio \\(\\phi_g\\), \\(\\theta_g\\) e \\(\\psi_g\\).</p> <pre><code>// Estimate orientation from IMU sensor\nvoid attitudeEstimator()\n{\n    // Estimator parameters\n    static const float wc = \n    static const float alpha = \n\n    // Measured angles from accelerometer\n    float phi_a = \n    float theta_a = \n\n    // Measured angles from gyroscope\n    float phi_g = \n    float theta_g = \n    float psi_g = \n\n    // Estimated angles (accelerometer and gyroscope with complementary filter)\n    phi = \n    theta = \n    psi = \n\n    // Angular velocities estimation (gyroscope)\n    wx = \n    wy = \n    wz = \n\n    // Auxiliary variables for logging Euler angles (CFClient uses degrees and not radians)\n    log_phi = phi * 180.0f / pi;\n    log_theta = -theta * 180.0f / pi;\n    log_psi = psi * 180.0f / pi;\n}\n</code></pre> <p>Carregue esse programa no drone e utilize o Crazyflie Client para visualizar o resultado de um estimador de atitude completo!</p>"},{"location":"pages/control/attitude/estimator/attitude_estimator/#validacao","title":"Valida\u00e7\u00e3o","text":""},{"location":"pages/control/horizontal/controller/horizontal_controller/","title":"Controlador horizontal","text":""},{"location":"pages/control/horizontal/estimator/horizontal_estimator/","title":"Estimador horizontal","text":""},{"location":"pages/control/mixer/mixer/","title":"Mixer","text":"<p>Nesta sec\u00e7\u00e3o voc\u00ea ir\u00e1 implementar o mixer, que converte as for\u00e7as e torques totais produzidos pelas h\u00e9lices \\(f_t\\), \\(\\tau_x\\), \\(\\tau_y\\) e \\(\\tau_z\\) nos sinais PWM correspondentes dos motores.</p> <p></p> <p>Para isto, ser\u00e3o implementadas tr\u00eas fun\u00e7\u00f5es:</p> <ul> <li><code>reference()</code></li> <li><code>mixer()</code></li> <li><code>actuators()</code></li> </ul>"},{"location":"pages/control/mixer/mixer/#implementacao","title":"Implementa\u00e7\u00e3o","text":"<p>Para come\u00e7ar, crie um arquivo chamado <code>mixer.c</code> dentro da pasta <code>src/control</code>.</p> <p>Esse arquivo ser\u00e1 dividido em tr\u00eas grandes blocos, conforme mostrado abaixo:</p> <pre><code>/* === Definitions ======================================================= */\n\n/* === Functions ========================================================= */\n\n/* === Main Loop ========================================================= */\n</code></pre>"},{"location":"pages/control/mixer/mixer/#definicoes","title":"Defini\u00e7\u00f5es","text":""},{"location":"pages/control/mixer/mixer/#bibliotecas-necessarias","title":"Bibliotecas necess\u00e1rias","text":"<p>Logo no in\u00edcio desse arquivo, importe todas(1) as bibliotecas que ser\u00e3o utilizadas:</p> <ol> <li>Algumas dessas bibliotecas n\u00e3o s\u00e3o estritamente necess\u00e1rias para o mixer, mas j\u00e1 as inclu\u00edmos agora para evitar preocupa\u00e7\u00f5es futuras ao integrar os pr\u00f3ximos m\u00f3dulos.</li> </ol> <pre><code>#include \"math.h\"       // Math functions (e.g., sqrtf, roundf, powf)\n#include \"FreeRTOS.h\"   // FreeRTOS core definitions (needed for task handling and timing)\n#include \"task.h\"       // FreeRTOS task functions (e.g., vTaskDelay)\n#include \"supervisor.h\" // Functions to check flight status (e.g., supervisorIsArmed)\n#include \"commander.h\"  // Access to commanded setpoints (e.g., commanderGetSetpoint)\n#include \"estimator.h\"  // Estimation framework for sensor fusion\n#include \"motors.h\"     // Low-level motor control interface (e.g., motorsSetRatio)\n#include \"debug.h\"      // Debug printing functions (e.g., DEBUG_PRINT)\n#include \"log.h\"        // Logging utilities to send data to the CFClient\n</code></pre>"},{"location":"pages/control/mixer/mixer/#parametros-e-constantes","title":"Par\u00e2metros e constantes","text":"<p>Na sequ\u00eancia, declare(1) algumas constantes f\u00edsicas e par\u00e2metros do quadricoptero que ser\u00e3o bastante utilizados:</p> <ol> <li>Usamos <code>const</code> para garantir que o valor n\u00e3o muda em tempo de execu\u00e7\u00e3o. J\u00e1 o <code>static</code> limita a visibilidade da vari\u00e1vel ao arquivo atual, evitando conflitos de nomes em outros arquivos. Assim, <code>static const</code> cria constantes imut\u00e1veis e restritas ao arquivo.</li> </ol> <pre><code>// Physical constants\nstatic const float pi = 3.1416f; // Mathematical constant\nstatic const float g = 9.81f;    // Gravitational acceleration [m/s^2]\nstatic const float dt = 0.005f;  // Loop time step [s] (5 ms -&gt; 200 Hz)\n\n// Quadcopter parameters\nstatic const float l = 35.0e-3f;   // Distance from motor to quadcopter center of mass [m]\nstatic const float m = 38.6e-3f;   // Mass [kg]\nstatic const float Ixx = 20.0e-6f; // Moment of inertia around x-axis [kg.m^2]\nstatic const float Iyy = 20.0e-6f; // Moment of inertia around y-axis [kg.m^2]\nstatic const float Izz = 40.0e-6f; // Moment of inertia around z-axis [kg.m^2]\n</code></pre>"},{"location":"pages/control/mixer/mixer/#variaveis-globais","title":"Vari\u00e1veis globais","text":"<p>Em seguida, declare como vari\u00e1veis globais as vari\u00e1veis que entram e saem da fun\u00e7\u00e3o do mixer.</p> <pre><code>// Actuators\nfloat pwm1, pwm2, pwm3, pwm4; // Motors PWM\n\n// System inputs\nfloat ft;                     // Thrust force [N]\nfloat tx, ty, tz;             // Roll, pitch and yaw torques [N.m]\n</code></pre>"},{"location":"pages/control/mixer/mixer/#funcoes","title":"Fun\u00e7\u00f5es","text":""},{"location":"pages/control/mixer/mixer/#referencia","title":"Refer\u00eancia","text":"<p>Inicialmente, as for\u00e7as e torques ser\u00e3o comandados pelo Command Based Flight Control do Crazyflie Client.</p> <p></p> <ul> <li>Os bot\u00f5es <code>\u2191</code> / <code>\u2193</code> alteram a vari\u00e1vel <code>setpoint.position.x</code> em incrementos de \\(0,5\\)</li> <li>Os bot\u00f5es <code>\u2190</code> / <code>\u2192</code> alteram a vari\u00e1vel <code>setpoint.position.y</code> em incrementos de \\(0,5\\)</li> <li>Os bot\u00f5es <code>Up</code> / <code>Down</code> alteram a vari\u00e1vel <code>setpoint.position.z</code> em incrementos de \\(0,5\\)</li> </ul> <p>Vamos utilizar essas vari\u00e1veis para comandar a for\u00e7a total \\(f_t\\) em incrementos de \\(0,01\\,N\\) e os torques de rolagem \\(\\tau_x\\) e inclina\u00e7\u00e3o \\(\\tau_y\\) em incrementos de \\(0,001\\,N.m\\). Portanto, precisamos ajustar as escalas da seguinte forma(1):</p> <ol> <li>O torque \\(\\tau_x\\) possui uma invers\u00e3o de sinal pois o eixo \\(y\\), que \u00e9 comandado pelos bot\u00f5es <code>\u2190</code> e <code>\u2192</code>, est\u00e1 no sentido contr\u00e1rio do torque.</li> </ol> <p></p> <p>Abaixo temos um exemplo de fun\u00e7\u00e3o <code>reference()</code> que faz isso(1):</p> <ol> <li>Multiplicamos por \\(2\\), arredondamos e depois dividmos por \\(100\\) (ou \\(1000\\)) para garantir um arredondamento com \\(2\\) (ou \\(3\\)) casas decimais.</li> </ol> <pre><code>// Get reference setpoints from commander module\nvoid reference()\n{\n    // Declare variables that store the most recent setpoint and state from commander\n    static setpoint_t setpoint;\n    static state_t state;\n\n    // Retrieve the current commanded setpoints and state from commander module\n    commanderGetSetpoint(&amp;setpoint, &amp;state);\n\n    // Extract position references from the received setpoint\n    ft =  roundf((setpoint.position.z) * 2.0f) / 100.0f;    // Thrust force command [N] (maps 0.5m -&gt; 0.01N)\n    tx = -roundf((setpoint.position.y) * 2.0f) / 1000.0f;   // Roll torque command [N.m] (maps 0.5m -&gt; 0.001N.m)\n    ty =  roundf((setpoint.position.x) * 2.0f) / 1000.0f;   // Pitch torque command [N.m] (maps 0.5m -&gt; 0.001N.m)\n    tz = 0.0f;                                              // Yaw torque command [N.m]\n}\n</code></pre>"},{"location":"pages/control/mixer/mixer/#mixer_1","title":"Mixer","text":"<p>J\u00e1 deduzimos a matriz \\(M^{-1}\\) que converte as for\u00e7a e torques totais produzidos pelas h\u00e9lices \\(f_t\\), \\(\\tau_x\\), \\(\\tau_y\\) e \\(\\tau_z\\)  no quadrado das velocidades angulares dos motores \\(\\omega_1\\), \\(\\omega_2\\), \\(\\omega_3\\) e \\(\\omega_4\\) :</p> \\[ \\begin{bmatrix}     \\omega_1^2 \\\\     \\omega_2^2 \\\\     \\omega_3^2 \\\\     \\omega_4^2 \\end{bmatrix} =  \\underbrace{ \\begin{bmatrix}      \\frac{1}{4 k_l} &amp; - \\frac{1}{4 k_l l} &amp; - \\frac{1}{4 k_l l} &amp; - \\frac{1}{4 k_d}  \\\\      \\frac{1}{4 k_l} &amp; - \\frac{1}{4 k_l l} &amp; \\frac{1}{4 k_l l} &amp; \\frac{1}{4 k_d} \\\\      \\frac{1}{4 k_l} &amp; \\frac{1}{4 k_l l} &amp; \\frac{1}{4 k_l l} &amp; - \\frac{1}{4 k_d} \\\\      \\frac{1}{4 k_l} &amp; \\frac{1}{4 k_l l} &amp; - \\frac{1}{4 k_l l} &amp; \\frac{1}{4 k_d}  \\end{bmatrix} }_{M^{-1}} \\begin{bmatrix}     f_t \\\\     \\tau_x \\\\     \\tau_y \\\\     \\tau_z \\end{bmatrix} \\] <p>Al\u00e9m disso, tamb\u00e9m j\u00e1 determinanos os coeficientes dos motores \\(a_2\\) e \\(a_1\\) que convertem a velocidade angular \\(\\omega\\) do motor no sinal PWM correspondente:</p> \\[     PWM = a_2 \\omega^2 + a_1 \\omega \\] <p>Se unirmos essas duas fun\u00e7\u00f5es, temos a l\u00f3gica do mixer:</p> <p></p> <p>Voc\u00ea deve implementar essa l\u00f3gica na fun\u00e7\u00e3o <code>mixer()</code>(1): </p> <ol> <li>Declarare os par\u00e2metros do quadc\u00f3ptero previamente identificados como vari\u00e1veis locais.</li> </ol> <pre><code>// Compute motor commands\nvoid mixer()\n{\n    // Quadcopter parameters\n    static const float a2 = \n    static const float a1 = \n    static const float kl = \n    static const float kd = \n\n    // Compute required motor angular velocities squared (omega^2)\n    float omega1 =\n    float omega2 = \n    float omega3 =\n    float omega4 = \n\n    // Clamp to non-negative and take square root (omega)\n    omega1 =\n    omega2 =\n    omega3 =\n    omega4 =\n\n    // Compute motor PWM using motor model\n    pwm1 = \n    pwm2 = \n    pwm3 = \n    pwm4 = \n}\n</code></pre> <p>Aten\u00e7\u00e3o</p> <p>Cuidado ao tirar a raiz quadrada de n\u00fameros negativos! Voc\u00ea deve checar o sinal de \\(\\omega^2\\), e s\u00f3 tirar a raiz quadrada se ele for positivo.</p>"},{"location":"pages/control/mixer/mixer/#atuadores","title":"Atuadores","text":"<p>A fun\u00e7\u00e3o <code>actuators()</code> apenas envia os valores dos sinais PWM calculados aos motores: </p> <p></p> <p>No entanto, ela faz isso apenas quando o drone \u00e9 armado pelo Crazyflie Client com o bot\u00e3o <code>Arm</code>, conforme exemplo abaixo:</p> <pre><code>// Apply motor commands\nvoid actuators()\n{\n    // Check is quadcopter is armed or disarmed\n    if (supervisorIsArmed())\n    {\n        // Apply calculated PWM values if is commanded to take-off\n        motorsSetRatio(MOTOR_M1, pwm1 * UINT16_MAX);\n        motorsSetRatio(MOTOR_M2, pwm2 * UINT16_MAX);\n        motorsSetRatio(MOTOR_M3, pwm3 * UINT16_MAX);\n        motorsSetRatio(MOTOR_M4, pwm4 * UINT16_MAX);\n    }\n    else\n    {\n        // Turn-off all motor if disarmed\n        motorsStop();\n    }\n}\n</code></pre> <p>Voc\u00ea pode simplesmente copiar e colar o c\u00f3digo acima. Se quiser entender ele melhor, volte na sec\u00e7\u00e3o dos motores.</p>"},{"location":"pages/control/mixer/mixer/#loop-principal","title":"Loop principal","text":"<p>Por fim, temos o loop principal que executa as tr\u00eas fun\u00e7\u00f5es definidas na sequ\u00eancia em uma frequ\u00eancia de 200 Hz.</p> <pre><code>// Main application task\nvoid appMain(void *param)\n{\n    // Infinite loop (runs at 200Hz)\n    while (true)\n    {\n        reference();                  // Read reference setpoints (from Crazyflie Client)\n        mixer();                      // Convert desired force/torques into motor PWM\n        motors();                     // Send commands to motors\n        vTaskDelay(pdMS_TO_TICKS(5)); // Loop delay (5 ms)\n    }\n}\n</code></pre>"},{"location":"pages/control/mixer/mixer/#validacao","title":"Valida\u00e7\u00e3o","text":"<p>Para validar sua implementa\u00e7\u00e3o voc\u00ea deve realizar alguns teste simples, que consistem apenas em verificar se os motores corretos est\u00e3o aumentando ou diminuindo suas velocidades angulares.</p> <p></p> <p>Aten\u00e7\u00e3o</p> <p>Muitos alunos pulam um teste ou outro e s\u00f3 v\u00e3o descobrir o problema l\u00e1 na frente, ao passarem horas tentando entender por que o drone deles n\u00e3o voa. N\u00e3o seja essa pessoa.</p>"},{"location":"pages/control/mixer/mixer/#forca-de-empuxo-f_t","title":"For\u00e7a de empuxo \\(f_t\\)","text":"<p>Arme o drone a altere o valor da for\u00e7a de empuxo \\(f_t\\) com os bot\u00f5es <code>Up</code> e <code>Down</code>. Verifique se todos os quatro motores aumentam e diminuem suas velocidades angulares conforme voc\u00ea faz isso.</p>"},{"location":"pages/control/mixer/mixer/#torque-de-rolagem-tau_x","title":"Torque de rolagem \\(\\tau_x\\)","text":"<p>Arme o drone a altere o valor do torque de rolagem \\(\\tau_x\\) com os bot\u00f5es <code>\u2190</code> e <code>\u2192</code>. Verifique se apenas os motores 3 e 4 ligam com valores positivos e os motores 1 e 2 com valores negativos.</p>"},{"location":"pages/control/mixer/mixer/#torque-de-inclinacao-tau_y","title":"Torque de inclina\u00e7\u00e3o \\(\\tau_y\\)","text":"<p>Arme o drone a altere o valor do torque de inclina\u00e7\u00e3o \\(\\tau_y\\) com os bot\u00f5es <code>\u2191</code> e <code>\u2193</code>. Verifique se apenas os motores 2 e 3 ligam com valores positivos e os motores 1 e 4 com valores negativos.</p>"},{"location":"pages/control/mixer/mixer/#torque-de-guinagem-tau_z","title":"Torque de guinagem \\(\\tau_z\\)","text":"<p>Modifique a fun\u00e7\u00e3o de refer\u00eancia, para que os bot\u00f5es <code>\u2190</code> e <code>\u2192</code> alterem o valor do torque de guinagem \\(\\tau_z\\) em incrementos de \\(0,0001\\,N.m\\)(1):</p> <ol> <li>Note que \u00e9 uma casa decimal a mais.</li> </ol> <p></p> <p>Arme o drone a altere o valor do torque de guinagem \\(\\tau_z\\) com os bot\u00f5es <code>\u2190</code> e <code>\u2192</code>. Verifique se apenas os motores 2 e 4 ligam com valores positivos e os motores 1 e 3 com valores negativos.</p>"},{"location":"pages/control/vertical/controller/vertical_controller/","title":"Controlador vertical","text":"<p>Nesta sec\u00e7\u00e3o voc\u00ea ir\u00e1 implementar o controlador vertical, que comanda a for\u00e7a de empuxo \\({\\color{var(--c2)}f_t}\\) a partir da diferen\u00e7a entre a posi\u00e7\u00e3o vertical de refer\u00eancia \\({\\color{var(--c3)}z_r}\\) e estimada \\({\\color{var(--c1)}z}\\).</p> <p></p> <p>Para isto, ser\u00e1 implementada uma nova fun\u00e7\u00e3o:</p> <ul> <li><code>verticalController()</code></li> </ul> <p>Al\u00e9m de uma altera\u00e7\u00e3o em uma fun\u00e7\u00e3o j\u00e1 previamente implementada:</p> <ul> <li><code>reference()</code></li> </ul>"},{"location":"pages/control/vertical/controller/vertical_controller/#implementacao","title":"Implementa\u00e7\u00e3o","text":"<p>Para come\u00e7ar, copie e cole o arquivo <code>vertical_estimator.c</code> e renomeie ele para <code>vertical_controller.c</code>.</p>"},{"location":"pages/control/vertical/controller/vertical_controller/#definicoes","title":"Defini\u00e7\u00f5es","text":""},{"location":"pages/control/vertical/controller/vertical_controller/#variaveis-globais","title":"Vari\u00e1veis globais","text":"<p>Declare mais uma vari\u00e1vel global, que corresponde \u00e0 posi\u00e7\u00e3o vertical de refer\u00eancia \\({\\color{var(--c3)}z_r}\\).</p> <pre><code>// Actuators\nfloat pwm1, pwm2, pwm3, pwm4; // Motors PWM\n\n// Sensors\nfloat ax, ay, az;             // Accelerometer [m/s^2]\nfloat gx, gy, gz;             // Gyroscope [rad/s]\nfloat d;                      // Range [m]\n\n// System inputs\nfloat ft;                    // Thrust force [N]\nfloat tx, ty, tz;            // Roll, pitch and yaw torques [N.m]\n\n// System states\nfloat phi, theta, psi;       // Euler angles [rad]\nfloat wx, wy, wz;            // Angular velocities [rad/s]\nfloat z;                     // Vertical position [m]\nfloat vz;                    // Vertical velocity [m/s]\n\n// System references\nfloat phi_r, theta_r, psi_r; // Euler angles reference [rad]\nfloat z_r                    // Vertical position reference [m]\n</code></pre>"},{"location":"pages/control/vertical/controller/vertical_controller/#loop-principal","title":"Loop principal","text":"<p>Inclua a chamada da fun\u00e7\u00e3o <code>verticalController()</code> no loop principal.</p> <pre><code>// Main application task\nvoid appMain(void *param)\n{\n    // Infinite loop (runs at 200Hz)\n    while (true)\n    {\n        reference();                  // Read reference setpoints (from Crazyflie Client)\n        sensors();                    // Read raw sensor measurements\n        attitudeEstimator();          // Estimate orientation (roll/pitch/yaw) from IMU sensor\n        verticalEstimator();          // Estimate vertical position/velocity from range sensor\n        verticalController();         // Compute desired thrust force\n        attitudeController();         // Compute desired roll/pitch/yaw torques\n        mixer();                      // Convert desired force/torques into motor PWM\n        actuators();                  // Send commands to motors\n        vTaskDelay(pdMS_TO_TICKS(5)); // Loop delay (5 ms)\n    }\n}\n</code></pre>"},{"location":"pages/control/vertical/controller/vertical_controller/#funcoes","title":"Fun\u00e7\u00f5es","text":""},{"location":"pages/control/vertical/controller/vertical_controller/#referencia","title":"Refer\u00eancia","text":"<p>A posi\u00e7\u00e3o vertical de refer\u00eancia \\({\\color{var(--c3)}z_r}\\) ser\u00e1 comandada pelo Command Based Flight Control do Crazyflie Client utilizando os bot\u00f5es Up e Down.</p> <p></p> <p>Modifique a fun\u00e7\u00e3o <code>reference()</code> para que a posi\u00e7\u00e3o vertical de refer\u00eancia \\({\\color{var(--c3)}z_r}\\) seja definida pela vari\u00e1vel <code>setpoint.position.z</code>.</p> <pre><code>// Get reference setpoints from commander module\nvoid reference()\n{\n    // Declare variables that store the most recent setpoint and state from commander\n    static setpoint_t setpoint;\n    static state_t state;\n\n    // Retrieve the current commanded setpoints and state from commander module\n    commanderGetSetpoint(&amp;setpoint, &amp;state);\n\n    // Extract position references from the received setpoint\n    z_r = setpoint.position.z;                        // Z position reference [m]\n    phi_r = (setpoint.position.y * 2.0f) * pi/4.0f;   // Roll reference command [rad] (maps 0.5m -&gt; pi/4 rad)\n    theta_r = (setpoint.position.y * 2.0f) * pi/4.0f; // Pitch reference command [rad] (maps 0.5m -&gt; pi/4 rad)\n    psi_r = 0.0f;                                     // Yaw reference command [rad]\n}\n</code></pre>"},{"location":"pages/control/vertical/controller/vertical_controller/#controlador-vertical_1","title":"Controlador vertical","text":"<p>A fun\u00e7\u00e3o <code>verticalController()</code> \u00e9 quem comanda a for\u00e7a de empuxo \\({\\color{var(--c2)}f_t}\\) a partir da diferen\u00e7a entre a posi\u00e7\u00e3o vertical de refer\u00eancia \\({\\color{var(--c3)}z_r}\\) e estimada \\({\\color{var(--c1)}z}\\).</p> <pre><code>// Compute desired thrust force\nvoid verticalController()\n{ \n}\n</code></pre> <p>J\u00e1 vimos que a din\u00e2mica linearizada de um quadric\u00f3ptero pode ser representada pelo diagrama de blocos abaixo:</p> <p></p> <p>A din\u00e2mica de posi\u00e7\u00e3o vertical \u00e9 descrita pela seguinte parte:</p> <p></p> <p>Podemos cancelar a massa e a acelera\u00e7\u00e3o da gravidade de modo que a vari\u00e1vel de controle seja a acelera\u00e7\u00e3o vertical:</p> <p></p> <p>Isso reduz o sistema a ser controlado a um integrador duplo, exatamente como fizemos com o controlador de atitude. No entanto, agora temos um problema adicional: como estamos somando o termo da acelera\u00e7\u00e3o da gravidade (diferentemente da massa que est\u00e1 sendo multiplicada), caso ele seja um pouco diferente do real, n\u00e3o acontecer\u00e1 um cancelamento exato e o sistema possuir\u00e1 erro em regime permanente. Para resolver esse problema, podemos incluir um integrador no controlador.</p> PIDPI-PLQI <p>O controlador proporcional integral derivativo (PID) adiciona \u00e0 estrutura proporcional derivativo um termo integral que acumula o erro ao longo do tempo, eliminando o erro estacion\u00e1rio. A a\u00e7\u00e3o proporcional e derivativa garantem resposta r\u00e1pida e amortecida, enquanto a integral corrige desvios persistentes. \u00c9 vers\u00e1til e eficaz para o integrador duplo, mas o termo integral exige cuidado para evitar oscila\u00e7\u00f5es de baixa frequ\u00eancia (windup) e lentid\u00e3o na resposta.</p> <p></p> <p>Olhando o controlador isoladamente, temos o seguinte diagrama de blocos:</p> <p></p> <p>Que se traduz nas equa\u00e7\u00f5es abaixo:</p> \\[ \\left\\{ \\begin{array}{l}     z_e = {\\color{var(--c3)}z_r} - {\\color{var(--c1)}z} \\\\     {\\color{var(--c2)}f_t} = m \\left( g + \\left( k_p z_e + k_d \\dfrac{d z_e}{dt}  + k_i \\displaystyle\\int z_e dt \\right) \\right) \\end{array} \\right. \\] <p>Inclua na fun\u00e7\u00e3o <code>attitudeController()</code> duas vari\u00e1veis locais \\(k_p\\) e \\(k_d\\), que correspondem aos ganhos do controlador, e, em seguida, calcule o torque comandado \\({\\color{var(--c2)}f_t}\\) seguindo as equa\u00e7\u00f5es acima.</p> <pre><code>// Compute desired torques\nvoid attitudeController()\n{\n    // Controller parameters (settling time of 0.3s and overshoot of 0,05%)\n    static const float kp = \n    static const float kd = \n\n    // Last error (static to retain value amoung function calls)\n    static float theta_e_last;\n\n    // Compute angular aceleration reference\n    float theta_e = \n    float theta_dot_e =\n    float theta_ddot_r =\n    float tau_x =\n\n    // Update last error for next call\n    theta_e_last = theta_e;\n\n    // Compute desired torque\n    ty = \n}\n</code></pre> <p>O controlador proporcional em cascata com a\u00e7\u00e3o integral (PI-P) na malha externa combina uma malha interna proporcional com uma malha externa proporcional com a\u00e7\u00e3o integral. A malha interna garante resposta r\u00e1pida e amortecida, enquanto o termo integral na malha externa elimina o erro estacion\u00e1rio de posi\u00e7\u00e3o. Essa configura\u00e7\u00e3o equilibra desempenho e simplicidade, oferecendo boa robustez sem exigir integra\u00e7\u00f5es redundantes, mas requer sintonia coordenada entre as duas malhas.</p> <p></p> <p>Olhando o controlador isoladamente, temos o seguinte diagrama de blocos:</p> <p></p> <p>Que se traduz nas equa\u00e7\u00f5es abaixo:</p> \\[ \\left\\{ \\begin{array}{l}     \\dot{z}_r = k_p ( {\\color{var(--c3)}z_r} - {\\color{var(--c1)}z} ) \\\\     \\ddot{z}_r = k_d ( \\dot{z}_r - {\\color{var(--c1)}\\dot{z}} ) \\\\     {\\color{var(--c2)}f_t} = m ( g + \\ddot{z}_r ) \\end{array} \\right. \\] <p>Inclua na fun\u00e7\u00e3o <code>attitudeController()</code> duas vari\u00e1veis locais \\(k_p\\) e \\(k_d\\), que correspondem aos ganhos do controlador, e, em seguida, calcule o torque comandado \\({\\color{var(--c2)}f_t}\\) seguindo as equa\u00e7\u00f5es acima.</p> <pre><code>// Compute desired torques\nvoid attitudeController()\n{\n    // Controller parameters (settling time of 0.3s and overshoot of 0,05%)\n    static const float kp = \n    static const float kd = \n\n    // Compute angular aceleration reference\n    float theta_dot_r = \n    float theta_ddot_r =\n\n    // Compute desired torque\n    ty = \n}\n</code></pre> <p>O regulador de estados com a\u00e7\u00e3o integral estende o regulador de estados tradicional adicionando uma vari\u00e1vel que integra o erro de sa\u00edda ao vetor de estados. Isso permite eliminar o erro estacion\u00e1rio sem perder as vantagens do controle por realimenta\u00e7\u00e3o completa. A estrutura resultante combina desempenho din\u00e2mico ajust\u00e1vel \u2014 por meio do posicionamento dos polos \u2014 com precis\u00e3o em regime permanente. \u00c9 uma solu\u00e7\u00e3o elegante e sistem\u00e1tica, mas requer modelagem ampliada e c\u00e1lculo de ganhos por m\u00e9todos de espa\u00e7o de estados, como o posicionamento de polos ou o LQI.</p> <p></p> <p>Olhando o controlador isoladamente, temos o seguinte diagrama de blocos(1):</p> <ol> <li>No sistema linearizado temos que \\({\\color{var(--c3)}\\dot{z}_r} = {\\color{var(--c3)}v_{z_r}}\\) e \\({\\color{var(--c1)}\\dot{z}} = {\\color{var(--c1)}v_z}\\).</li> </ol> <p></p> <p>Que se traduz na equa\u00e7\u00e3o abaixo(1):</p> <ol> <li> <p>Como o objetivo \u00e9 deixar o quadric\u00f3ptero estacion\u00e1rio, a velocidade angular de refer\u00eancia \\({\\color{var(--c3)}v_{z_r}}\\) pode ser assumida como sendo zero, o que reduz um dos termos:</p> \\[ k_d \\left( \\cancelto{0}{{\\color{var(--c3)}v_{z_r}}} - {\\color{var(--c1)}\\dot{z}} \\right) = - k_d  {\\color{var(--c1)}v_z} \\] </li> </ol> \\[ \\left\\{ \\begin{array}{l}     z_e = {\\color{var(--c3)}z_r} - {\\color{var(--c1)}z} \\\\     {\\color{var(--c2)}f_t} = m \\left( g + \\left( k_p z_e + k_i \\displaystyle\\int z_e dt - k_d {\\color{var(--c1)}v_z} \\right) \\right) \\end{array} \\right. \\] <p>Inclua na fun\u00e7\u00e3o <code>verticalController()</code> tr\u00eas vari\u00e1veis locais \\(k_p\\), \\(k_d\\) e \\(k_i\\), que correspondem aos ganhos do controlador, e, em seguida, calcule a for\u00e7a comandada \\({\\color{var(--c2)}f_t}\\)(1).</p> <ol> <li>A termo integral do erro \\(z_{e_{int}} = \\displaystyle\\int z_e dt\\) pode ser calculado com uma vari\u00e1vel auxiliar conforme exemplo abaixo.</li> </ol> <pre><code>// Compute desired thrust force\nvoid verticalController()\n{\n    // Controller parameters (settling time of 0.3s and overshoot of 0,05%)\n    static const float kp = \n    static const float kd = \n    static const float ki = \n\n    // Compute angle error\n    float z_e = \n\n    // Calculate integral term (static to retain value amoung function calls)\n    static float z_e_int;\n    z_e_int += z_e*dt;\n\n    // Compute desired force\n    ft = \n}\n</code></pre>"},{"location":"pages/control/vertical/estimator/vertical_estimator/","title":"Estimador vertical","text":"<p>Nesta sec\u00e7\u00e3o voc\u00ea ir\u00e1 implementar o estimador vertical, que estima a posi\u00e7\u00e3o \\({\\color{var(--c1)}z}\\) e velocidade \\({\\color{var(--c1)}v_z}\\) a partir da leitura do sensor de proximidade \\({\\color{var(--c3)}d}\\).</p> <p></p> <p>Para isto, ser\u00e1 implementada uma nova fun\u00e7\u00e3o:</p> <ul> <li><code>verticalEstimator()</code></li> </ul> <p>Al\u00e9m de uma altera\u00e7\u00e3o em uma fun\u00e7\u00e3o j\u00e1 previamente implementada:</p> <ul> <li><code>sensors()</code></li> </ul>"},{"location":"pages/control/vertical/estimator/vertical_estimator/#implementacao","title":"Implementa\u00e7\u00e3o","text":"<p>Para come\u00e7ar, copie e cole o arquivo <code>attitude_controller.c</code> e renomeie ele para <code>vertical_estimator.c</code>.</p>"},{"location":"pages/control/vertical/estimator/vertical_estimator/#definicoes","title":"Defini\u00e7\u00f5es","text":""},{"location":"pages/control/vertical/estimator/vertical_estimator/#variaveis-globais","title":"Vari\u00e1veis globais","text":"<p>Declare mais algumas vari\u00e1veis globais, que s\u00e3o as vari\u00e1veis que entram e saem da fun\u00e7\u00e3o do estimador vertical.</p> <pre><code>// Actuators\nfloat pwm1, pwm2, pwm3, pwm4; // Motors PWM\n\n// Sensors\nfloat ax, ay, az;             // Accelerometer [m/s^2]\nfloat gx, gy, gz;             // Gyroscope [rad/s]\nfloat d;                      // Range [m]\n\n// System inputs\nfloat ft;                     // Thrust force [N]\nfloat tx, ty, tz;             // Roll, pitch and yaw torques [N.m]\n\n// System states\nfloat phi, theta, psi;        // Euler angles [rad]\nfloat wx, wy, wz;             // Angular velocities [rad/s]\nfloat z;                      // Vertical position [m]\nfloat vz;                     // Vertical velocity [m/s]\n\n// System references\nfloat phi_r, theta_r, psi_r; // Euler angles reference [rad]\n</code></pre>"},{"location":"pages/control/vertical/estimator/vertical_estimator/#variaveis-de-registro","title":"Vari\u00e1veis de registro","text":"<p>Adicione as vari\u00e1veis criadas ao grupo de registro previamente definido, para que seja poss\u00edvel visualizar nossa estimativa em tempo real no Crazyflie Client.</p> <pre><code>// Logging group that stream variables to CFClient.\nLOG_GROUP_START(stateEstimate)\nLOG_ADD_CORE(LOG_FLOAT, roll, &amp;log_phi)\nLOG_ADD_CORE(LOG_FLOAT, pitch, &amp;log_theta)\nLOG_ADD_CORE(LOG_FLOAT, yaw, &amp;log_psi)\nLOG_ADD_CORE(LOG_FLOAT, z, &amp;z)\nLOG_ADD_CORE(LOG_FLOAT, vz, &amp;vz)\nLOG_GROUP_STOP(stateEstimate)\n</code></pre>"},{"location":"pages/control/vertical/estimator/vertical_estimator/#loop-principal","title":"Loop principal","text":"<p>Inclua no seu loop principal a chamada da fun\u00e7\u00e3o <code>verticalEstimator()</code> entre as fun\u00e7\u00f5es <code>attitudeEstimator()</code> e <code>attitudeController()</code>.</p> <pre><code>// Main application task\nvoid appMain(void *param)\n{\n    // Infinite loop (runs at 200Hz)\n    while (true)\n    {\n        reference();                  // Read reference setpoints (from Crazyflie Client)\n        sensors();                    // Read raw sensor measurements\n        attitudeEstimator();          // Estimate orientation (roll/pitch/yaw) from IMU sensor\n        verticalEstimator();          // Estimate vertical position/velocity from range sensor\n        attitudeController();         // Compute desired roll/pitch/yaw torques\n        mixer();                      // Convert desired force/torques into motor PWM\n        actuators();                  // Send commands to motors\n        vTaskDelay(pdMS_TO_TICKS(5)); // Loop delay (5 ms)\n    }\n}\n</code></pre>"},{"location":"pages/control/vertical/estimator/vertical_estimator/#funcoes","title":"Fun\u00e7\u00f5es","text":""},{"location":"pages/control/vertical/estimator/vertical_estimator/#sensores","title":"Sensores","text":"<p>Inclua na fun\u00e7\u00e3o <code>sensors()</code> um c\u00f3digo adicional que pega a leitura do sensor de proximidade e armazena ela na vari\u00e1vel global previamente declarada.</p> <pre><code>// Get sensor readings from estimator module\nvoid sensors()\n{\n    // Declare variable that store the most recent measurement from estimator\n    static measurement_t measurement;\n\n    // Retrieve the current measurement from estimator module\n    while (estimatorDequeue(&amp;measurement))\n    {\n        switch (measurement.type)\n        {\n        // Get accelerometer sensor readings and convert [G's -&gt; m/s^2]\n        case MeasurementTypeAcceleration:\n            ax = -measurement.data.acceleration.acc.x * g;\n            ay = -measurement.data.acceleration.acc.y * g;\n            az = -measurement.data.acceleration.acc.z * g;\n            break;\n        // Get gyroscope sensor readings and convert [deg/s -&gt; rad/s]\n        case MeasurementTypeGyroscope:\n            gx = measurement.data.gyroscope.gyro.x * pi / 180.0f;\n            gy = measurement.data.gyroscope.gyro.y * pi / 180.0f;\n            gz = measurement.data.gyroscope.gyro.z * pi / 180.0f;\n            break;\n        // Get flow sensor readings [m]\n        case MeasurementTypeTOF:\n            d = measurement.data.tof.distance;\n            break;\n        default:\n            break;\n        }\n    }\n}\n</code></pre>"},{"location":"pages/control/vertical/estimator/vertical_estimator/#estimador-vertical_1","title":"Estimador vertical","text":"<p>A fun\u00e7\u00e3o <code>verticalEstimator()</code> \u00e9 quem estima a posi\u00e7\u00e3o e velocidade vertical a partir da leitura do sensor de proximidade.</p> <pre><code>// Estimate vertical position/velocity from range sensor\nvoid verticalEstimator()\n{\n}\n</code></pre> <p>O sensor de proximidade utilizado \u00e9 o VL53L1X, da STMicroelectronics, localizado no Flow Deck v2.</p> <p></p> <p>Esse sensor utiliza tecnologia VCSEL (\"Vertical Cavity Surface Emitting Laser\"), que mede a dist\u00e2ncia de um objeto com base no tempo de voo -  ToF (\"Time of Flight\") - dos f\u00f3tons emitidos. Ele possui um alcance de aproximadamente 4 cm a 4 m e uma taxa de amostragem m\u00e1xima de 50 Hz.</p> <p>Sensores de proximidade s\u00e3o dispositivos capazes de medir a dist\u00e2ncia de um objeto sem contato f\u00edsico, geralmente por meio da emiss\u00e3o e recep\u00e7\u00e3o de ondas refletidas. O princ\u00edpio \u00e9 sempre o mesmo \u2014 emite-se uma onda, analisa-se o retorno \u2014 variando apenas o tipo de onda e a propriedade medida (tempo de retorno, intensidade ou diferen\u00e7a de fase).</p> <p>Eles podem ser classificados em tr\u00eas categorias principais:</p> <ul> <li>Radar (\"Radio Detection and Ranging\") \u2014 utilizam ondas eletromagn\u00e9ticas de r\u00e1dio</li> <li>Sonar (\"Sound Navigation and Ranging\") \u2014 utilizam ondas sonoras (ultrass\u00f4nicas)</li> <li>Lidar (\"Light Detection and Ranging\") \u2014 utilizam ondas eletromagn\u00e9ticas de luz (infravermelha ou laser)</li> </ul> <p>Sensores VCSEL, como o VL53L1X, s\u00e3o portanto um tipo espec\u00edfico de Lidar, operando no espectro infravermelho pr\u00f3ximo e com alta precis\u00e3o em curtas dist\u00e2ncias.</p>"},{"location":"pages/control/vertical/estimator/vertical_estimator/#valor-medido","title":"Valor medido","text":"<p>Embora o sensor de proximidade me\u00e7a a dist\u00e2ncia ao solo no referencial do drone, o que realmente nos interessa \u00e9 a altura em rela\u00e7\u00e3o ao sistema inercial. Para isso, precisamos corrigir a medida levando em conta a inclina\u00e7\u00e3o do drone.</p> <p>2D</p> <p>Determine a posi\u00e7\u00e3o vertical medida \\({\\color{var(--c3)}z_m}\\) a partir da leitura do sensor de proximidade \\({\\color{var(--c3)}d}\\) e do \u00e2ngulo de rolagem \\({\\color{var(--c1)}\\phi}\\).</p> <p></p> Resposta <p></p> \\[ \\begin{align}     \\cos{\\color{var(--c1)}\\phi} &amp;= \\dfrac{{\\color{var(--c3)}z_m}}{{\\color{var(--c3)}d}} \\\\     {\\color{var(--c3)}z_m} &amp;= {\\color{var(--c3)}d} \\cos{\\color{var(--c1)}\\phi} \\\\ \\end{align} \\] <p>3D</p> <p>Determine a posi\u00e7\u00e3o vertical medida \\({\\color{var(--c3)}z_m}\\) a partir da leitura do sensor de proximidade \\({\\color{var(--c3)}d}\\) e dos \u00e2ngulos de rolagem \\({\\color{var(--c1)}\\phi}\\) e inclina\u00e7\u00e3o \\({\\color{var(--c1)}\\theta}\\).</p> <p></p> Resposta <p></p> \\[ \\begin{align}     \\cos{\\color{var(--c1)}\\theta} &amp;= \\dfrac{{\\color{var(--c3)}z_m}}{d'} \\\\     {\\color{var(--c3)}z_m} &amp;= d' \\cos{\\color{var(--c1)}\\theta} \\end{align} \\] \\[ \\begin{align}     \\cos{\\color{var(--c1)}\\phi} &amp;= \\dfrac{d'}{{\\color{var(--c3)}d}} \\\\     d' &amp;= {\\color{var(--c3)}d} \\cos{\\color{var(--c1)}\\phi} \\end{align} \\] \\[ \\begin{align}     {\\color{var(--c3)}z_m} &amp;= {\\color{var(--c3)}d} \\cos{\\color{var(--c1)}\\phi} \\cos {\\color{var(--c1)}\\theta}  \\end{align} \\] <p>Inclua na fun\u00e7\u00e3o <code>verticalEstimator()</code> uma vari\u00e1vel local \\({\\color{var(--c3)}z_m}\\), que corresponde ao valor medido a partir da leitura do sensor de proximidade \\({\\color{var(--c3)}d}\\) e dos \u00e2ngulos de rolagem \\({\\color{var(--c1)}\\phi}\\) e inclina\u00e7\u00e3o \\({\\color{var(--c1)}\\theta}\\) e, em seguida, atribua ela a dist\u00e2ncia vertical estimada \\(z\\).</p> <pre><code>// Estimate vertical position/velocity from range sensor\nvoid verticalEstimator()\n{\n    // Measured distante from range sensor\n    float z_m = \n\n    // Estimated distance\n    z = \n}\n</code></pre> <p>Verifique como est\u00e1 sua estimativa, para isso carregue esse programa no drone e utilize o Crazyflie Client para visualizar o resultado.</p> <p>Resultado esperado</p> <p>Voc\u00ea deve notar que estamos compensando corretamente altera\u00e7\u00f5es na orienta\u00e7\u00e3o do drone. No entanto, a estimativa possui muito ru\u00eddo. Ao inv\u00e9s de utilizarmos um filtro passa-baixas (como no estimador de atitude) para remover esse ru\u00eddo, vamos utilizar agora um observador de estados.</p>"},{"location":"pages/control/vertical/estimator/vertical_estimator/#observador-de-estados","title":"Observador de estados","text":"<p>Um observador de estados \u00e9 um modelo que, a partir das entradas e sa\u00eddas do sistema real (planta), estima internamente os seus estados.</p> <p>No nosso caso, a planta \u00e9 a din\u00e2mica vertical do drone e o observador de estados \u00e9 um sistema cujas entradas s\u00e3o a for\u00e7a de propuls\u00e3o total \\({\\color{var(--c2)}f_t}\\) e a posi\u00e7\u00e3o vertical medida \\({\\color{var(--c3)}z_m}\\), e as sa\u00eddas s\u00e3o a posi\u00e7\u00e3o e velocidade verticais estimadas \\({\\color{var(--c1)}z}\\) e \\({\\color{var(--c1)}v_z}\\), conforme diagrama de blocos abaixo:</p> <p></p> <p>Vamos projetar tr\u00eas observadores de estados na sequ\u00eancia um do outro. O primeiro ser\u00e1 bem simples, de ordem 1. Em seguida, vamos torn\u00e1-lo mais sofisticado, de ordem 2. Por fim, vamos considerar a entrada da planta em nosso observador.</p>"},{"location":"pages/control/vertical/estimator/vertical_estimator/#observador-de-ordem-1","title":"Observador de ordem 1","text":"<p>Vamos come\u00e7ar assumindo que o drone est\u00e1 parado, ou seja, sua posi\u00e7\u00e3o vertical permanece constante:</p> \\[ {\\color{var(--c1)}z} = \\text{cte} \\] <p>Chamamos esse caso de observador de ordem 1, pois o modelo da planta \u00e9 descrito por uma equa\u00e7\u00e3o diferencial de primeira ordem:</p> \\[ {\\color{var(--c1)}\\dot{z}} = 0 \\] <p>Agora, se realimentarmos a diferen\u00e7a entre a posi\u00e7\u00e3o vertical medida \\(z_m\\) e a estimada \\(z\\), obtemos um sistema cuja estimativa converge exponencialmente para a medida, desde que o ganho do observador \\(l\\) seja positivo:</p> \\[ {\\color{var(--c1)}\\dot{z}}  = 0 + l \\left( {\\color{var(--c3)}z_m}  - {\\color{var(--c1)}z}  \\right) \\] <p></p> <p>Esse diagrama de blocos pode ser resumido em uma \u00fanica fun\u00e7\u00e3o de transfer\u00eancia:</p> <p></p> <p>Note que essa fun\u00e7\u00e3o de transfer\u00eancia \u00e9 id\u00eantica \u00e0 de um filtro passa-baixas de primeira ordem, com o ganho \\(l\\) desempenhando o papel da frequ\u00eancia de corte \\(\\omega_c\\):</p> \\[ l = \\omega_c \\] <p>Em outras palavras, um observador de ordem 1 \u00e9 equivalente a um filtro passa-baixas: ele suaviza a medi\u00e7\u00e3o, filtrando ru\u00eddos de alta frequ\u00eancia e preservando a tend\u00eancia lenta da posi\u00e7\u00e3o vertical.</p> <p>Como o observador ser\u00e1 implementado em um microcontrolador, precisamos encontrar sua forma discreta. Voc\u00ea j\u00e1 fez isso anteriormente para um filtro passa-baixas usando o m\u00e9todo de Euler impl\u00edcito. Desta vez, vamos aplicar o m\u00e9todo de Euler expl\u00edcito(1):</p> <ol> <li> <p>A express\u00e3o derivada \u00e9 id\u00eantica \u00e0 que voc\u00ea j\u00e1 viu antes:</p> \\[ {\\color{var(--c1)}z[k+1]} = \\underbrace{\\left(1-l\\Delta t\\right)}_{\\left(1-\\alpha\\right)} {\\color{var(--c1)}z[k]} + \\underbrace{l\\Delta t}_{\\alpha} {\\color{var(--c3)}z_m[k]}  \\] <p>No entanto, o valor de \\(\\alpha\\) agora \u00e9 dado por:</p> \\[ \\alpha = l \\Delta t \\] <p>Isso significa que ele pode ultrapassar 1 se \\(l\\) for muito alto \u2014 o que torna o sistema inst\u00e1vel. Essa \u00e9 a desvantagem do m\u00e9todo expl\u00edcito em rela\u00e7\u00e3o ao impl\u00edcito. No entanto, basta garantir que:</p> \\[ l &lt; \\frac{1}{\\Delta t} \\] </li> </ol> \\[ \\begin{align*}     \\frac{{\\color{var(--c1)}z[k+1]}-{\\color{var(--c1)}z[k]}}{\\Delta t} + l{\\color{var(--c1)}z[k]} &amp;= l {\\color{var(--c3)}z_m[k]} \\\\     {\\color{var(--c1)}z[k+1]}-{\\color{var(--c1)}z[k]} + l\\Delta t{\\color{var(--c1)}z[k]} &amp;= l\\Delta t {\\color{var(--c3)}z_m[k]} \\\\     {\\color{var(--c1)}z[k+1]} - \\left( 1 - l\\Delta t \\right) {\\color{var(--c1)}z[k]} &amp;= l\\Delta t {\\color{var(--c3)}z_m[k]} \\\\     {\\color{var(--c1)}z[k+1]} &amp;= \\left(1-l\\Delta t\\right) {\\color{var(--c1)}z[k]} + l\\Delta t {\\color{var(--c3)}z_m[k]}  \\end{align*} \\] <p>A equa\u00e7\u00e3o discretizada pode ser reescrita de modo a evidenciar suas duas partes - uma de predi\u00e7\u00e3o e outra de corre\u00e7\u00e3o:</p> \\[ {\\color{var(--c1)}z[k+1]} = \\underbrace{{\\color{var(--c1)}z[k]}}_{\\text{Predi\u00e7\u00e3o}} + \\quad  \\underbrace{l \\Delta t \\left[ {\\color{var(--c3)}z_m[k]} - {\\color{var(--c1)}z[k]} \\right]}_{\\text{Corre\u00e7\u00e3o}} \\] <ul> <li>A parte de predi\u00e7\u00e3o \"prev\u00ea\" o valor com base no modelo (neste caso, de que a posi\u00e7\u00e3o vertical permanece constante)</li> <li>A parte de corre\u00e7\u00e3o \"corrige\" o valor com base na medi\u00e7\u00e3o (neste caso, a diferen\u00e7a entre a posi\u00e7\u00e3o medida e prevista)</li> </ul> <p>De forma equivalente, podemos representar o processo em duas etapas sequenciais, como ser\u00e1 implementado no c\u00f3digo(1):</p> <ol> <li>A etapa de predi\u00e7\u00e3o \u00e9 redundante neste caso, pois o modelo \u00e9 de ordem 1 e n\u00e3o h\u00e1 din\u00e2mica a propagar \u2014 o estado simplesmente permanece constante. Ainda assim, mantemos essa etapa para preservar a estrutura geral do observador (predi\u00e7\u00e3o seguida de corre\u00e7\u00e3o), que ser\u00e1 reutilizada nos casos de ordem 2, onde a predi\u00e7\u00e3o efetivamente calcula a evolu\u00e7\u00e3o do estado.</li> </ol> \\[ \\begin{align}     \\text{Predi\u00e7\u00e3o:} &amp;\\quad {\\color{var(--c1)}z[k+1]} = {\\color{var(--c1)}z[k]} \\\\ \\\\     \\text{Corre\u00e7\u00e3o:} &amp;\\quad {\\color{var(--c1)}z[k+1]} = {\\color{var(--c1)}z[k+1]} + l \\Delta t \\left({\\color{var(--c3)}z_m[k]} - {\\color{var(--c1)}z[k+1]}\\right) \\end{align} \\] <p>Modifique sua fun\u00e7\u00e3o <code>verticalEstimator()</code> para que a dist\u00e2ncia vertical \\(z\\) seja estimada por um observador de ordem 1 com as etapas de predi\u00e7\u00e3o e corre\u00e7\u00e3o.</p> <p><pre><code>// Estimate vertical position/velocity from range sensor\nvoid verticalEstimator()\n{\n    // Estimator parameters\n    static const float wc =              \n    static const float l =               \n\n    // Measured distante from range sensor\n    float z_m = \n\n    // Prediction step (model)\n    z = \n\n    // Correction step (measurement)\n    z = \n}\n</code></pre> Experimente uma frequ\u00eancia de corte \\(\\omega_c = 10\\)rad/s e verifique como isso influencia na sua estimativa.</p> <p>Resultado esperado</p> <p>Apesar da estimativa possuir bem menos ru\u00eddo agora, ela est\u00e1 lenta quando movimentamos o drone. Isso ocorre pois nosso modelo assume que o drone est\u00e1 sempre parado, o que nem sempre \u00e9 verdade. Para corrigir isso, vamos sofisticar um pouco nosso observador de estados.</p>"},{"location":"pages/control/vertical/estimator/vertical_estimator/#observador-de-ordem-2","title":"Observador de ordem 2","text":"<p>Agora, vamos considerar que o drone est\u00e1 em movimento mas com velocidade constante:</p> \\[ {\\color{var(--c1)}\\dot{z}} = \\text{cte} \\] <p>Nesse caso, temos um observador de ordem 2, j\u00e1 que a planta \u00e9 representada por uma equa\u00e7\u00e3o diferencial de segunda ordem, ou seja, duas equa\u00e7\u00f5es de primeira ordem encadeadas:</p> \\[ {\\color{var(--c1)}\\ddot{z}} = 0  \\qquad \\longrightarrow \\qquad \\left\\{ \\begin{array}{l}     {\\color{var(--c1)}\\dot{z}} = {\\color{var(--c1)}v_z} \\\\     {\\color{var(--c1)}\\dot{v}_z} = 0 \\end{array}{} \\right. \\] <p>Agora, se realimentarmos a diferen\u00e7a entre a posi\u00e7\u00e3o vertical medida \\(z_m\\) e a estimada \\(z\\) em ambas as equa\u00e7\u00f5es diferenciais, obtemos um sistema cuja estimativa converge exponencialmente para a medida, desde que os ganhos do observador \\(l_1\\) e \\(l_2\\) sejam positivos:</p> \\[ \\left\\{ \\begin{array}{l}     {\\color{var(--c1)}\\dot{z}} = {\\color{var(--c1)}v_z} + l_1 \\left( {\\color{var(--c3)}z_m} - {\\color{var(--c1)}z} \\right) \\\\     {\\color{var(--c1)}\\dot{v}_z} = 0 + l_2 \\left( {\\color{var(--c3)}z_m} - {\\color{var(--c1)}z} \\right) \\end{array}{} \\right. \\] <p></p> <p>Esse diagrama de blocos pode ser resumido em uma \u00fanica fun\u00e7\u00e3o de transfer\u00eancia:</p> <p></p> <p>Agora, a fun\u00e7\u00e3o de transfer\u00eancia \u00e9 id\u00eantica a de um filtro passa baixas de ordem dois, em que os ganhos \\(l_1\\) e \\(l_2\\) dependem da frequ\u00eancia de corte \\(\\omega_c\\) mas tamb\u00e9m do fator de amortecimento \\(\\zeta\\):</p> \\[ \\left\\{ \\begin{array}{l}         l_1 = 2 \\zeta \\omega_c \\\\         l_2 = \\omega_c^2 \\end{array} \\right. \\] <p>Sinais com frequ\u00eancias inferiores \u00e0 frequ\u00eancia de corte \\(\\omega_c\\) possuem ganho 1 (n\u00e3o s\u00e3o atenuados), enquanto que, sinais com frequ\u00eancias superiores \u00e0 frequ\u00eancia de corte \\(\\omega_c\\) possuem ganho 0 (s\u00e3o atenuados). Essa transi\u00e7\u00e3o \u00e9 cont\u00ednua, podendo ser muito mais acentuada em um observador de ordem 2 do que de ordem 1, devido a possibilidade de ajustar o fator de amortecimento \\(\\zeta\\):</p> <p></p> <p>Quanto menor for o fator de amortecimento \\(\\zeta\\), mais acentuada ser\u00e1 esta transi\u00e7\u00e3o. No entanto, quando \\(\\zeta &lt; \\frac{\\sqrt{2}}{2}\\), come\u00e7a a haver um aumento do ganho para frequ\u00eancias pr\u00f3ximas \u00e0 frequ\u00eancia de corte, fen\u00f4meno conhecido como ``resson\u00e2ncia'':</p> <p></p> <p>Queremos que a curva seja o mais acentuada poss\u00edvel por\u00e9m sem gerar resson\u00e2ncia. \u00c9 comum fixarmos o valor de \\(\\zeta\\) em \\(\\frac{\\sqrt{2}}{2}\\), que nos garante isso.</p> <p>Aplicando novamente o m\u00e9todo de Euler, chegamos nas seguintes equa\u00e7\u00f5es discretizadas:</p> \\[ \\left\\{ \\begin{array}{rll}     {\\color{var(--c1)}z[k+1]} =&amp; \\overbrace{{\\color{var(--c1)}z[k]} + {\\color{var(--c1)}v_z[k]} \\Delta t}^{\\text{Predi\u00e7\u00e3o}} &amp;+  \\quad \\overbrace{l_1 \\Delta t \\left[ {\\color{var(--c3)}z_m[k]} - {\\color{var(--c1)}z[k]} \\right]}^{\\text{Corre\u00e7\u00e3o}} \\\\     {\\color{var(--c1)}v_z[k+1]} =&amp; \\underbrace{{\\color{var(--c1)}v_z[k]}\\qquad\\qquad}_{\\text{Predi\u00e7\u00e3o}} &amp;+  \\quad \\underbrace{l_2 \\Delta t \\left[ {\\color{var(--c3)}z_m[k]} - {\\color{var(--c1)}z[k]} \\right]}_{\\text{Corre\u00e7\u00e3o}} \\end{array} \\right. \\] <p>Que podem ser divididas em duas etapas, uma de predi\u00e7\u00e3o e outra de corre\u00e7\u00e3o:</p> \\[ \\begin{align}     \\text{Predi\u00e7\u00e3o:} &amp;\\quad      \\left\\{     \\begin{array}{l}         {\\color{var(--c1)}z[k+1]} = {\\color{var(--c1)}z[k]} + {\\color{var(--c1)}v_z[k]} \\Delta t \\\\         {\\color{var(--c1)}v_z[k+1]} = {\\color{var(--c1)}v_z[k]}     \\end{array}     \\right.  \\\\ \\\\     \\text{Corre\u00e7\u00e3o:} &amp;\\quad      \\left\\{     \\begin{array}{l}         {\\color{var(--c1)}z[k+1]} = {\\color{var(--c1)}z[k+1]} + l_1 \\Delta t \\left({\\color{var(--c3)}z_m[k]} - {\\color{var(--c1)}z[k+1]}\\right) \\\\         {\\color{var(--c1)}v_z[k+1]} = {\\color{var(--c1)}v_z[k+1]} + l_2 \\Delta t \\left({\\color{var(--c3)}z_m[k]} - {\\color{var(--c1)}z[k+1]}\\right)     \\end{array}     \\right. \\end{align} \\] <p>Modifique sua fun\u00e7\u00e3o <code>verticalEstimator()</code> para que a dist\u00e2ncia vertical \\(z\\) e velocidade vertical \\(v_z\\) sejam estimados por um observador de ordem 2 com as etapas de predi\u00e7\u00e3o e corre\u00e7\u00e3o(1).</p> <ol> <li>Na etapa de corre\u00e7\u00e3o, primeiro n\u00f3s corrigimos o valor de \\(v_z\\) e depois de \\(z\\) para garantir que o valor utilizado de \\(z\\) no c\u00e1culo da corre\u00e7\u00e3o seja o mesmo em ambas as equa\u00e7\u00f5es.</li> </ol> <pre><code>// Estimate vertical position/velocity from range sensor\nvoid verticalEstimator()\n{\n    // Estimator parameters\n    static const float wc = \n    static const float zeta = \n    static const float l1 = \n    static const float l2 = \n\n    // Measured distante from range sensor\n    float z_m = \n\n    // Prediction step (model)\n    z = \n    vz =\n\n    // Correction step (measurement)\n    vz =\n    z = \n}\n</code></pre> <p>Carregue esse programa no drone e utilize o Crazyflie Client para verificar como est\u00e1 sua nova estimativa.</p> <p>Resultado esperado</p> <p>Sua estimativa deve estar muito melhor, filtrando ru\u00eddos e respondendo mais r\u00e1pido a varia\u00e7\u00f5es na velocidade. Al\u00e9m disso, agora estamos estimando tamb\u00e9m a velocidade vertical, que ser\u00e1 essencial ao controlador a ser implementado.</p>"},{"location":"pages/control/vertical/estimator/vertical_estimator/#observador-de-ordem-2-com-entrada","title":"Observador de ordem 2 (com entrada)","text":"<p>Por fim, vamos considerar que a acelera\u00e7\u00e3o do drone, em vez de ser nula, depende das for\u00e7as atuantes \u2014 o peso e o empuxo gerado pelos motores:</p> \\[ {\\color{var(--c1)}\\ddot{z}} = - g + \\frac{{\\color{var(--c2)}f_t}}{m} \\] <p>O observador permanece de ordem 2, mas inclui a entrada de controle:</p> \\[ \\left\\{ \\begin{array}{l}     {\\color{var(--c1)}\\dot{z}} = {\\color{var(--c1)}v_z} \\\\     {\\color{var(--c1)}\\dot{v}_z} =  - g + \\dfrac{{\\color{var(--c2)}f_t}}{m} \\end{array}{} \\right. \\] <p>Isso significa que agora sua din\u00e2mica \u00e9 uma c\u00f3pia fiel da planta, conforme pode ser verificado no diagrama de blocos abaixo:</p> <p></p> <p>As etapas depredi\u00e7\u00e3o e e corre\u00e7\u00e3o s\u00e3o quase id\u00eanticas, com uma leve altera\u00e7\u00e3o (apenas na predi\u00e7\u00e3o da velocidade):</p> \\[ \\begin{align}     \\text{Predi\u00e7\u00e3o:} &amp;\\quad      \\left\\{     \\begin{array}{l}         {\\color{var(--c1)}z[k+1]} = {\\color{var(--c1)}z[k]} + {\\color{var(--c1)}v_z[k]} \\Delta t \\\\         {\\color{var(--c1)}v_z[k+1]} = {\\color{var(--c1)}v_z[k]} + \\left( - g + \\dfrac{{\\color{var(--c2)}f_t[k]}}{m} \\right)  \\Delta t     \\end{array}     \\right.  \\\\ \\\\     \\text{Corre\u00e7\u00e3o:} &amp;\\quad      \\left\\{     \\begin{array}{l}         {\\color{var(--c1)}z[k+1]} = {\\color{var(--c1)}z[k+1]} + l_1 \\Delta t \\left({\\color{var(--c3)}z_m[k]} - {\\color{var(--c1)}z[k+1]}\\right) \\\\         {\\color{var(--c1)}v_z[k+1]} = {\\color{var(--c1)}v_z[k+1]} + l_2 \\Delta t \\left({\\color{var(--c3)}z_m[k]} - {\\color{var(--c1)}z[k+1]}\\right)     \\end{array}     \\right. \\end{align} \\] <p>Modifique a etapa de predi\u00e7\u00e3o de \\(v_z\\) na sua fun\u00e7\u00e3o <code>verticalEstimator()</code> para que ela leve em considera\u00e7\u00e3o tamb\u00e9m as entradas do sistema.</p> <pre><code>// Estimate vertical position/velocity from range sensor\nvoid verticalEstimator()\n{\n    // Estimator parameters\n    static const float wc = \n    static const float zeta = \n    static const float l1 = \n    static const float l2 = \n\n    // Measured distante from range sensor\n    float z_m = \n\n    // Prediction step (model)\n    z = \n    vz =\n\n    // Correction step (measurement)\n    vz =\n    z = \n}\n</code></pre> <p>N\u00e3o \u00e9 poss\u00edvel testar essa \u00faltima vers\u00e3o segurando o drone com a m\u00e3o, pois a for\u00e7a normal exercida ao segur\u00e1-lo n\u00e3o est\u00e1 contemplada no modelo e resultaria em respostas inconsistentes. </p> <p>Ainda assim, se o seu observador de estados de ordem 2 sem entradas apresentou bons resultados, \u00e9 esperado que este, com entradas, tamb\u00e9m funcione corretamente.</p> <p>Guarde essa modifica\u00e7\u00e3o \u2014 ela ser\u00e1 essencial quando implementarmos o controlador vertical e finalmente colocarmos o drone para voar de forma aut\u00f4noma.</p>"},{"location":"pages/control/vertical/estimator/vertical_estimator/#validacao","title":"Valida\u00e7\u00e3o","text":""},{"location":"pages/fundamentals/aerodynamics/","title":"Aerodin\u00e2mica","text":"<p>Para conseguir controlar um drone, \u00e9 essencial primeiro entender a f\u00edsica por tr\u00e1s dele. Aqui, voc\u00ea vai aprender os conceitos b\u00e1sicos de aerodin\u00e2mica que explicam como o drone se mant\u00e9m no ar.</p>"},{"location":"pages/fundamentals/aerodynamics/#aerofolio","title":"Aerof\u00f3lio","text":"<p>O modelo matem\u00e1tico de um drone, qualquer que seja seu tipo, cont\u00e9m diversos par\u00e2metros aerodin\u00e2micos. No entanto, para obter o conhecimento necess\u00e1rio, come\u00e7aremos examinando as for\u00e7as aerodin\u00e2micas em um aerof\u00f3lio.</p>"},{"location":"pages/fundamentals/aerodynamics/#forcas-aerodinamicas","title":"For\u00e7as aerodin\u00e2micas","text":"<p>A figura abaixo mostra a sec\u00e7\u00e3o transversal de um aerof\u00f3lio, um corpo te\u00f3rico moldado para produzir sustenta\u00e7\u00e3o quando colocado em um fluxo de ar.</p> <p></p> <p>Apesar de um aerof\u00f3lio ser projetado para produzir uma for\u00e7a desejada de sustenta\u00e7\u00e3o \\({\\color{var(--c2)}f_l}\\) (perpendicular \u00e0 velocidade \\({\\color{var(--c1)}v}\\)), ele tamb\u00e9m produz uma for\u00e7a indesejada de arrasto \\({\\color{var(--c2)}f_d}\\) (paralela \u00e0 velocidade \\({\\color{var(--c1)}v}\\)): $$     {\\color{var(--c2)}f_l} = \\frac{1}{2} \\rho A C_l {\\color{var(--c1)}v}^2      \\qquad     {\\color{var(--c2)}f_d} = \\frac{1}{2} \\rho A C_d {\\color{var(--c1)}v}^2  $$</p> <p>Onde:</p> <ul> <li>\\(\\rho\\) - Densidade do ar (\\(kg/m^3\\))</li> <li>\\(A\\) - \u00c1rea de superf\u00edcie (\\(m^2\\))</li> <li>\\(C_l\\) - Coeficiente de sustenta\u00e7\u00e3o (adimensional)</li> <li>\\(C_d\\) - Coeficiente de arrasto (adimensional)</li> <li>\\({\\color{var(--c1)}v}\\) - Velocidade linear do aerof\u00f3lio (\\(m/s\\))</li> </ul>"},{"location":"pages/fundamentals/aerodynamics/#coeficientes-aerodinamicos","title":"Coeficientes aerodin\u00e2micos","text":"<p>Os coeficientes de sustenta\u00e7\u00e3o e arrasto n\u00e3o s\u00e3o constantes, eles variam conforme as seguintes condi\u00e7\u00f5es aerodin\u00e2micas:</p> <ul> <li>\u00c2ngulo de ataque (\\(\\alpha\\)), que \u00e9 o \u00e2ngulo que a linha m\u00e9dia do aerof\u00f3lio (tamb\u00e9m chamada de ``corda'') faz com o vetor velocidade</li> <li>N\u00famero de Reynolds (\\(\\frac{\\rho v D}{\\mu}\\)), que \u00e9 uma medida adimensional e define o regime de escoamento do ar (laminar ou turbulento)</li> <li>N\u00famero Mach (\\(\\frac{\\color{var(--c1)}v}{v_s}\\)), que \u00e9 a raz\u00e3o entre a velocidade e a velocidade do som e define o regime de velocidade (subs\u00f4nica, supers\u00f4nica e hipers\u00f4nica)</li> </ul> <p>Para aerof\u00f3lios que se movem a velocidades subs\u00f4nicas (\\({\\color{var(--c1)}v}&lt;1.000km/h\\)), apenas o \u00e2ngulo de ataque \\(\\alpha\\), representado na figura abaixo, acaba apresentando uma influ\u00eancia significativa.</p> <p></p> <p>H\u00e1 diversos perfils diferentes para um aerfof\u00f3lio. Um bastante conhecido e utilizado \u00e9 o perfil Clark Y, cujos coeficientes de arrasto e sustenta\u00e7\u00e3o em fun\u00e7\u00e3o do \u00e2ngulo de ataque s\u00e3o bem conhecidos e dados(1) pelo gr\u00e1fico abaixo.</p> <ol> <li>Assumindo que o n\u00famero de Reynolds e o n\u00famero Mach permane\u00e7am dentro de uma determinada faixa de valores.</li> </ol> <p></p> <p>Enquanto o coeficiente de arrasto s\u00f3 aumenta com o \u00e2ngulo de ataque, o coeficiente de sustenta\u00e7\u00e3o tem um ponto m\u00e1ximo (\\(\\alpha=18^{\\circ}\\)). Esse ponto \u00e9 conhecido como \"estol\" ou simplesmente \"perda de sustenta\u00e7\u00e3o\", e ele ocorre quando o fluxo de ar descola da asa (deixa de seguir o contorno superior da asa gerando uma turbul\u00eancia). Note que o coeficiente de sustenta\u00e7\u00e3o \u00e9 nulo com uma leve inclina\u00e7\u00e3o negativa (\\(\\alpha=-5^{\\circ}\\)), e negativo abaixo disso.</p> <p>Exerc\u00edcio 1</p> <p>Para consolidar esses conceitos, considere um drone de asas fixas (asa voadora) em cruzeiro, isto \u00e9, voando no plano com velocidade constante e as seguintes caracter\u00edsticas:</p> <ul> <li>Massa de \\(40g\\) e comprimento de \\(10cm\\)</li> <li>Asas perfil Clark Y com \\(10cm\\) de envergadura</li> <li>Propulsores com \\(60\\%\\) de efici\u00eancia </li> <li>Bateria de \\(3,7V\\) e \\(350mAh\\)</li> <li>Adote \\(g = 9,81\\text{m/s}^2\\) e \\(\\rho = 1,225\\text{kg/m}^3\\)</li> </ul> a) Desenhe o diagrama de corpo livre das for\u00e7as que atuam nesse drone b) Determine a \u00e1rea total das asas do drone assumindo que seu corpo \u00e9 triangular \\[ \\begin{align*}     A &amp;= \\frac{10 \\cdot 10}{2} \\\\     A &amp;= 50 \\text{cm}^2 \\end{align*} \\] c) Determine os coeficientes de arrasto e sustenta\u00e7\u00e3o das asas do drone \\[ \\begin{align*}     C_l &amp;= 0,35 \\\\     C_d &amp;= 0,02 \\end{align*} \\] d) Determine a velocidade do drone \\[ \\begin{align*}     \\sum f_y &amp;= 0 \\\\     f_l - f_p &amp;= 0 \\\\     \\frac{1}{2} \\rho A C_l v^2 - mg &amp;= 0 \\\\     v &amp;= \\sqrt{\\frac{2mg}{\\rho AC_l}} \\\\     v &amp;= \\sqrt{\\frac{2 \\cdot 0,04 \\cdot 9,81}{1,225 \\cdot 50 \\times 10^{-4} \\cdot 0,35}} \\\\     v &amp;= 19,13 \\text{m/s} \\quad (\\approx 69\\text{km/h}) \\end{align*} \\] e) Determine a for\u00e7a de empuxo dos propulsores do drone \\[ \\begin{align*}     \\sum f_x &amp;= 0 \\\\     f_e - f_d &amp;= 0 \\\\     f_e - \\frac{1}{2} \\rho A C_d v^2  &amp;= 0 \\\\     f_e &amp;= \\frac{1}{2} \\rho A C_d v^2 \\\\     f_e &amp;= \\frac{1}{2} 1,225 \\cdot 50 \\times 10^{-4} \\cdot 0,02 \\cdot 19,13^2 \\\\     f_e &amp;= 0,0224 \\text{N} \\end{align*} \\] f) Determine o consumo energ\u00e9tico do drone \\[ \\begin{align*}     P_m &amp;= f_e v \\\\     P_m &amp;= 0,0224 \\cdot 19,13 \\\\     P_m &amp;= 0,429 \\text{W} \\end{align*} \\] \\[ \\begin{align*}     \\eta &amp;= \\frac{P_m}{P_e} \\\\     P_e &amp;= \\frac{P_m}{\\eta} \\\\     P_e &amp;= \\frac{0,429}{0,6} \\\\     P_e &amp;= 0,715 \\text{W} \\end{align*} \\] g) Determine quanto tempo que o drone consegue permanecer no ar \\[ \\begin{align*}     E &amp;= P_e \\Delta t \\\\     e_s i_s &amp;= P_e \\Delta t \\\\     \\Delta t &amp;= \\frac{e_s i_s}{P_e} \\\\     \\Delta t &amp;= \\frac{3,7 \\cdot ( 0,35 \\cdot 3600)}{0,715} \\\\     \\Delta t &amp;= 6.519 \\text{s} \\quad (\\approx 1\\text{h}49\\text{min}) \\end{align*} \\]"},{"location":"pages/fundamentals/aerodynamics/#helice","title":"H\u00e9lice","text":"<p>Uma h\u00e9lice \u00e9 composta por \\(n\\) p\u00e1s, onde cada p\u00e1 pode ser interpretada como um aerof\u00f3lio.</p>"},{"location":"pages/fundamentals/aerodynamics/#forcas-e-torques-aerodinamicos","title":"For\u00e7as e torques aerodin\u00e2micos","text":"<p>Quando a h\u00e9lice rotaciona, surgem for\u00e7as de sustenta\u00e7\u00e3o e arrasto em cada uma de suas p\u00e1s, conforme a figura abaixo.</p> <p></p> <p>Onde:</p> <ul> <li>\\(d\\) - Dist\u00e2ncia do centro de press\u00e3o ao eixo de rota\u00e7\u00e3o (\\(m\\))</li> <li>\\({\\color{var(--c1)}\\omega}\\) - Velocidade angular da h\u00e9lice (\\(rad/s\\))</li> </ul> <p>Exerc\u00edcio 2</p> <p>Determine as for\u00e7as de sustenta\u00e7\u00e3o \\({\\color{var(--c2)}f_l}\\) e arrasto \\({\\color{var(--c2)}f_d}\\) nas p\u00e1s da h\u00e9lice em fun\u00e7\u00e3o de sua velocidade angular \\({\\color{var(--c1)}\\omega}\\)</p> Resposta \\[ \\begin{align*}     f_l &amp;= \\frac{1}{2} \\rho A C_l v^2 \\\\      f_l &amp;= \\frac{1}{2} \\rho A C_l (\\omega d )^2 \\\\     f_l &amp;= \\frac{1}{2} \\rho A C_l d^2 \\omega^2  \\end{align*} \\] \\[ \\begin{align*}     f_d &amp;= \\frac{1}{2} \\rho A C_d v^2 \\\\      f_d &amp;= \\frac{1}{2} \\rho A C_d (\\omega d )^2 \\\\     f_d &amp;= \\frac{1}{2} \\rho A C_d d^2 \\omega^2  \\end{align*} \\] <p>As for\u00e7as de sustenta\u00e7\u00e3o e arrasto em cada uma das p\u00e1s podem ser representadas por uma \u00fanica for\u00e7a de sustenta\u00e7\u00e3o e torque de arrasto da h\u00e9lice, conforme a figura abaixo.</p> <p></p> <p>Exerc\u00edcio 3</p> <p>Determine a for\u00e7a de sustenta\u00e7\u00e3o \\({\\color{var(--c2)}f}\\) e torque de arrasto \\({\\color{var(--c2)}\\tau}\\) da h\u00e9lice</p> Resposta \\[ \\begin{align*}     f &amp;= 2 f_l \\\\     f &amp;= 2 \\left( \\frac{1}{2} \\rho A C_l d^2 \\omega^2  \\right) \\\\     f &amp;= \\rho A C_l d^2 \\omega^2  \\end{align*} \\] \\[ \\begin{align*}     \\tau &amp;= 2 \\left( d f_d \\right) \\\\      \\tau &amp;= 2 \\left( d \\left( \\frac{1}{2} \\rho A C_d d^2 \\omega^2 \\right) \\right) \\\\     \\tau &amp;= \\rho A C_d d^3 \\omega^2  \\end{align*} \\] <p>Como todos os par\u00e2metros s\u00e3o constantes e apenas a velocidade angular \\({\\color{var(--c1)}\\omega}\\) varia, a for\u00e7a de sustenta\u00e7\u00e3o e torque de arrasto de uma h\u00e9lice podem ser simplificados por:</p> \\[ {\\color{var(--c2)}f} = \\underbrace{\\rho A C_l d^2}_{k_l} {\\color{var(--c1)}\\omega}^2  \\qquad {\\color{var(--c2)}\\tau} = \\underbrace{\\rho A C_d d^3}_{k_d} {\\color{var(--c1)}\\omega}^2  \\] <p>Onde:</p> <ul> <li>\\(k_l\\) - Coeficiente de sustenta\u00e7\u00e3o da h\u00e9lice (\\(N.s^2/rad^2\\))</li> <li>\\(k_d\\) - Coeficiente de arrasto da h\u00e9lice (\\(N.m.s^2/rad^2\\))</li> </ul>"},{"location":"pages/fundamentals/aerodynamics/#constantes-aerodinamicas","title":"Constantes aerodin\u00e2micas","text":"<p>Ou seja, apenas dois par\u00e2metros definem a for\u00e7a e o torque que uma h\u00e9lice produz, que dependem do quadrado de sua velocidade angular:</p> <p></p> \\[ {\\color{var(--c2)}f} = k_l {\\color{var(--c1)}\\omega}^2  \\qquad {\\color{var(--c2)}\\tau} = k_d {\\color{var(--c1)}\\omega}^2  \\] <p>Exerc\u00edcio 4</p> <p>Com o aux\u00edlio de uma r\u00e9gua, estime(1) as constantes aerodin\u00e2micas das h\u00e9lices do Bitcraze Crazyflie e anote elas abaixo. Assuma que a h\u00e9lice pode ser aproximada a um perfil Clark Y com \u00e2ngulo de ataque \\(\\alpha = 5^\\circ\\), sendo a constante de sustenta\u00e7\u00e3o igual, por\u00e9m a constante de arrasto 10x maior(2).</p> <ol> <li>Estamos preocupados apenas com a ordem de grandeza dos resultados.</li> <li>Devido \u00e0 turbul\u00eancia gerada pela h\u00e9lice.</li> </ol> Resposta \\[ \\left\\{     \\begin{align*}         \\rho &amp;= 1,225 kg/m^3 \\\\         A &amp;= 2,5 \\cdot 0,5 = 1,25 cm^2 \\\\         d &amp;= 1,5 cm \\\\         C_l &amp;= 0,7 \\\\         C_d &amp;= 0,04 \\cdot 10 = 0,4      \\end{align*} \\right. \\] \\[ \\begin{align*}     k_l &amp;= \\rho A C_l d^2\\\\     k_l &amp;= 1,225 \\cdot (1,25 \\cdot 10^{-4}) \\cdot 0,7 \\cdot (1,5 \\times 10^{-2})^2 \\\\     k_l &amp;= 2,41 \\times10^{-8} \\text{N.s}^2\\text{/rad}^2 \\end{align*} \\] \\[ \\begin{align*}     k_d &amp;= \\rho A C_d d^3 \\\\     k_d &amp;= 1,225 \\cdot (1,25 \\cdot 10^{-4}) \\cdot 0,4 \\cdot (1,5 \\times 10^{-2})^3 \\\\     k_d &amp;= 2,07 \\times10^{-10} \\text{N.m.s}^2\\text{/rad}^2 \\end{align*} \\] <p>Esses dois par\u00e2metros ser\u00e3o determinados experimentalmente (\\(k_l\\) e \\(k_d\\)), e voc\u00ea ver\u00e1 que a chegar\u00e1 em valores muito pr\u00f3ximos aos estimados acima.</p> <p>Exerc\u00edcio 5</p> <p>Para consolidar esses conceitos, considere um drone multi-rotor (quadricoptero) pairando no ar, isto \u00e9, parado no espa\u00e7o com as seguintes caracter\u00edsticas:</p> <ul> <li>Massa de \\(40g\\)</li> <li>H\u00e9lices com constante de sustenta\u00e7\u00e3o de \\(2,0\\times10^{-8} \\text{N}.\\text{s}^2/\\text{rad}^2\\) e constante de arrasto de \\(2,0\\times10^{-10} \\text{N}.\\text{m}.\\text{s}^2\\text{/rad}^2\\)</li> <li>Motores el\u00e9tricos com \\(90\\%\\) de efici\u00eancia </li> <li>Bateria de \\(3,7V\\) e \\(350mAh\\)</li> <li>Adote \\(g = 9,81\\text{m/s}^2\\) e \\(\\rho = 1,225\\text{kg/m}^3\\)</li> </ul> a) Desenhe o diagrama de corpo livre das for\u00e7as que atuam nesse drone b) Determine a velocidade angular das h\u00e9lices do drone \\[ \\begin{align*}     \\sum f_y &amp;= 0 \\\\     4 f - f_w &amp;= 0 \\\\     4 k_l \\omega^2 - mg &amp;= 0 \\\\     \\omega &amp;= \\sqrt{\\frac{mg}{4 k_l}} \\\\     \\omega &amp;= \\sqrt{\\frac{0,04 \\cdot 9,81}{4 \\cdot (2,0\\times10^{-8})}} \\\\     \\omega &amp;= 2.215 \\text{rad/s} \\quad (\\approx 21.149\\text{rpm}) \\end{align*} \\] c) Determine o torque dos motores do drone \\[ \\begin{align*}     \\sum \\tau &amp;= 0 \\\\     \\tau_m - \\tau_d &amp;= 0 \\\\     \\tau_m - k_d \\omega^2 &amp;= 0 \\\\     \\tau_m &amp;= k_d \\omega^2 \\\\     \\tau_m &amp;= 2,0 \\times 10 ^{-10} \\cdot 2215^2 \\\\     \\tau_m &amp;= 0,000981 \\text{N.m} \\\\ \\end{align*} \\] d) Determine o consumo energ\u00e9tico do drone \\[ \\begin{align*}     P_m &amp;= 4 \\tau_m \\omega \\\\     P_m &amp;= 4 \\cdot 0,000981 \\cdot 2215 \\\\     P_m &amp;= 8,69 \\text{W} \\end{align*}    \\] \\[ \\begin{align*}     \\eta &amp;= \\frac{P_m}{P_e} \\\\     P_e &amp;= \\frac{P_m}{\\eta} \\\\     P_e &amp;= \\frac{8,69}{0,9} \\\\     P_e &amp;= 9,66 \\text{W} \\end{align*} \\] e) Determine quanto tempo que o drone consegue permanecer no ar \\[ \\begin{align*}     E &amp;= P_e \\Delta t \\\\     e_s i_s &amp;= P_e \\Delta t \\\\     \\Delta t &amp;= \\frac{e_s i_s}{P_e} \\\\     \\Delta t &amp;= \\frac{3,7 (\\cdot 0,35 \\cdot 3600)}{9,66} \\\\     \\Delta t &amp;= 483\\text{s} \\quad (\\approx 8\\text{min}) \\end{align*} \\] <p>Compare este resultado, do drone multi rotor, com o anterior, do drone de asas fixa. Note como o drone de asa fixa consegue permanecer muito mais tempo no ar (&gt;10x), com a desvatagem de n\u00e3o conseguir permanecer parado e nem decolar/pousar na vertical como um drone multi-rotor.</p>"},{"location":"pages/fundamentals/inertia/","title":"In\u00e9rcia","text":"<p>Todo corpo resiste a mudan\u00e7as em seu estado de movimento \u2014 essa resist\u00eancia \u00e9 o que chamamos de in\u00e9rcia.</p> <p>No caso de um drone, que est\u00e1 livre para se mover e girar no espa\u00e7o, a in\u00e9rcia se manifesta de duas formas principais, e ambas s\u00e3o fundamentais para entender como ele responde aos comandos de controle:</p> <ul> <li>Massa \u2014 representa a resist\u00eancia a movimentos lineares (como subir/descer, avan\u00e7ar/recuar ou deslocar-se lateralmente). \u00c9 a chamada in\u00e9rcia translacional.</li> <li>Momento de in\u00e9rcia \u2014 representa a resist\u00eancia a movimentos angulares (como rolar, inclinar ou guinar). \u00c9 a chamada in\u00e9rcia rotacional.</li> </ul> <p>Controlar bem um drone exige compreender essas duas formas de in\u00e9rcia \u2014 e como elas influenciam as acelera\u00e7\u00f5es que conseguimos impor a ele.</p>"},{"location":"pages/fundamentals/inertia/#massa","title":"Massa","text":"<p>A massa representa o quanto o drone resiste a mudan\u00e7as na velocidade ao longo de um eixo de transla\u00e7\u00e3o. Ela depende da quantidade de mat\u00e9ria e \u00e9 a mesma em qualquer dire\u00e7\u00e3o. Ou seja, n\u00e3o importa se o movimento \u00e9 para cima, para frente ou para o lado: temos apenas uma \u00fanica massa.</p> <p></p> <p>Exerc\u00edcio 1</p> <p>Podemos calcular a massa do drone somando a massa de seus componentes:</p> <ul> <li>O drone que j\u00e1 considera bateria, PCB, motores, h\u00e9lices, etc.</li> <li>O m\u00f3dulo de expans\u00e3o que \u00e9 acoplado embaixo</li> </ul> <p>Determine a massa total do drone somando a massa de seus componentes. Elas podem ser obtidas nas especifica\u00e7\u00f5es t\u00e9cnicas no site da Bitcraze (cujos links foram disponibilizados acima).</p> Resposta \\[ \\begin{align*}     m &amp;= m_{cf} + m_{fd} \\\\     m &amp;= 37 + 1,6 \\\\     m &amp;= 38,6 g \\end{align*} \\]"},{"location":"pages/fundamentals/inertia/#momento-de-inercia","title":"Momento de In\u00e9rcia","text":"<p>O momento de in\u00e9rcia representa o quanto o drone resiste a mudan\u00e7as na velocidade angular em torno de um eixo de rota\u00e7\u00e3o. Ao contr\u00e1rio da massa, ele depende n\u00e3o apenas da quantidade de mat\u00e9ria, mas tamb\u00e9m de como ela est\u00e1 distribu\u00edda em rela\u00e7\u00e3o ao eixo de rota\u00e7\u00e3o. Como o drone pode girar em torno de tr\u00eas eixos (rolagem, inclina\u00e7\u00e3o e guinagem), ele possui tr\u00eas momentos de in\u00e9rcia: um para cada eixo.</p> <p></p> <p>Exerc\u00edcio 2</p> <p>Podemos calcular os momentos de in\u00e9rcia do drone considerando um modelo mais simples<sup>1</sup>:</p> <ul> <li>A bateria como um paralelep\u00edpedo</li> <li>Os motores com  h\u00e9lices e suportes como massas puntiformes</li> </ul> <p>Determine a momento de in\u00e9rcia total do drone em torno de cada um de seus eixos. As dimens\u00f5es necess\u00e1rias podem ser obtidas com o aux\u00edlio de um paqu\u00edmetro, j\u00e1 as massas podem ser obtidas nas especifica\u00e7\u00f5es t\u00e9cnicas no site da Bitcraze (cujos links foram disponibilizados acima).</p> Resposta <p>A bateria possui \\(9,10 \\, g\\) de massa e dimens\u00f5es \\(3,3 \\times 2,0 \\times 0,8 \\, cm\\): </p> \\[ \\left\\{ \\begin{align*}     m_b &amp;= 9,10 \\, g\\\\     a &amp;= 3,3 \\, cm\\\\     b &amp;= 2,0 \\, cm\\\\     c &amp;= 0,8 \\, cm\\\\ \\end{align*} \\right. \\] <p>Assim, usando uma tabela de momentos de in\u00e9rcia de um paralelep\u00edpedo temos que:</p> <p></p> \\[ \\begin{align*}     I_{b_{xx}} &amp;= \\frac{m_b}{12} (b^2 + c^2) &amp; \\quad I_{b_{yy}} &amp;= \\frac{m_b}{12} (a^2 + c^2) &amp; \\quad I_{b_{zz}} &amp;= \\frac{m_b}{12} (a^2 + b^2) \\\\     I_{b_{xx}} &amp;= \\frac{9,1}{12} (2,0^2 + 0,8^2) &amp; \\quad I_{b_{yy}} &amp;= \\frac{9,1}{12} (3,3^2 + 0,8^2) &amp; \\quad I_{b_{zz}} &amp;= \\frac{9,1}{12} (3,3^2 + 2,0^2) \\\\     I_{b_{xx}} &amp;= 3,52 \\, g.cm^2 &amp; \\quad I_{b_{yy}} &amp;= 8,74 \\, g.cm^2 &amp; \\quad I_{b_{zz}} &amp;= 12,29 \\, g.cm^2 \\\\ \\end{align*} \\] <p>Os motores (\\(2,30 \\, g\\)), com h\u00e9lices (\\(1,34 \\, g\\)) e suportes (\\(0,33 \\, g\\)), possuem \\(3,97 \\, g\\) de massa total e est\u00e3o a \\(10 \\, cm\\) de dist\u00e2ncia na diagonal: </p> \\[ \\left\\{ \\begin{align*}     m_m &amp;= 3,97 \\, g\\\\     l_x &amp;= 5 \\frac{\\sqrt{2}}{2} \\, cm \\\\     l_y &amp;= 5 \\frac{\\sqrt{2}}{2} \\, cm \\\\     l_z &amp;= 5 \\, cm\\\\ \\end{align*} \\right. \\] <p>Assim, considerando eles como massas puntiformes temos que:</p> <p></p> \\[ \\begin{align*}     I_{m_{xx}} &amp;= m_m l_x^2 &amp; \\quad I_{m_{yy}} &amp;= m_m l_y^2 &amp; \\quad I_{m_{zz}} &amp;= m_m l_z^2 \\\\     I_{m_{xx}} &amp;= 3,97 \\cdot {\\left( 5,0 \\frac{\\sqrt{2}}{2} \\right)}^2 &amp; \\quad I_{m_{yy}} &amp;= 3,97 \\cdot {\\left( 5,0 \\frac{\\sqrt{2}}{2} \\right)}^2 &amp; \\quad I_{m_{zz}} &amp;= 3,97 \\cdot 5,0^2 \\\\     I_{m_{xx}} &amp;= 49,62 \\, g.cm^2 &amp; \\quad I_{m_{yy}} &amp;= 49,62 \\, g.cm^2 &amp; \\quad I_{m_{zz}} &amp;= 99,25 \\, g.cm^2 \\\\ \\end{align*} \\] <p>Dessa forma, os momentos de in\u00e9rcia totais s\u00e3o dados por:</p> \\[ \\begin{align*}     I_{xx} &amp;= I_{b_{xx}} + 4 I_{m_{xx}} &amp; \\quad I_{yy} &amp;= I_{b_{yy}} + 4 I_{m_{yy}} &amp; \\quad I_{zz} &amp;= I_{b_{zz}} + 4 I_{m_{zz}} \\\\     I_{xx} &amp;= 3,52 + 4 \\cdot 49,62 &amp; \\quad I_{yy} &amp;= 8,74 + 4 \\cdot 49,62 &amp; \\quad I_{zz} &amp;= 12,29 + 4 \\cdot 99,25 \\\\     I_{xx} &amp;= 202,02 \\, g.cm^2 &amp; \\quad I_{yy} &amp;= 207,24 \\, g.cm^2 &amp; \\quad I_{zz} &amp;= 408,29 \\, g.cm^2 \\\\ \\end{align*} \\] <p>Ou, de forma aproximada, e no S.I. (Sistema Internacional de Unidades):</p> \\[ \\begin{align*}     I_{xx} &amp;= 2 \\cdot 10^{-5} \\, kg.m^2 &amp; \\quad I_{yy} &amp;= 2 \\cdot 10^{-5} \\, kg.m^2 &amp; \\quad I_{zz} &amp;= 4 \\cdot 10^{-5} \\, kg.m^2 \\\\ \\end{align*} \\] <p>\u200b</p> <ol> <li> <p>Estamos desprezando a estrutura de PCB do drone, j\u00e1 que sua massa \u00e9 pequena comparada \u00e0 da bateria e dos motores, al\u00e9m de estar concentrada pr\u00f3xima ao centro de massa.\u00a0\u21a9</p> </li> </ol>"},{"location":"pages/fundamentals/mixer/","title":"Mixer","text":"<p>O voo de um drone depende diretamente das for\u00e7as e torques gerados pelos motores. Aqui, voc\u00ea vai entender como esses efeitos se combinam para movimentar o quadric\u00f3ptero no espa\u00e7o.</p>"},{"location":"pages/fundamentals/mixer/#movimentos-basicos-de-um-quadricoptero","title":"Movimentos b\u00e1sicos de um quadric\u00f3ptero","text":"<p>Um quadric\u00f3ptero possui quatro h\u00e9lices que, uma vez em movimento com velocidades angulares \\({\\color{var(--c1)}\\omega_1}\\), \\({\\color{var(--c1)}\\omega_2}\\), \\({\\color{var(--c1)}\\omega_3}\\) e \\({\\color{var(--c1)}\\omega_4}\\), produzem quatro for\u00e7as de sustenta\u00e7\u00e3o \\({\\color{var(--c2)}f_1}\\), \\({\\color{var(--c2)}f_2}\\), \\({\\color{var(--c2)}f_3}\\) e \\({\\color{var(--c2)}f_4}\\) e quatro torques de arrasto \\({\\color{var(--c2)}\\tau_1}\\), \\({\\color{var(--c2)}\\tau_2}\\), \\({\\color{var(--c2)}\\tau_3}\\) e \\({\\color{var(--c2)}\\tau_4}\\), conforme a figura abaixo.</p> <p></p> <p>Para um quadric\u00f3ptero se movimentar verticalmente, basta variar as velocidades angulares das quatro h\u00e9lices simultaneamente, conforme a figura abaixo.</p> <p>Enquanto que, para um quadric\u00f3ptero rotacionar em torno de seus eixos, basta variar as velocidades angulares de 2 h\u00e9lices simultaneamente, conforme a figura abaixo.</p> <p>Exerc\u00edcio 1</p> <p>Sobre os movimentos de um quadric\u00f3ptero, determine as respostas a seguir. </p> a) Quantas formas diferentes \u00e9 poss\u00edvel transladar um quadric\u00f3ptero <p>3 (ao longo dos eixos \\(x\\), \\(y\\) e \\(z\\))</p> b) Quantas formas diferentes \u00e9 poss\u00edvel rotacionar um quadric\u00f3ptero <p>3 (em torno dos eixos \\(x\\), \\(y\\) e \\(z\\)) </p> c) Quantos graus de liberdade possui um quadric\u00f3ptero <p>6 (3 de transla\u00e7\u00e3o + 3 de rota\u00e7\u00e3o) </p> d) Como o quadric\u00f3ptero realiza movimentos de transla\u00e7\u00e3o no plano (eixos \\(x\\) e \\(y\\)) <p>Atrav\u00e9s de uma composi\u00e7\u00e3o de movimentos de transla\u00e7\u00e3o (ao longo do eixo \\(z\\)) e rota\u00e7\u00e3o (em torno dos eixos \\(x\\) e \\(y\\)) </p>"},{"location":"pages/fundamentals/mixer/#transformacao-de-entradas","title":"Transforma\u00e7\u00e3o de entradas","text":"<p>As quatro for\u00e7as e quatro torques de cada uma das h\u00e9lices podem ser representadas por uma \u00fanica for\u00e7a de propuls\u00e3o total \\({\\color{var(--c2)}f_t}\\) e tr\u00eas torques \\({\\color{var(--c2)}\\tau_x}\\), \\({\\color{var(--c2)}\\tau_y}\\) e \\({\\color{var(--c2)}\\tau_z}\\), um em torno de cada eixo do quadric\u00f3ptero, conforme a figura abaixo.</p> <p></p> <p>Na sec\u00e7\u00e3o de aerodin\u00e2mica verificamos que as for\u00e7as e torques das h\u00e9lices s\u00e3o proporcionais ao quadrado de suas velocidades angulares:</p> \\[ \\left\\{ \\begin{array}{l}     {\\color{var(--c2)}f_i} = k_l {\\color{var(--c1)}\\omega_i}^2 \\\\    {\\color{var(--c2)}\\tau_i} = k_d {\\color{var(--c1)}\\omega_i}^2 \\\\ \\end{array} \\right. \\] <p>Isso significa que as quatro equa\u00e7\u00f5es determinadas anteriormente podem ser escritas no formato matricial:</p> \\[ \\begin{bmatrix}     {\\color{var(--c2)}f_t} \\\\     {\\color{var(--c2)}\\tau_x} \\\\     {\\color{var(--c2)}\\tau_y} \\\\     {\\color{var(--c2)}\\tau_z} \\end{bmatrix} = M  \\begin{bmatrix}     {\\color{var(--c1)}\\omega_1}^2 \\\\     {\\color{var(--c1)}\\omega_2}^2 \\\\     {\\color{var(--c1)}\\omega_3}^2 \\\\     {\\color{var(--c1)}\\omega_4}^2 \\end{bmatrix} \\] <p>Onde \\(M\\) \u00e9 uma matriz \\(4\\times4\\) que transforma as velocidades angulares das h\u00e9lices na for\u00e7a total e nos torques de um quadric\u00f3ptero.</p> <p>Exerc\u00edcio 2</p> <p>Determine a matriz \\(M\\) em fun\u00e7\u00e3o das constantes de sustenta\u00e7\u00e3o e arrasto da h\u00e9lice \\(k_l\\) e \\(k_d\\) e do comprimento \\(l\\). </p> Resposta \\[ M =  \\begin{bmatrix}      k_l &amp; k_l &amp; k_l &amp; k_l \\\\      -k_l l &amp; -k_l l &amp; k_l l &amp; k_l l \\\\      -k_l l &amp; k_l l &amp; k_l l &amp; -k_l l  \\\\      -k_d &amp; k_d &amp; -k_d &amp; k_d  \\end{bmatrix} \\] <p>Para obter as velocidades angulares das h\u00e9lices em fun\u00e7\u00e3o da for\u00e7a total e dos torques, basta multiplicar a equa\u00e7\u00e3o anterior pela matriz inversa \\(M^{-1}\\):</p> \\[ \\begin{bmatrix}     {\\color{var(--c1)}\\omega_1}^2 \\\\     {\\color{var(--c1)}\\omega_2}^2 \\\\     {\\color{var(--c1)}\\omega_3}^2 \\\\     {\\color{var(--c1)}\\omega_4}^2 \\end{bmatrix} = M^{-1}  \\begin{bmatrix}     {\\color{var(--c2)}f_t} \\\\     {\\color{var(--c2)}\\tau_x} \\\\     {\\color{var(--c2)}\\tau_y} \\\\     {\\color{var(--c2)}\\tau_z} \\end{bmatrix} \\] <p>Exerc\u00edcio 3</p> <p>Determine a matriz inversa \\(M^{-1}\\) (dica: utilize o Symbolic Math Toolbox do MATLAB).</p> Resposta \\[ M^{-1} =  \\begin{bmatrix}      \\frac{1}{4 k_l} &amp; - \\frac{1}{4 k_l l} &amp; - \\frac{1}{4 k_l l} &amp; - \\frac{1}{4 k_d}  \\\\      \\frac{1}{4 k_l} &amp; - \\frac{1}{4 k_l l} &amp; \\frac{1}{4 k_l l} &amp; \\frac{1}{4 k_d} \\\\      \\frac{1}{4 k_l} &amp; \\frac{1}{4 k_l l} &amp; \\frac{1}{4 k_l l} &amp; - \\frac{1}{4 k_d} \\\\      \\frac{1}{4 k_l} &amp; \\frac{1}{4 k_l l} &amp; - \\frac{1}{4 k_l l} &amp; \\frac{1}{4 k_d}  \\end{bmatrix} \\]"},{"location":"pages/identification/drag_constant/","title":"Identifica\u00e7\u00e3o da constante de arrasto","text":"<p>Nesta sec\u00e7\u00e3o, voc\u00ea ir\u00e1 determinar experimentalmente a constante de arrasto das h\u00e9lices \\(k_d\\).</p>"},{"location":"pages/identification/drag_constant/#fundamentos-teoricos","title":"Fundamentos te\u00f3ricos","text":"<p>As h\u00e9lices de um quadricoptero atuam como superf\u00edcies aerodin\u00e2micas, acelerando o fluxo de ar atrav\u00e9s delas. Isso consome energia das baterias e produz for\u00e7as de sustenta\u00e7\u00e3o e torques de arrasto no quadricoptero. J\u00e1 deduzimos que o torque de arrasto de uma h\u00e9lice \\(\\tau\\) \u00e9 proporcional \u00e0 velocidade angular da h\u00e9lice \\(\\omega\\) ao quadrado.</p> <p></p> \\[     \\tau = k_d \\omega^2 \\] <p>Onde:</p> <ul> <li>\\(k_d\\) - Constante de arrasto (\\(N.m.s^2\\))   </li> </ul>"},{"location":"pages/identification/drag_constant/#procedimento-experimental","title":"Procedimento experimental","text":"<p>Voc\u00ea vai medir o torque de arrasto \\(\\tau\\) das h\u00e9lices com um suporte(1) que restringe todos os graus de liberdade do drone deixando apenas o \u00e2ngulo de guinagem \\(\\psi\\) livre.</p> <ol> <li>Para prender o quadcoptero no suporte, voc\u00ea precisa encaix\u00e1-lo pela lateral e depois prender dois parafusos. </li> </ol> <p></p> <p>Sabendo o momento de in\u00e9rcia do drone \\(I_{zz}\\) e o \u00e2ngulo de guinagem ao longo do tempo \\(\\psi\\), \u00e9 poss\u00edvel determinar o torque de arrasto total das h\u00e9lices \\(\\tau_z\\) atrav\u00e9s de uma an\u00e1lise din\u00e2mica. Para realizar a leitura do \u00e2ngulo de guinagem ao longo do tempo, voc\u00ea deve filmar o procedimento no modo c\u00e2mera lenta de seu celular com um cron\u00f4metro no campo de vis\u00e3o.</p> <p></p> <p>Voc\u00ea deve carregar no drone um programa que faz com que as h\u00e9lices \\(1\\) e \\(3\\) rotacionem com velocidade angular de \\(1.000\\,\\text{rad/s}\\) e as h\u00e9lices \\(2\\) e \\(4\\) com \\(2.000\\,\\text{rad/s}\\). Como as h\u00e9lices \\(1\\) e \\(3\\) giram no sentido hor\u00e1rio e as h\u00e9lices \\(2\\) e \\(4\\) no anti-hor\u00e1rio, haver\u00e1 um torque resultante que far\u00e1 com que o drone rotacione no sentido anti-hor\u00e1rio. Para cada quarto de volta (\\(90^{\\circ}\\)), voc\u00ea dever\u00e1 anotar o tempo decorrido. Voc\u00ea dever\u00e1 realizar o experimento tr\u00eas vezes e tirar uma m\u00e9dia. Para facilitar o experimento, voc\u00ea pode ligar/desligar as h\u00e9lices com os bot\u00f5es <code>Take off</code> e <code>Land</code> do Command Based Flight Control atrav\u00e9s do CFClient.</p> <p></p> <p>Crie um arquivo chamado <code>drag_constant.c</code> dentro da pasta <code>src/identification</code> com o seguinte c\u00f3digo(1):</p> <ol> <li>N\u00e3o esque\u00e7a de atualizar os valores dos coeficientes dos motores \\(a_2\\) e \\(a_1\\) (linhas 8-9) estimados anteriormente.</li> </ol> drag_constant.c<pre><code>#include \"FreeRTOS.h\"      // FreeRTOS core definitions (needed for task handling and timing)\n#include \"task.h\"          // FreeRTOS task functions (e.g., vTaskDelay)\n#include \"supervisor.h\"    // Functions to check flight status (e.g., supervisorIsArmed)\n#include \"commander.h\"     // Access to commanded setpoints (e.g., commanderGetSetpoint)\n#include \"motors.h\"        // Low-level motor control interface (e.g., motorsSetRatio)\n\n// Motor coefficients of the quadratic model: PWM = a_2 * omega^2 + a_1 * omega\nconst float a_2 = 0.0f;\nconst float a_1 = 0.0f;\n\n// Global variables to store the desired setpoint, the current state (not used here),\n// and the computed PWM values for different motor speeds\nsetpoint_t setpoint;\nstate_t state;\nfloat pwm_1, pwm_2;\nfloat omega_1, omega_2; \n\n// Main application\nvoid appMain(void *param)\n{\n    // Infinite loop (runs forever)\n    while (true)\n    {\n        // Check if the drone is armed (i.e., ready to fly)\n        if (supervisorIsArmed())\n        {\n            // Fetch the latest setpoint from the commander\n            commanderGetSetpoint(&amp;setpoint, &amp;state);\n\n            if ((setpoint.position.z) &gt; 0)\n            {\n                // Set two different angular velocities for the motors\n                // Motors M1 and M3 will spin at 2000 rad/s\n                // Motors M2 and M4 will spin at 1000 rad/s\n                // This configuration induces pure yaw rotation (spinning in place)\n                omega_1 = 2000.0f;\n                omega_2 = 1000.0f;\n\n                // Convert angular velocities to PWM using the motor model\n                pwm_1 = a_2 * omega_1 * omega_1 + a_1 * omega_1;\n                pwm_2 = a_2 * omega_2 * omega_2 + a_1 * omega_2;\n            }\n            else\n            {\n                // If Z setpoint is not positive, apply minimal power to all motors (for idle spin)\n                pwm_1 = 0.1f;\n                pwm_2 = 0.1f;\n            }\n        }\n        else\n        {\n            // If not armed, stop all motors\n            pwm_1 = 0.0f;\n            pwm_2 = 0.0f;\n        }\n        // Apply PWM to motors:\n        // M1 and M3 get pwm_1 (corresponding to 2000 rad/s)\n        // M2 and M4 get pwm_2 (corresponding to 1000 rad/s)\n        // This asymmetric configuration results in yaw motion\n        motorsSetRatio(MOTOR_M1, pwm_1 * UINT16_MAX);\n        motorsSetRatio(MOTOR_M2, pwm_2 * UINT16_MAX);\n        motorsSetRatio(MOTOR_M3, pwm_1 * UINT16_MAX);\n        motorsSetRatio(MOTOR_M4, pwm_2 * UINT16_MAX);\n        // Wait for 100 milliseconds before the next iteration (10 Hz control loop)\n        vTaskDelay(pdMS_TO_TICKS(100));\n    }\n}\n</code></pre> <p>As etapas para coletar os dados s\u00e3o as seguintes:</p> <ol> <li>Garanta que a bateria do drone est\u00e1 carregada </li> <li>Prenda o drone no dispositivo e posicione um cron\u00f4metro ao seu lado</li> <li>Arme o drone apertando o bot\u00e3o <code>Arm</code> no CFClient</li> <li>Comece a filmar com seu celular no modo c\u00e2mera lenta</li> <li>Ligue os motores com o Command Based Flight Control do CFClient</li> <li>Espere o drone dar duas voltas e pare de filmar</li> </ol> <p>Ap\u00f3s o experimento, voc\u00ea dever\u00e1 coletar dados para preencher a tabela abaixo.</p> \\(\\psi \\, (^{\\circ})\\) \\(t_1 \\, (s)\\) \\(t_2 \\, (s)\\) \\(t_3 \\, (s)\\) \\(0\\) \\(90\\) \\(180\\) \\(270\\) \\(360\\) \\(450\\) \\(540\\) \\(630\\) \\(720\\)"},{"location":"pages/identification/drag_constant/#analise-de-dados","title":"An\u00e1lise de dados","text":"<p>Utilizando os dados coletados, voc\u00ea dever\u00e1 ajustar uma curva que correlacione o \u00e2ngulo de guinagem \\(\\psi\\) com o tempo \\(t\\) da h\u00e9lice (note que voc\u00ea precisa converter o \u00e2ngulo de guinagem de \\(^{\\circ}\\) para \\(rad\\)).</p> <p></p> <p>Aplicando um torque constante, o deslocamento angular em fun\u00e7\u00e3o do tempo \u00e9 dado por:</p> <p>$$     \\psi = \\frac{\\tau_z}{2 I_{zz}} t^2 $$ J\u00e1 deduzimos que esse torque \u00e9 dado pela soma dos torques de arrasto de cada h\u00e9lice \\(\\tau_i\\), que por sua vez s\u00e3o proporcionais \u00e0s velocidades angulares das h\u00e9lices \\(\\omega_i\\) ao quadrado:</p> \\[     \\tau_z = -k_d \\omega_1^2 + k_d \\omega_2^2 - k_d \\omega_3^2 + k_d \\omega_4^2 \\] <p>Como \\(\\omega_1 = \\omega_3 = 1.000 \\, rad/s\\), \\(\\omega_2 = \\omega_4 = 2.000 \\, rad/s\\) e \\(I_{zz} = 4 \\cdot 10^{-5} \\, kg.m^2\\). substituindo na equa\u00e7\u00e3o anterior:</p> \\[ \\begin{align*}     \\psi &amp;= \\frac{\\tau_z}{2I_{zz}} t^2 \\\\     \\psi &amp;= \\frac{\\left(-k_d \\omega_1^2 + k_d \\omega_2^2 - k_d \\omega_3^2 + k_d \\omega_4^2\\right)}{2I_{zz}} t^2 \\\\     \\psi &amp;= \\frac{\\left(-\\omega_1^2 + \\omega_2^2 - \\omega_3^2 + \\omega_4^2\\right)k_d}{2I_{zz}} t^2 \\\\     \\psi &amp;= \\frac{- \\cancel{2}\\omega_1^2 + \\cancel{2} \\omega_2^2}{\\cancel{2}I_{zz}} k_d t^2 \\\\     \\psi &amp;= \\frac{- 1000^2 + 2000^2}{4 \\cdot 10^{-5}} k_d t^2 \\\\     \\psi &amp;= \\left( 75 \\times 10^{9} \\right) k_d t^2 \\\\ \\end{align*} \\] <p>Ou seja, o tipo de fun\u00e7\u00e3o mais adequado para realizar esse ajuste de curva \u00e9 uma fun\u00e7\u00e3o polinomial de 2\u00ba grau cujos coeficientes de ordem zero e um s\u00e3o nulos.</p> <p>Determine o valor de \\(k_d\\) fazendo esse ajuste de curva (dica: utilize o Curve Fitting Toolbox do MATLAB). Anote o valor obtido em algum lugar pois ele ser\u00e1 utilizado em breve.</p>"},{"location":"pages/identification/drag_constant/#validacao-dos-resultados","title":"Valida\u00e7\u00e3o dos resultados","text":"<p>Compare o resultado obtido com o estimado anteriormente. \u00c9 esperado que a constante de sustenta\u00e7\u00e3o \\(k_d\\) seja da ordem de grandeza de \\(10^{-10}N.s^2\\). </p>"},{"location":"pages/identification/lift_constant/","title":"Identifica\u00e7\u00e3o da constante de sustenta\u00e7\u00e3o","text":"<p>Nesta sec\u00e7\u00e3o, voc\u00ea ir\u00e1 determinar experimentalmente a constante de sustenta\u00e7\u00e3o das h\u00e9lices \\(k_l\\).</p>"},{"location":"pages/identification/lift_constant/#fundamentos-teoricos","title":"Fundamentos te\u00f3ricos","text":"<p>As h\u00e9lices de um quadricoptero atuam como superf\u00edcies aerodin\u00e2micas, acelerando o fluxo de ar atrav\u00e9s delas. Isso consome energia das baterias e produz for\u00e7as de sustenta\u00e7\u00e3o e torques de arrasto no quadricoptero. J\u00e1 deduzimos que a for\u00e7a de sustenta\u00e7\u00e3o de uma h\u00e9lice \\(f\\) \u00e9 proporcional \u00e0 velocidade angular da h\u00e9lice \\(\\omega\\) ao quadrado.</p> <p></p> \\[     \\tau = k_l \\omega^2 \\] <p>Onde:</p> <ul> <li>\\(k_l\\) - Constante de sustenta\u00e7\u00e3o (\\(N.s^2\\))   </li> </ul>"},{"location":"pages/identification/lift_constant/#procedimento-experimental","title":"Procedimento experimental","text":"<p>Voc\u00ea vai medir a for\u00e7a de de sustenta\u00e7\u00e3o \\(f\\) das h\u00e9lices com um suporte(1) que fixa o drone em uma balan\u00e7a atrav\u00e9s de um im\u00e3. </p> <ol> <li>Para prender o quadcoptero no suporte, voc\u00ea precisa encaix\u00e1-lo pela lateral e depois prender dois parafusos. </li> </ol> <p></p> <p>Sabendo a leitura da balan\u00e7a, \u00e9 poss\u00edvel determinar a for\u00e7a de sustenta\u00e7\u00e3o das h\u00e9lices. Voc\u00ea pode zerar a balan\u00e7a com o quadcoptero apertando o bot\u00e3o <code>TARE</code>, assim, qualquer for\u00e7a de sustenta\u00e7\u00e3o que as h\u00e9lices produzirem vai gerar uma leitura negativa na balan\u00e7a.</p> <p></p> <p>Voc\u00ea deve carregar no drone um programa que ligue os quatro motores com um determinado valor de velocidade angular. Ser\u00e3o levantados dados de peso na balan\u00e7a para 10 valores distintos, e, para cada valor de, voc\u00ea dever\u00e1 realizar o experimento tr\u00eas vezes e tirar uma m\u00e9dia. Para facilitar o experimento, voc\u00ea pode controlar o valor da velocidade angular com os bot\u00f5es <code>Up</code> e <code>Down</code> do Command Based Flight Control atrav\u00e9s do CFClient.</p> <p></p> <p>Crie um arquivo chamado <code>lift_constant.c</code> dentro da pasta <code>src/identification</code> com o seguinte c\u00f3digo(1):</p> <ol> <li>N\u00e3o esque\u00e7a de atualizar os valores dos coeficientes dos motores \\(a_2\\) e \\(a_1\\) (linhas 8-9) estimados anteriormente.</li> </ol> lift_constant.c<pre><code>#include \"FreeRTOS.h\"      // FreeRTOS core definitions (needed for task handling and timing)\n#include \"task.h\"          // FreeRTOS task functions (e.g., vTaskDelay)\n#include \"supervisor.h\"    // Functions to check flight status (e.g., supervisorIsArmed)\n#include \"commander.h\"     // Access to commanded setpoints (e.g., commanderGetSetpoint)\n#include \"motors.h\"        // Low-level motor control interface (e.g., motorsSetRatio)\n#include \"debug.h\"         // Debug printing functions (e.g., DEBUG_PRINT)\n\n// Motor coefficients of the quadratic model: PWM = a_2 * omega^2 + a_1 * omega\nconst float a_2 = 0.0f;\nconst float a_1 = 0.0f;\n\n// Global variables to store the desired setpoint, the current state (not used here), \n// the computed PWM value, and the desired angular velocity (omega)\nsetpoint_t setpoint;\nstate_t state;\nfloat pwm;\nfloat omega;\n\n// Main application\nvoid appMain(void *param)\n{\n    // Infinite loop (runs forever)\n    while (true)\n    {\n        // Check if the drone is armed (i.e., ready to fly)\n        if (supervisorIsArmed())\n        {\n            // Fetch the latest setpoint from the commander and also fetch the current estimated state (not used here)\n            commanderGetSetpoint(&amp;setpoint, &amp;state);\n\n            // Compute an angular velocity value proportional to the commanded altitude (Z axis position)\n            // The altitude command increases in 0.5 m steps, and we want the angular velocity to increase \n            // by 200 rad/s for each step. Therefore, we multiply Z by 400.0 so that: 0.5 m \u2192 200 rad/s\n            omega = (setpoint.position.z) * 400.0f;\n\n            // Print the computed omega value to the debug console (rounded to nearest integer)\n            DEBUG_PRINT(\"Omega (rad/s): %.0f\\n\", (double)omega);\n\n            // Convert angular velocity to PWM using the motor model: PWM = a_2 * omega^2 + a_1 * omega\n            pwm = a_2 * omega * omega + a_1 * omega;\n        }\n        else\n        {\n            // If not armed, stop the motors (set PWM to zero)\n            pwm = 0.0f;\n        }\n\n        // Send the PWM signal to all four motors (M1\u2013M4), scaling it to match the expected range [0, UINT16_MAX]\n        motorsSetRatio(MOTOR_M1, pwm * UINT16_MAX);\n        motorsSetRatio(MOTOR_M2, pwm * UINT16_MAX);\n        motorsSetRatio(MOTOR_M3, pwm * UINT16_MAX);\n        motorsSetRatio(MOTOR_M4, pwm * UINT16_MAX);\n\n        // Wait for 100 milliseconds before running the next iteration (10 Hz control loop)\n        vTaskDelay(pdMS_TO_TICKS(100));\n    }\n}\n</code></pre> <p>As etapas para coletar os dados s\u00e3o as seguintes:</p> <ol> <li>Garanta que a bateria do drone est\u00e1 carregada </li> <li>Prenda o drone no dispositivo e zere a balan\u00e7a presionando o bot\u00e3o <code>T</code></li> <li>Arme o drone apertando o bot\u00e3o <code>Arm</code> no CFClient</li> <li>Ligue o motor com um valor espec\u00edfico de velocidade angular \\(\\omega\\) com o Command Based Flight Control do CFClient</li> <li>Anote o n\u00famero que aparece na tela</li> <li>Repita as etapas 4-5 para outros valores de sinal PWM</li> </ol> <p>Ap\u00f3s o experimento, voc\u00ea dever\u00e1 coletar dados para preencher a tabela abaixo.</p> \\(\\omega \\, (rad/s)\\) \\(W_1 \\, (g)\\) \\(W_2 \\, (g)\\) \\(W_3 \\, (g)\\) \\(600\\) \\(800\\) \\(1200\\) \\(1400\\) \\(1600\\) \\(1800\\) \\(2000\\) \\(2200\\) \\(2400\\)"},{"location":"pages/identification/lift_constant/#analise-de-dados","title":"An\u00e1lise de dados","text":"<p>Utilizando os dados coletados, voc\u00ea dever\u00e1 ajustar uma curva que correlacione a velocidade angular \\(\\omega\\) com a for\u00e7a de sustenta\u00e7\u00e3o \\(f\\) da h\u00e9lice (note que voc\u00ea precisa converter a a leitura da balan\u00e7a de \\(g\\) para \\(N\\) e dividir por 4, dado que estamos interessados na for\u00e7a de uma \u00fanica h\u00e9lice).</p> <p></p> <p>Voc\u00ea j\u00e1 sabe que a for\u00e7a de sustenta\u00e7\u00e3o de uma h\u00e9lice \\(f\\) \u00e9 proporcional \u00e0 velocidade angular da h\u00e9lice \\(\\omega\\) ao quadrado:</p> \\[     f = k_l \\omega^2 \\] <p>Ou seja, o tipo de fun\u00e7\u00e3o mais adequado para realizar esse ajuste de curva \u00e9 uma fun\u00e7\u00e3o polinomial de 2\u00ba grau cujos coeficientes de ordem zero e um s\u00e3o nulos. </p> <p>Determine o valor de \\(k_l\\) fazendo esse ajuste de curva (dica: utilize o Curve Fitting Toolbox do MATLAB). Anote o valor obtido em algum lugar pois ele ser\u00e1 utilizado em breve.</p>"},{"location":"pages/identification/lift_constant/#validacao-dos-resultados","title":"Valida\u00e7\u00e3o dos resultados","text":"<p>Compare o resultado obtido com o estimado anteriormente. \u00c9 esperado que a constante de sustenta\u00e7\u00e3o \\(k_l\\) seja da ordem de grandeza de \\(10^{-8}N.s^2\\). </p>"},{"location":"pages/identification/motor_coefficients/","title":"Identifica\u00e7\u00e3o dos coeficientes do motor","text":"<p>Nesta sec\u00e7\u00e3o, voc\u00ea ir\u00e1 determinar experimentalmente os coeficientes do motor el\u00e9trico.</p>"},{"location":"pages/identification/motor_coefficients/#fundamentos-teoricos","title":"Fundamentos te\u00f3ricos","text":"<p>O PWM (\"pulse width modulation\") \u00e9 uma t\u00e9cnica para controlar a pot\u00eancia de um sinal utilizando uma comuta\u00e7\u00e3o digital. Ao mudar rapidamente o sinal entre o m\u00e1ximo e zero (\"on-off\"), e variando a fra\u00e7\u00e3o de tempo que o sinal est\u00e1 no m\u00e1ximo, pode-se controlar a pot\u00eancia transmitida (isto \u00e9, modulando a largura do pulso).</p> <p> </p> <p>Este \u00e9 o mecanismo utilizado pelo Crazyflie para acionar seus motores. J\u00e1 sabemos que no c\u00f3digo \u00e9 poss\u00edvel definir um valor real entre <code>0.0</code> e <code>1.0</code> que corresponde ao sinal PWM do motor. </p> <p>Voc\u00ea ir\u00e1 implementar uma fun\u00e7\u00e3o que, dada uma velocidade angular desejada \\(\\omega\\), determine o sinal PWM correspondente. </p>"},{"location":"pages/identification/motor_coefficients/#procedimento-experimental","title":"Procedimento experimental","text":"<p>Para medir a velocidade angular da h\u00e9lice, voc\u00ea pode utilizar um instrumento de medi\u00e7\u00e3o do n\u00famero de rota\u00e7\u00f5es chamado tac\u00f4metro. Para utiliz\u00e1-lo, voc\u00ea deve fixar um pequeno peda\u00e7o de fita refletora em uma das h\u00e9lices. Certifique-se de usar apenas um pequeno peda\u00e7o de fita e aplicar suavemente na h\u00e9lice, caso contr\u00e1rio voc\u00ea interferir\u00e1 no fluxo de ar e obter\u00e1 dados ruins. </p> <p></p> <p>O tac\u00f4metro pode detectar quando a tira passa pelo seu feixe de luz, assim, a velocidade de rota\u00e7\u00e3o \u00e9 calculada contando quantas vezes a tira passa em um determinado per\u00edodo de tempo. O tac\u00f4metro DT-2234C+ registra a velocidade angular enquanto voc\u00ea pressiona o bot\u00e3o <code>TEST</code> e, uma vez que este bot\u00e3o \u00e9 liberado, ele armazena os valores m\u00ednimo, m\u00e1ximo e m\u00e9dio, que voc\u00ea pode conferir apertando o bot\u00e3o <code>MEM</code>.</p> <p></p> <p>Voc\u00ea deve carregar no drone um programa que ligue apenas o motor cuja h\u00e9lice est\u00e1 com o peda\u00e7o de fita refletora com um determinado valor de sinal PWM. Ser\u00e3o levantados dados de velocidade angular da h\u00e9lice para 10 valores distintos de sinal PWM (<code>0.1</code> at\u00e9 <code>1.0</code>), e, para cada valor de sinal PWM, voc\u00ea dever\u00e1 realizar o experimento 3 vezes e tirar uma m\u00e9dia. Para facilitar o experimento, voc\u00ea pode controlar o valor do PWM com os bot\u00f5es <code>Up</code> e <code>Down</code> do Command Based Flight Control atrav\u00e9s do CFClient.</p> <p></p> <p>Crie um arquivo chamado <code>motor_coeficients.c</code> dentro da pasta <code>src/identification</code> com o seguinte c\u00f3digo:</p> motor_coeficients.c<pre><code>#include \"FreeRTOS.h\"      // FreeRTOS core definitions (needed for task handling and timing)\n#include \"task.h\"          // FreeRTOS task functions (e.g., vTaskDelay)\n#include \"supervisor.h\"    // Functions to check flight status (e.g., supervisorIsArmed)\n#include \"commander.h\"     // Access to commanded setpoints (e.g., commanderGetSetpoint)\n#include \"motors.h\"        // Low-level motor control interface (e.g., motorsSetRatio)\n\n// Global variables to store the desired setpoint, the current state (not used here) and the computed PWM value.\nsetpoint_t setpoint;\nstate_t state;\nfloat pwm;\n\n// Main application\nvoid appMain(void *param)\n{\n    // Infinite loop (runs forever)\n    while (true)\n    {\n        // Check if the drone is armed (i.e., ready to fly)\n        if (supervisorIsArmed())\n        {\n            // Fetch the latest setpoint from the commander and also fetch the current estimated state (not used here)\n            commanderGetSetpoint(&amp;setpoint, &amp;state);\n\n            // Compute a PWM value proportional to the commanded altitude (Z axis position)\n            // The altitude command increases in 0.5 m steps, and we want the PWM to increase by 0.1 for each step.\n            // Therefore, we divide Z by 5.0 so that: 0.5 m \u2192 0.1 PWM\n            pwm = (setpoint.position.z) / 5.0f;\n        }\n        else\n        {\n            // If not armed, stop the motor (set PWM to zero)\n            pwm = 0.0f;\n        }\n        // Send the PWM signal to motor M1, scaling it to match the expected range [0, UINT16_MAX]\n        motorsSetRatio(MOTOR_M1, pwm * UINT16_MAX);\n        // Wait for 100 milliseconds before running the next iteration (10 Hz control loop)\n        vTaskDelay(pdMS_TO_TICKS(100));\n    }\n}\n</code></pre> <p>As etapas para coletar um dado s\u00e3o as seguintes:</p> <ol> <li>Garanta que a bateria do drone est\u00e1 carregada </li> <li>Prenda o drone na mesa com uma fita crepe</li> <li>Arme o drone apertando o bot\u00e3o <code>Arm</code> no CFClient</li> <li>Ligue o motor com um valor espec\u00edfico de sinal PWM com o Command Based Flight Control do CFClient</li> <li>Aponte o tac\u00f4metro para a h\u00e9lice segurando a aproximadamente \\(30cm\\) de dist\u00e2ncia e, em seguida, pressione o bot\u00e3o <code>TEST</code> </li> <li>Mantenha o bot\u00e3o <code>TEST</code> pressionado o tempo todo, certificando-se de que o feixe aponta para onde a faixa refletora passa  </li> <li>Mantenha essa posi\u00e7\u00e3o por alguns segundos e solte o bot\u00e3o <code>TEST</code> </li> <li>Pressione o bot\u00e3o <code>MEM</code> uma vez e espere aparecer a segunda leitura, que corresponde \u00e0 velocidade m\u00e1xima (em \\(rpm\\)) observada durante o experimento  </li> <li>Anote o n\u00famero que aparece na tela</li> <li>Repita as etapas 4-9 para outros valores de sinal PWM</li> </ol> <p>Ap\u00f3s o experimento, voc\u00ea dever\u00e1 coletar dados para preencher a tabela abaixo.</p> PWM N1 (rpm) N2 (rpm) N3 (rpm) <code>0.1</code> <code>0.2</code> <code>0.3</code> <code>0.4</code> <code>0.5</code> <code>0.6</code> <code>0.7</code> <code>0.8</code> <code>0.9</code> <code>1.0</code>"},{"location":"pages/identification/motor_coefficients/#analise-de-dados","title":"An\u00e1lise de dados","text":"<p>Utilizando os dados coletados, voc\u00ea dever\u00e1 ajustar uma curva que correlacione a velocidade angular das h\u00e9lice \\(\\omega\\) com o sinal PWM correspondente do motor (note que voc\u00ea precisa converter a velocidade angular de \\(rpm\\) para \\(rad/s\\)).</p> <p></p> <p>H\u00e1 diversos tipos de fun\u00e7\u00f5es de ajuste para esta curva (linear, exponencial, polinomial, etc.):</p> \\[     \\text{PWM} = f(\\omega) \\] <p>Para definir qual \u00e9 melhor para este caso, \u00e9 necess\u00e1rio se aprofundar na din\u00e2mica do sistema. O esquema eletromec\u00e2nico de um motor el\u00e9trico com uma h\u00e9lice pode ser visto no diagrama abaixo<sup>1</sup>.</p> <p></p> <p>Onde:</p> <ul> <li>\\(e_a\\) - Tens\u00e3o de armadura (\\(V\\))</li> <li>\\(i_a\\) - Corrente de armadura (\\(A\\))</li> <li>\\(R_a\\) - Resist\u00eancia de armadura (\\(\\Omega\\))</li> <li>\\(L_a\\) - Indut\u00e2ncia de armadura (\\(H\\))</li> <li>\\(e_b\\) - Tens\u00e3o contra-eletromotriz (\\(V\\))</li> <li>\\(\\omega\\) - Velocidade angular do motor/h\u00e9lice (\\(rad/s\\))</li> <li>\\(\\tau_m\\) - Torque do motor (\\(N.m\\))</li> <li>\\(k_d\\) - Constante de arrasto da h\u00e9lice (\\(N.m.s^2/rad^2\\))</li> <li>\\(b\\) - Coeficiente de atrito viscoso do motor (\\(N.m.s/rad\\))</li> <li>\\(I\\) - Momento de in\u00e9rcia do motor/h\u00e9lice (\\(kg.m^2\\))</li> </ul> <p>Exerc\u00edcio 1</p> <p>Aplique a lei de Kirchoff das tens\u00f5es no circuito de armadura.</p> Resposta \\[ \\begin{align*}     \\sum_{i=1}^n e_i &amp;= 0 \\\\     e_a - R_a i_a - L_a \\frac{d}{dt} i_a - e_b &amp;= 0 \\end{align*} \\] <p>Exerc\u00edcio 2</p> <p>Aplique a 2\u00ba lei de Newton em torno do eixo do motor.</p> Resposta \\[ \\begin{align*}     \\sum_{i=1}^n \\tau_i &amp;= I \\frac{d}{dt} \\omega \\\\     \\tau_m - k_d \\omega^2 - b \\omega &amp;= I \\frac{d}{dt} \\omega \\end{align*} \\] <p>Em um motor de corrente cont\u00ednua, o torque do motor \\(\\tau_m\\) \u00e9 diretamente proporcional \u00e0 corrente de armadura \\(i_a\\), e a tens\u00e3o contra-eletromotriz \\(e_b\\) \u00e9 diretamente proporcional \u00e0 velocidade angular \\(\\omega\\):</p> \\[ \\tau_m = K_m i_a  \\qquad e_b = K_m \\omega    \\] <p>Onde:</p> <ul> <li>\\(K_m\\) - Constante de torque do motor (\\(N.m/A\\) ou \\(V.s/rad\\)).</li> </ul> <p>Exerc\u00edcio 3</p> <p>Substitua o torque do motor \\(\\tau_m\\) e a tens\u00e3o contra-eletromotriz \\(e_b\\) nas duas equa\u00e7\u00f5es diferenciais obtidas anteriormente.</p> Resposta \\[ \\left\\{     \\begin{array}{l}         L_a \\dfrac{d}{dt} i_a + R_a i_a + K_m \\omega = e_a \\\\ \\\\         I \\dfrac{d}{dt} \\omega + k_d \\omega^2 + b \\omega - K_m i_a = 0     \\end{array} \\right. \\] <p>Quando o motor entra em regime, a corrente de armadura \\(i_a\\) e a velocidade angular \\(\\omega\\) tornam-se constantes (essa \u00e9 a defini\u00e7\u00e3o de ``regime''):</p> \\[     \\dfrac{d}{dt} i_a = 0 \\qquad \\dfrac{d}{dt} \\omega = 0 \\] <p>Exerc\u00edcio 4</p> <p>Iguale as derivadas da corrente de armadura \\(i_a\\) e da velocidade angular \\(\\omega\\) a zero e isole a corrente de armadura \\(i_a\\) nas duas equa\u00e7\u00f5es.</p> Resposta \\[ \\begin{align*}         L_a \\cancelto{0}{\\dfrac{d}{dt} i_a} + R_a i_a + K_m \\omega &amp;= e_a \\\\         R_a i_a &amp;= e_a - K_m \\omega \\\\         i_a &amp;= \\dfrac{1}{R_a} e_a - \\dfrac{K_m}{R_a} \\omega \\end{align*} \\] \\[ \\begin{align*}     I \\cancelto{0}{\\dfrac{d}{dt} \\omega} + k_d \\omega^2 + b \\omega - K_m i_a &amp;= 0 \\\\     K_m i_a &amp;= k_d \\omega^2 + b \\omega \\\\     i_a &amp;= \\dfrac{k_d}{K_m} \\omega^2 + \\dfrac{b}{K_m} \\omega \\end{align*} \\] <p>Exerc\u00edcio 5</p> <p>Iguale a corrente de armadura \\(i_a\\) obtida em cada uma das equa\u00e7\u00f5es e isole a tens\u00e3o de armadura \\(e_a\\) na equa\u00e7\u00e3o.</p> Resposta \\[ \\begin{align*}     \\dfrac{1}{R_a} e_a - \\dfrac{K_m}{R_a} \\omega &amp;= \\dfrac{k_d}{K_m} \\omega^2 + \\dfrac{b}{K_m} \\omega\\\\     \\dfrac{1}{R_a} e_a &amp;= \\dfrac{k_d}{K_m} \\omega^2 + \\dfrac{b}{K_m} \\omega + \\dfrac{K_m}{R_a} \\omega \\\\     e_a &amp;= \\dfrac{R_a k_d}{K_m} \\omega^2 + \\dfrac{R_a b + K_m^2}{K_m} \\omega \\end{align*} \\] <p>O sinal PWM \u00e9 a raz\u00e3o entre a tens\u00e3o de armadura \\(e_a\\) e a tens\u00e3o da bateria \\(e_s\\):</p> \\[     \\text{PWM} = \\frac{e_a}{e_s} \\] <p>Exerc\u00edcio 6</p> <p>Substitua a tens\u00e3o de armadura \\(e_a\\) na equa\u00e7\u00e3o anterior e isole o sinal PWM na equa\u00e7\u00e3o.</p> Resposta \\[ \\begin{align*}     e_a &amp;= \\dfrac{R_a k_d}{K_m} \\omega^2 + \\dfrac{R_a b + K_m^2}{K_m} \\omega \\\\     e_s \\text{PWM} &amp;= \\dfrac{R_a k_d}{K_m} \\omega^2 + \\dfrac{R_a b + K_m^2}{K_m} \\omega \\\\     \\text{PWM} &amp;= \\dfrac{R_a k_d}{K_me_s} \\omega^2 + \\dfrac{R_a b + K_m^2}{K_me_s} \\omega \\end{align*} \\] <p>Voc\u00ea deve ter chegado a:</p> \\[     \\text{PWM} =\\dfrac{R_a k_d}{K_me_s} \\omega^2 + \\dfrac{R_a b + K_m^2}{K_me_s} \\omega \\] <p>Como \\(R_a\\), \\(k_d\\), \\(b\\), \\(K_m\\) e \\(e_s\\) s\u00e3o par\u00e2metros constantes, podemos agrup\u00e1-los em duas constantes:</p> \\[     \\text{PWM} = \\underbrace{\\dfrac{R_a k_d}{K_me_s}}_{a_2} \\omega^2 + \\underbrace{\\dfrac{R_a b + K_m^2}{K_me_s}}_{a_1} \\omega \\] <p>Ou seja, o tipo de fun\u00e7\u00e3o mais adequado para realizar esse ajuste de curva \u00e9 uma fun\u00e7\u00e3o polinomial de 2\u00ba grau cujo coeficiente de ordem zero \u00e9 nulo:</p> \\[     \\text{PWM} = a_2 \\omega^2 + a_1 \\omega + \\cancelto{0}{a_0}   \\] <p>Dessa forma, ao inv\u00e9s de determinar os valores de cada par\u00e2metro (\\(R_a\\), \\(k_d\\), \\(b\\), \\(K_m\\) e \\(e_s\\)), voc\u00ea ir\u00e1 determinar experimentalmente apenas os valores dos coeficientes \\(a_2\\) e \\(a_1\\) (dica: utilize o Curve Fitting Toolbox do MATLAB).</p>"},{"location":"pages/identification/motor_coefficients/#validacao-dos-resultados","title":"Valida\u00e7\u00e3o dos resultados","text":"<p>Uma vez determinados os coeficientes \\(a_2\\) e \\(a_1\\), declare os seus valores no c\u00f3digo (linhas 10 e 11) e modifique seu programa para que, dada uma velocidade angular \\(\\omega\\) comandada (linhas 30 e 35), ele determine o sinal PWM correspondente (linha 41) e envie isso ao motor M1 (linha 50). Note que estamos imprimindo no console o valor de velocidade angular comandada (linha 38) e, para isso, devemos incluir uma biblioteca adicional (linha 6).</p> motor_coeficients.c<pre><code>#include \"FreeRTOS.h\"      // FreeRTOS core definitions (needed for task handling and timing)\n#include \"task.h\"          // FreeRTOS task functions (e.g., vTaskDelay)\n#include \"supervisor.h\"    // Functions to check flight status (e.g., supervisorIsArmed)\n#include \"commander.h\"     // Access to commanded setpoints (e.g., commanderGetSetpoint)\n#include \"motors.h\"        // Low-level motor control interface (e.g., motorsSetRatio)\n#include \"debug.h\"         // Debug printing functions (e.g., DEBUG_PRINT)\n\n// Motor coefficients of the quadratic model: PWM = a_2 * omega^2 + a_1 * omega\nconst float a_2 = 0.0f;\nconst float a_1 = 0.0f;\n\n// Global variables to store the desired setpoint, the current state (not used here), \n// the computed PWM value, and the desired angular velocity (omega)\nsetpoint_t setpoint;\nstate_t state;\nfloat pwm;\nfloat omega;\n\n// Main application\nvoid appMain(void *param)\n{\n    // Infinite loop (runs forever)\n    while (true)\n    {\n        // Check if the drone is armed (i.e., ready to fly)\n        if (supervisorIsArmed())\n        {\n            // Fetch the latest setpoint from the commander and also fetch the current estimated state (not used here)\n            commanderGetSetpoint(&amp;setpoint, &amp;state);\n\n            // Compute an angular velocity value proportional to the commanded altitude (Z axis position)\n            // The altitude command increases in 0.5 m steps, and we want the angular velocity to increase \n            // by 200 rad/s for each step. Therefore, we multiply Z by 400.0 so that: 0.5 m \u2192 200 rad/s\n            omega = (setpoint.position.z) * 400.0f;\n\n            // Print the computed omega value to the debug console (rounded to nearest integer)\n            DEBUG_PRINT(\"Omega (rad/s): %.0f\\n\", (double)omega);\n\n            // Convert angular velocity to PWM using the motor model: PWM = a_2 * omega^2 + a_1 * omega\n            pwm = a_2 * omega * omega + a_1 * omega;\n        }\n        else\n        {\n            // If not armed, stop the motors (set PWM to zero)\n            pwm = 0.0f;\n        }\n\n        // Send the PWM signal to motors M1, scaling it to match the expected range [0, UINT16_MAX]\n        motorsSetRatio(MOTOR_M1, pwm * UINT16_MAX);\n\n        // Wait for 100 milliseconds before running the next iteration (10 Hz control loop)\n        vTaskDelay(pdMS_TO_TICKS(100));\n    }\n}\n</code></pre> <p>O c\u00f3digo acima faz uso do Command Based Flight Control para comandar a velocidade angular \\(\\omega\\) em incrementos de \\(200rad/s\\). Voc\u00ea deve test\u00e1-lo verificando se a velocidade angular comandada est\u00e1 pr\u00f3xima<sup>2</sup> da leitura do tac\u00f4metro.</p> <ol> <li> <p>Embora o Crazyflie utilize um motor el\u00e9trico de corrente cont\u00ednua sem escovas e n\u00e3o com escovas, a equa\u00e7\u00e3o matem\u00e1tica de ambos \u00e9 equivalente.\u00a0\u21a9</p> </li> <li> <p>Ela n\u00e3o vai bater na v\u00edrgula, pois fizemos um ajuste de curva. No entanto, essa diverg\u00eancia n\u00e3o ser\u00e1 um problema pois ainda vamos fechar a malha de controle em um n\u00edvel superior.\u00a0\u21a9</p> </li> </ol>"},{"location":"pages/interface/motors/","title":"Atuadores","text":"<p>Nesta sec\u00e7\u00e3o, vamos fazer o drone girar um de seus motores pela primeira vez. Esse \u00e9 o seu primeiro contato com controle real de hardware, um passo fundamental rumo ao voo aut\u00f4nomo.</p> <p>Vamos criar um programa simples que liga o motor 1 com 10% de pot\u00eancia, sempre que o drone estiver armado (ou seja, autorizado a voar).</p>"},{"location":"pages/interface/motors/#visao-geral","title":"Vis\u00e3o geral","text":"<p>Antes de come\u00e7ar, \u00e9 importante entender alguns conceitos:</p> <ul> <li>Armar o drone significa autorizar o funcionamento dos motores. Isso \u00e9 feito manualmente pelo operador atrav\u00e9s do Crazyflie Client e verificado no c\u00f3digo com a fun\u00e7\u00e3o <code>supervisorIsArmed()</code>.</li> <li>O controle dos motores \u00e9 feito atrav\u00e9s da fun\u00e7\u00e3o <code>motorsSetRatio(id, ratio)</code>, onde <code>id</code> corresponde ao motor que vai ser acionado e <code>ratio</code> \u00e0 sua pot\u00eancia.<ul> <li>O Crazyflie possui quatro motores, identificados como <code>MOTOR_M1</code>, <code>MOTOR_M2</code>, <code>MOTOR_M3</code> e <code>MOTOR_M4</code>.</li> <li>A pot\u00eancia vai de <code>0</code> (desligado) at\u00e9 <code>UINT16_MAX</code> (pot\u00eancia m\u00e1xima).</li> </ul> </li> <li>Em FreeRTOS, um delay \u00e9 realizado atrav\u00e9s da fun\u00e7\u00e3o <code>vTaskDelay(pdMS_TO_TICKS(xTimeInMs))</code>, que recebe um tempo em milissegundos e o converte para ticks do sistema.</li> </ul>"},{"location":"pages/interface/motors/#codigo","title":"C\u00f3digo","text":"<p>Crie um arquivo chamado <code>motors.c</code> dentro da pasta <code>src/examples</code> com o seguinte c\u00f3digo:</p> motors.c<pre><code>#include \"FreeRTOS.h\"      // FreeRTOS core definitions (needed for task handling and timing)\n#include \"task.h\"          // FreeRTOS task functions (e.g., vTaskDelay)\n#include \"supervisor.h\"    // Functions to check flight status (e.g., supervisorIsArmed)\n#include \"motors.h\"        // Low-level motor control interface (e.g., motorsSetRatio)\n#include \"debug.h\"         // Debug printing functions (e.g., DEBUG_PRINT)\n\n// Main application loop\nvoid appMain(void *param)\n{\n    // Infinite loop (runs continuously while the drone is powered on)\n    while (true)\n    {\n        // Check if the drone is armed (i.e., ready to receive motor commands)\n        if (supervisorIsArmed())\n        {\n            // If armed, turn on motor 1 with 10% power\n            motorsSetRatio(MOTOR_M1, 0.1f * UINT16_MAX);\n        }\n        else\n        {\n            // If not armed, stop motor 1\n            motorsSetRatio(MOTOR_M1, 0);\n        }\n        // Wait for 100 milliseconds before checking again (10 Hz loop)\n        vTaskDelay(pdMS_TO_TICKS(100));\n    }\n}\n</code></pre> <p>Voc\u00ea pode simplesmente copiar e colar o c\u00f3digo acima. Mas \u00e9 importante que voc\u00ea leia e entenda o que cada linha est\u00e1 fazendo (o c\u00f3digo est\u00e1 bem comentado).</p>"},{"location":"pages/interface/motors/#compilando","title":"Compilando","text":"<p>Para que o firmware compile seu novo programa, modifique o arquivo <code>Kbuild</code>:</p> Kbuild<pre><code>obj-y += src/examples/motors.o\n</code></pre> <p>Em seguida, compile e programe o quadricoptero.</p>"},{"location":"pages/interface/motors/#testando","title":"Testando","text":"<p>Para testar o funcionamento, siga as etapas abaixo:</p> <ol> <li>Abra o Crazyflie Client e conecte-se ao drone.</li> <li>Clique no bot\u00e3o <code>Arm</code>.</li> <li>O motor 1 deve come\u00e7ar a girar com 10% de pot\u00eancia.</li> <li>Ao clicar em <code>Disarm</code>, o motor deve parar imediatamente.</li> </ol> <p>Aten\u00e7\u00e3o</p> <p>O motor vai girar, mas o drone n\u00e3o vai levantar voo, pois estamos controlando apenas um motor isolado com baixa pot\u00eancia.</p> <p>Voc\u00ea acaba de escrever seu primeiro programa que interage com o hardware real do drone \u2014 controlando motores com seguran\u00e7a. Um passo simples, mas poderoso, no caminho do voo aut\u00f4nomo.</p>"},{"location":"pages/interface/sensors/","title":"Sensores","text":"<p>Nesta sec\u00e7\u00e3o, vamos aprender como ler os dados dos sensores do drone em tempo real. Esses dados s\u00e3o fundamentais para tarefas como estabiliza\u00e7\u00e3o, controle, navega\u00e7\u00e3o e autonomia.</p> <p>Vamos criar um programa que l\u00ea e imprime no console os seguintes sensores:</p> <ul> <li>Aceler\u00f4metro (\\(a_x\\), \\(a_y\\) e \\(a_z\\))</li> <li>Girosc\u00f3pio (\\(g_x\\), \\(g_y\\) e \\(g_z\\))</li> <li>Proximidade (\\(d\\))</li> <li>Fluxo \u00f3ptico (\\(p_x\\) e \\(p_y\\))</li> </ul>"},{"location":"pages/interface/sensors/#visao-geral","title":"Vis\u00e3o geral","text":"<p>Antes de come\u00e7ar, \u00e9 importante entender alguns conceitos:</p> <ul> <li>Os sensores no Crazyflie s\u00e3o processados por um sistema de estima\u00e7\u00e3o que envia os dados via uma fila interna. Usamos a fun\u00e7\u00e3o <code>estimatorDequeue(&amp;m)</code>, para preencher a estrutura <code>measurement_t m</code>, que cont\u00e9m diferentes tipos de leitura, identificados por <code>m.type</code>.</li> <li>O sistema coleta dados continuamente em alta frequ\u00eancia, que v\u00eam da IMU (aceler\u00f4metro e girosc\u00f3pio), do lidar (proximidade) e da c\u00e2mera (fluxo \u00f3ptico).</li> <li>Usamos <code>DEBUG_PRINT()</code> para exibir os valores no console serial.</li> </ul>"},{"location":"pages/interface/sensors/#codigo","title":"C\u00f3digo","text":"<p>Crie um arquivo chamado <code>sensors.c</code> dentro da pasta <code>src/examples</code> com o seguinte c\u00f3digo:</p> sensors.c<pre><code>#include \"FreeRTOS.h\"   // FreeRTOS core definitions (needed for task handling and timing)\n#include \"task.h\"       // FreeRTOS task functions (e.g., vTaskDelay)\n#include \"supervisor.h\" // Functions to check flight status (e.g., supervisorIsArmed)\n#include \"debug.h\"      // Debug printing functions (e.g., DEBUG_PRINT)\n#include \"estimator.h\"  // Estimator functions (e.g., estimatorDequeue)\n\n// Sensors data\nfloat ax, ay, az; // Accelerometer [m/s^2]\nfloat gx, gy, gz; // Gyroscope [rad/s]\nfloat d;          // Range [m]\nfloat px, py;     // Optical flow [pixels]\n\n// Main application loop\nvoid appMain(void *param)\n{\n    // Infinite loop (runs continuously while the drone is powered on)\n    while (true)\n    {\n        // Get sensor data from queue\n        measurement_t m;\n        while (estimatorDequeue(&amp;m))\n        {\n            switch (m.type)\n            {\n            case MeasurementTypeGyroscope:\n                gx = m.data.gyroscope.gyro.x;\n                gy = m.data.gyroscope.gyro.y;\n                gz = m.data.gyroscope.gyro.z;\n                break;\n            case MeasurementTypeAcceleration:\n                ax = m.data.acceleration.acc.x;\n                ay = m.data.acceleration.acc.y;\n                az = m.data.acceleration.acc.z;\n                break;\n            case MeasurementTypeTOF:\n                d = m.data.tof.distance;\n                break;\n            case MeasurementTypeFlow:\n                px = m.data.flow.dpixelx;\n                py = m.data.flow.dpixely;\n                break;\n            default:\n                break;\n            }\n        }\n        // Print sensor data to console\n        DEBUG_PRINT(\"Acc: %4.2f %4.2f %4.2f | Gyr: %6.2f %6.2f %6.2f | Dis: %4.2f | Flow: %2.0f %2.0f\\n\",(double)ax,(double)ay,(double)az,(double)gx,(double)gy,(double)gz,(double)d,(double)px,(double)py);\n        // Wait for 100 milliseconds before checking again (10 Hz loop)\n        vTaskDelay(pdMS_TO_TICKS(100));\n    }\n}\n</code></pre> <p>Voc\u00ea pode simplesmente copiar e colar o c\u00f3digo acima. Mas \u00e9 importante que voc\u00ea leia e entenda o que cada linha est\u00e1 fazendo (o c\u00f3digo est\u00e1 bem comentado).</p>"},{"location":"pages/interface/sensors/#compilando","title":"Compilando","text":"<p>Para que o firmware compile seu novo programa, modifique o arquivo <code>Kbuild</code>:</p> Kbuild<pre><code>obj-y += src/examples/sensors.o\n</code></pre> <p>Em seguida, compile e programe o quadricoptero.</p>"},{"location":"pages/interface/sensors/#testando","title":"Testando","text":"<p>Para testar o funcionamento, siga as etapas abaixo:</p> <ol> <li>Abra o Crazyflie Client e conecte-se ao drone.</li> <li>Clique em <code>View</code> &gt; <code>Toolboxes</code> &gt; <code>Console</code></li> <li>Verifique se os dados dos sensores est\u00e3o sendo impressos</li> </ol> <p>Aten\u00e7\u00e3o</p> <p>Movimente o drone com a m\u00e3o e observe a varia\u00e7\u00e3o dos sensores em tempo real.</p> <p>Agora voc\u00ea sabe como acessar dados brutos dos sensores do drone. Esses dados s\u00e3o a base para algoritmos de controle, filtros e navega\u00e7\u00e3o. A partir daqui, voc\u00ea ter\u00e1 todo o poder necess\u00e1rio para construir sistemas embarcados inteligentes \u2014 do jeito que quiser!</p>"},{"location":"pages/modeling/2d_model/","title":"Modelo 2D","text":"<p>Inicialmente, vamos deduzir as equa\u00e7\u00f5es diferenciais que descrevem a din\u00e2mica 2D de um quadric\u00f3ptero. Partiremos de um caso simplificado em duas dimens\u00f5es, o que reduz a complexidade matem\u00e1tica e facilita uma compreens\u00e3o mais intuitiva. Esse modelo funciona como um primeiro passo essencial para visualizar como as entradas influenciam as sa\u00eddas.</p>"},{"location":"pages/modeling/2d_model/#introducao","title":"Introdu\u00e7\u00e3o","text":"<p>A din\u00e2mica 2D possui 3 graus de liberdade (2 de transla\u00e7\u00e3o e 1 de rota\u00e7\u00e3o) e, portanto, devemos obter 6 equa\u00e7\u00f5es diferenciais (2 para cada grau de liberdade)(1).</p> <ol> <li>Para facilitar o entendimento, utilizaremos as seguintes cores e nota\u00e7\u00f5es:<ul> <li>\\({\\color{magenta} x}\\) - Estados (sistema de coordenadas inercial)</li> <li>\\({\\color{cyan} x\\,'}\\) - Estados (sistema de coordenadas m\u00f3vel)</li> <li>\\({\\color{#65DD18} u}\\) - Entradas</li> <li>\\(m\\) - Constantes</li> </ul> </li> </ol> <p></p> <p>Vamos modelar esse sistema sob quatro perspectivas diferentes, na seguinte ordem:</p> Ordem Nota\u00e7\u00e3o Posi\u00e7\u00f5es Velocidades 1 Escalar \\( y \\quad z \\quad \\phi \\) \\( v_y \\quad v_z \\quad \\omega_x \\) 2 \\( y \\quad z \\quad \\phi \\) \\( v^{'}_y \\quad v^{'}_z \\quad \\omega^{'}_x \\) 3 Vetorial \\( y \\quad z \\quad \\phi \\) \\( v_y \\quad v_z \\quad \\omega_x \\) 4 \\( y \\quad z \\quad \\phi \\) \\( v^{'}_y \\quad v^{'}_z \\quad \\omega^{'}_x \\) <p>Apesar de ir ficando cada vez mais complicado, quando passarmos para a din\u00e2mica 3D, a quarta (e \u00faltima) perspectiva acaba sendo a mais simples.</p>"},{"location":"pages/modeling/2d_model/#notacao-escalar","title":"Nota\u00e7\u00e3o escalar","text":"<p>A 2\u00aa lei de Newton para transla\u00e7\u00e3o e rota\u00e7\u00e3o, utilizando a nota\u00e7\u00e3o escalar, \u00e9 dada por:</p> \\[ \\left\\{ \\begin{array}{l}         \\sum f = m a \\\\          \\sum \\tau = I \\alpha \\end{array} \\right. \\] <p>Ela dever\u00e1 ser aplicada individualmente para cada grau de liberdade.</p>"},{"location":"pages/modeling/2d_model/#sistema-inercial","title":"Sistema inercial","text":"<p>Inicialmente, a ideia \u00e9 que tanto as posi\u00e7\u00f5es como as velocidades sejam descritas no sistema de coordenadas inercial, de modo que os estados do sistema sejam \\({\\color{magenta}y}\\), \\({\\color{magenta}z}\\), \\({\\color{magenta}\\phi}\\), \\({\\color{magenta}v_y}\\), \\({\\color{magenta}v_z}\\) e \\({\\color{magenta}\\omega_x}\\). </p> <p>Exerc\u00edcio 1</p> <p>Determine as equa\u00e7\u00f5es cinem\u00e1ticas, isto \u00e9, as equa\u00e7\u00f5es das derivadas das posi\u00e7\u00f5es (\\({\\color{magenta}y}\\), \\({\\color{magenta}z}\\) e \\({\\color{magenta}\\phi}\\)) em fun\u00e7\u00e3o dos estados do sistema.</p> a) Escreva \\({\\color{magenta}\\dot{y}}\\) em fun\u00e7\u00e3o dos estados do sistema. \\[ {\\color{magenta}\\dot{y}} = {\\color{magenta}v_y} \\] b) Escreva \\({\\color{magenta}\\dot{z}}\\) em fun\u00e7\u00e3o dos estados do sistema. \\[ {\\color{magenta}\\dot{z}} = {\\color{magenta}v_z} \\] c) Escreva \\({\\color{magenta}\\dot{\\phi}}\\) em fun\u00e7\u00e3o dos estados do sistema. \\[ {\\color{magenta}\\dot{\\phi}} = {\\color{magenta}\\omega_x} \\] <p>Exerc\u00edcio 2</p> <p>Determine as equa\u00e7\u00f5es cin\u00e9ticas, isto \u00e9, as equa\u00e7\u00f5es das derivadas das velocidades (\\({\\color{magenta}v_y}\\), \\({\\color{magenta}v_z}\\) e \\({\\color{magenta}\\omega_x}\\)) em fun\u00e7\u00e3o dos estados do sistema.</p> <p>Dica: voc\u00ea deve aplicar a 2\u00aa lei de Newton para cada grau de liberdade do sistema de coordenadas inercial.</p> a) Escreva \\({\\color{magenta}\\dot{v}_y}\\) em fun\u00e7\u00e3o dos estados do sistema. \\[ \\begin{align*}     \\sum  {\\color{magenta}f_y} &amp;= m {\\color{magenta}a_y} \\\\     - {\\color{#65DD18}f_t} \\sin {\\color{magenta}\\phi} &amp;= m {\\color{magenta}\\dot{v}_y} \\\\     {\\color{magenta}\\dot{v}_y} &amp;= - \\frac{1}{m} \\sin {\\color{magenta}\\phi} {\\color{#65DD18}f_t} \\end{align*} \\] b) Escreva \\({\\color{magenta}\\dot{v}_z}\\) em fun\u00e7\u00e3o dos estados do sistema. \\[ \\begin{align*}     \\sum {\\color{magenta}f_z} &amp;= m {\\color{magenta}a_z} \\\\     {\\color{#65DD18}f_t} \\cos {\\color{magenta}\\phi} - mg &amp;= m {\\color{magenta}\\dot{v}_z} \\\\         {\\color{magenta}\\dot{v}_z} &amp;= -g + \\frac{1}{m} \\cos {\\color{magenta}\\phi} {\\color{#65DD18}f_t} \\end{align*} \\] c) Escreva \\({\\color{magenta}\\dot{\\omega}_x}\\) em fun\u00e7\u00e3o dos estados do sistema. \\[ \\begin{align*}     \\sum {\\color{magenta}\\tau_x} &amp;= I_{xx} {\\color{magenta}\\alpha_x} \\\\     {\\color{#65DD18}\\tau_x} &amp;= I_{xx} {\\color{magenta}\\dot{\\omega}_x} \\\\     {\\color{magenta}\\dot{\\omega}_x} &amp;= \\frac{1}{I_{xx}} {\\color{#65DD18}\\tau_x} \\end{align*} \\] <p>Se juntarmos as equa\u00e7\u00f5es cin\u00e9ticas e cinem\u00e1ticas, obtemos a din\u00e2mica completa do sistema:</p> \\[ \\left\\{ \\begin{array}{l}     {\\color{magenta}\\dot{y}} = {\\color{magenta}v_y} \\\\      {\\color{magenta}\\dot{z}} = {\\color{magenta}v_z} \\\\     {\\color{magenta}\\dot{\\phi}} = {\\color{magenta}\\omega_x} \\\\      {\\color{magenta}\\dot{v}_y} = - \\frac{1}{m} \\sin {\\color{magenta}\\phi} {\\color{#65DD18}f_t} \\\\      {\\color{magenta}\\dot{v}_z} = -g + \\frac{1}{m} \\cos {\\color{magenta}\\phi} {\\color{#65DD18}f_t} \\\\      {\\color{magenta}\\dot{\\omega}_x} = \\frac{1}{I_{xx}} {\\color{#65DD18}\\tau_x} \\end{array} \\right. \\]"},{"location":"pages/modeling/2d_model/#sistema-movel","title":"Sistema m\u00f3vel","text":"<p>Outra forma de abordar esse problema \u00e9 descrevendo as posi\u00e7\u00f5es no sistema de coordenadas inercial mas as velocidades no sistema de coordenadas m\u00f3vel, de modo que os estados agora sejam \\({\\color{magenta}y}\\), \\({\\color{magenta}z}\\), \\({\\color{magenta}\\phi}\\), \\({\\color{cyan}v_y\\,'}\\), \\({\\color{cyan}v_z\\,'}\\) e \\({\\color{cyan}\\omega_x\\,'}\\). </p> <p>Isso normalmente \u00e9 feito pois faz muito mais sentido descrever as velocidades no sistema de coordenadas fixo no drone, al\u00e9m de que a maioria dos sensores (aceler\u00f4metro, girosc\u00f3pio, proximidade, fluxo \u00f3ptico, etc.) est\u00e3o presos nele e alinhados com esse sistema de coordenadas. No entanto, conforme veremos, as equa\u00e7\u00f5es agora ficam um pouco mais complexas e menos intuitivas.</p> <p>Exerc\u00edcio 3</p> <p>Determine as equa\u00e7\u00f5es cinem\u00e1ticas, isto \u00e9, as equa\u00e7\u00f5es das derivadas das posi\u00e7\u00f5es (\\({\\color{magenta}y}\\), \\({\\color{magenta}z}\\) e \\({\\color{magenta}\\phi}\\)) em fun\u00e7\u00e3o dos estados do sistema.</p> <p>Dica: lembre-se das matrizes de rota\u00e7\u00e3o vistas anteriormente e que os eixos \\({\\color{magenta}x}\\) e \\({\\color{cyan}x\\,'}\\) est\u00e3o alinhados.</p> a) Escreva \\({\\color{magenta}\\dot{y}}\\) em fun\u00e7\u00e3o dos estados do sistema. \\[ \\begin{bmatrix}     {\\color{cyan}v_y\\,'} \\\\     {\\color{cyan}v_z\\,'}     \\end{bmatrix}     =     \\underbrace{     \\begin{bmatrix}      \\cos{\\color{magenta}\\phi} &amp; \\sin{\\color{magenta}\\phi} \\\\      -\\sin{\\color{magenta}\\phi} &amp; \\cos{\\color{magenta}\\phi}  \\end{bmatrix}     }_{R}     \\begin{bmatrix}     {\\color{magenta}\\dot{y}} \\\\     {\\color{magenta}\\dot{z}} \\end{bmatrix} \\qquad \\longrightarrow \\qquad     \\begin{bmatrix}     {\\color{magenta}\\dot{y}} \\\\     {\\color{magenta}\\dot{z}}     \\end{bmatrix}     =     \\underbrace{     \\begin{bmatrix}      \\cos{\\color{magenta}\\phi} &amp; -\\sin{\\color{magenta}\\phi} \\\\      \\sin{\\color{magenta}\\phi} &amp; \\cos{\\color{magenta}\\phi}  \\end{bmatrix}     }_{R^{-1}}     \\begin{bmatrix}     {\\color{cyan}v_y\\,'} \\\\     {\\color{cyan}v_z\\,'} \\end{bmatrix} \\] \\[ {\\color{magenta}\\dot{y}} =  {\\color{cyan}v_y\\,'} \\cos {\\color{magenta}\\phi} -  {\\color{cyan}v_z\\,'} \\sin {\\color{magenta}\\phi} \\] b) Escreva \\({\\color{magenta}\\dot{z}}\\) em fun\u00e7\u00e3o dos estados do sistema. \\[ \\begin{bmatrix}     {\\color{cyan}v_y\\,'} \\\\     {\\color{cyan}v_z\\,'}     \\end{bmatrix}     =     \\underbrace{     \\begin{bmatrix}      \\cos{\\color{magenta}\\phi} &amp; \\sin{\\color{magenta}\\phi} \\\\      -\\sin{\\color{magenta}\\phi} &amp; \\cos{\\color{magenta}\\phi}  \\end{bmatrix}     }_{R}     \\begin{bmatrix}     {\\color{magenta}\\dot{y}} \\\\     {\\color{magenta}\\dot{z}} \\end{bmatrix} \\qquad \\longrightarrow \\qquad     \\begin{bmatrix}     {\\color{magenta}\\dot{y}} \\\\     {\\color{magenta}\\dot{z}}     \\end{bmatrix}     =     \\underbrace{     \\begin{bmatrix}      \\cos{\\color{magenta}\\phi} &amp; -\\sin{\\color{magenta}\\phi} \\\\      \\sin{\\color{magenta}\\phi} &amp; \\cos{\\color{magenta}\\phi}  \\end{bmatrix}     }_{R^{-1}}     \\begin{bmatrix}     {\\color{cyan}v_y\\,'} \\\\     {\\color{cyan}v_z\\,'} \\end{bmatrix} \\] \\[ {\\color{magenta}\\dot{z}} =  {\\color{cyan}v_y\\,'} \\sin {\\color{magenta}\\phi} +  {\\color{cyan}v_z\\,'} \\cos {\\color{magenta}\\phi} \\] c) Escreva \\({\\color{magenta}\\dot{\\phi}}\\) em fun\u00e7\u00e3o dos estados do sistema. \\[ {\\color{magenta}\\dot{\\phi}} = {\\color{cyan}\\omega_x\\,'} \\] <p>Exerc\u00edcio 4</p> <p>Determine as equa\u00e7\u00f5es cin\u00e9ticas, isto \u00e9, as equa\u00e7\u00f5es das derivadas das velocidades (\\({\\color{cyan}v_y\\,'}\\), \\({\\color{cyan}v_z\\,'}\\) e \\({\\color{cyan}\\omega_x\\,'}\\)) em fun\u00e7\u00e3o dos estados do sistema.</p> <p>Dica: voc\u00ea deve aplicar a 2\u00aa lei de Newton para cada grau de liberdade do sistema de coordenadas inercial.</p> a) Escreva \\({\\color{cyan}\\dot{v}_y\\,'}\\) em fun\u00e7\u00e3o dos estados do sistema. \\[ \\begin{align*}     \\sum {\\color{cyan}f_y\\,'} &amp;= m {\\color{cyan}a_y\\,'} \\\\     - m g \\sin {\\color{magenta}\\phi} &amp;= m \\left( {\\color{cyan}\\dot{v}_y\\,'} - {\\color{cyan}v_z\\,' \\omega_x\\,'} \\right) \\\\     {\\color{cyan}\\dot{v}_y\\,'} &amp;= {\\color{cyan}v_z\\,' \\omega_x\\,'} - g \\sin {\\color{magenta}\\phi} \\end{align*} \\] b) Escreva \\({\\color{cyan}\\dot{v}_z\\,'}\\) em fun\u00e7\u00e3o dos estados do sistema. \\[ \\begin{align*}     \\sum {\\color{cyan}f_z\\,'} &amp;= m {\\color{cyan}a_z\\,'} \\\\     {\\color{#65DD18}f_t} - m g {\\color{magenta}\\cos \\phi} &amp;= m \\left( {\\color{cyan}\\dot{v}_z\\,'} + {\\color{cyan}v_y\\,' \\omega_x\\,'} \\right) \\\\     {\\color{cyan}\\dot{v}_z\\,'} &amp;= - {\\color{cyan}v_y\\,' \\omega_x\\,'} - g \\cos {\\color{magenta}\\phi} + \\frac{1}{m} {\\color{#65DD18}f_t} \\end{align*} \\] c) Escreva \\({\\color{cyan}\\dot{\\omega}_x\\,'}\\) em fun\u00e7\u00e3o dos estados do sistema. \\[ \\begin{align*}     \\sum {\\color{cyan}\\tau_x\\,'} &amp;= I_{xx} {\\color{cyan}\\alpha_x\\,'} \\\\     {\\color{#65DD18}\\tau_x} &amp;= I_{xx} {\\color{cyan}\\dot{\\omega}_x\\,'} \\\\     {\\color{cyan}\\dot{\\omega}_x\\,'} &amp;= \\frac{1}{I_{xx}} {\\color{#65DD18}\\tau_x} \\end{align*} \\] <p>Se juntarmos as equa\u00e7\u00f5es cin\u00e9ticas e cinem\u00e1ticas, obtemos a din\u00e2mica completa do sistema:</p> \\[ \\left\\{ \\begin{array}{l}     {\\color{magenta}\\dot{y}} =  {\\color{cyan}v_y\\,'} \\cos {\\color{magenta}\\phi} -  {\\color{cyan}v_z\\,'} \\sin {\\color{magenta}\\phi} \\\\      {\\color{magenta}\\dot{z}} =  {\\color{cyan}v_y\\,'} \\sin {\\color{magenta}\\phi} +  {\\color{cyan}v_z\\,'} \\cos {\\color{magenta}\\phi} \\\\     {\\color{magenta}\\dot{\\phi}} =  {\\color{cyan}\\omega_x\\,'} \\\\      {\\color{cyan}\\dot{v}_y\\,'} = {\\color{cyan}v_z\\,' \\omega_x\\,'} - g \\sin {\\color{magenta}\\phi} \\\\      {\\color{cyan}\\dot{v}_z\\,'} = - {\\color{cyan}v_y\\,' \\omega_x\\,'} - g \\cos {\\color{magenta}\\phi} + \\frac{1}{m} {\\color{#65DD18}f_t} \\\\      {\\color{cyan}\\dot{\\omega}_x\\,'} = \\frac{1}{I_{xx}} {\\color{#65DD18}\\tau_x} \\end{array} \\right. \\] <p>Os termos \\({\\color{cyan}v_z\\,' \\omega_x\\,'}\\) e \\({\\color{cyan}v_y\\,' \\omega_x\\,'}\\) correspondem \u00e0s pseudo-acelera\u00e7\u00f5es centr\u00edfugas, que surgem ao descrever o movimento no referencial n\u00e3o inercial do drone (sistema de coordenadas m\u00f3vel).</p>"},{"location":"pages/modeling/2d_model/#notacao-vetorial","title":"Nota\u00e7\u00e3o vetorial","text":"<p>A 2\u00aa lei de Newton para transla\u00e7\u00e3o e rota\u00e7\u00e3o utilizando nota\u00e7\u00e3o vetorial \u00e9 dada por:</p> \\[ \\left\\{ \\begin{array}{l}         \\sum \\vec{f} = \\frac{d}{dt} \\vec{p} \\\\          \\sum \\vec{\\tau} = \\frac{d}{dt} \\vec{h} \\end{array} \\right. \\] <p>Onde \\(\\vec{p}\\) e \\(\\vec{h}\\) s\u00e3o, respectivamente, os vetores de momentos lineares e angulares:</p> \\[ \\left\\{ \\begin{array}{l}         \\vec{p} = m \\vec{v} \\\\          \\vec{h} = I \\vec{\\omega} \\end{array} \\right. \\] <p>Apesar de \\(m\\) continuar sendo um escalar que representa a massa do corpo, \\(I\\) agora \u00e9 uma matriz que representa os momentos de in\u00e9rcia em torno dos 3 eixos de rota\u00e7\u00e3o:</p> \\[ I =  \\begin{bmatrix}     I_{xx} &amp; 0 &amp; 0 \\\\     0 &amp; I_{yy} &amp; 0 \\\\     0 &amp; 0 &amp; I_{zz} \\end{bmatrix} \\] <p>Como estamos trabalhando agora com vetores, estas equa\u00e7\u00f5es podem ser aplicadas de uma \u00fanica vez para todos os graus de liberdade.</p>"},{"location":"pages/modeling/2d_model/#sistema-inercial_1","title":"Sistema inercial","text":"<p>Inicialmente, vamos definir o vetor acelera\u00e7\u00e3o da gravidade \\({\\color{magenta}\\vec{g}}\\) no sistema de coordenadas inercial e os vetores de for\u00e7as \\({\\color{cyan}\\vec{f}_d\\,'}\\) e torques \\({\\color{cyan}\\vec{\\tau}_d\\,'}\\) do drone no sistema de coordenadas m\u00f3vel:</p> \\[ {\\color{magenta}\\vec{g}} =  \\begin{bmatrix}     0 \\\\     0 \\\\     g \\end{bmatrix} \\qquad {\\color{cyan}\\vec{f_d}\\,'} =  \\begin{bmatrix}     0 \\\\     0 \\\\     {\\color{#65DD18}f_t}  \\end{bmatrix} \\qquad {\\color{cyan}\\vec{\\tau_d}\\,'} =  \\begin{bmatrix}     {\\color{#65DD18}\\tau_x} \\\\     0 \\\\     0 \\end{bmatrix} \\] <p>Fazemos isso pois eles est\u00e3o alinhados com estes sistemas de coordenadas e portanto \u00e9 muito mais f\u00e1cil descrev\u00ea-los assim.</p> <p>Exerc\u00edcio 5</p> <p>Exerc\u00edcio 6</p> <p>Determine as equa\u00e7\u00f5es cin\u00e9ticas vetoriais, isto \u00e9, as equa\u00e7\u00f5es das derivadas dos vetores de velocidades (\\({\\color{magenta}\\vec{v}}\\) e \\({\\color{magenta}\\vec{\\omega}}\\)) em fun\u00e7\u00e3o das somat\u00f3rias de for\u00e7as e torques.</p> a) Escreva \\({\\color{magenta}\\dot{\\vec{v}}}\\) em fun\u00e7\u00e3o de \\(\\sum{\\color{magenta}\\vec{f}}\\). \\[ \\begin{align*}     \\sum {\\color{magenta}\\vec{f}} &amp;= \\frac{d}{dt} {\\color{magenta}\\vec{p}} \\\\     \\sum {\\color{magenta}\\vec{f}} &amp;= \\frac{d}{dt} \\left( m {\\color{magenta}\\vec{v}} \\right) \\\\     \\sum {\\color{magenta}\\vec{f}} &amp;= m {\\color{magenta}\\dot{\\vec{v}}} \\\\     {\\color{magenta}\\dot{\\vec{v}}} &amp;= \\frac{1}{m} \\sum {\\color{magenta}\\vec{f}} \\end{align*} \\] b) Escreva \\({\\color{magenta}\\dot{\\vec{\\omega}}}\\) em fun\u00e7\u00e3o de \\(\\sum{\\color{magenta}\\vec{\\tau}}\\). \\[ \\begin{align*}     \\sum {\\color{magenta}\\vec{\\tau}} &amp;= \\frac{d}{dt} {\\color{magenta}\\vec{h}} \\\\     \\sum {\\color{magenta}\\vec{\\tau}} &amp;= \\frac{d}{dt} \\left( I {\\color{magenta}\\vec{\\omega}} \\right) \\\\     \\sum {\\color{magenta}\\vec{\\tau}} &amp;= I {\\color{magenta}\\dot{\\vec{\\omega}}} \\\\     {\\color{magenta}\\dot{\\vec{\\omega}}} &amp;= I^{-1} \\sum {\\color{magenta}\\vec{\\tau}} \\end{align*} \\] <p>Voc\u00ea deve ter chegado a:</p> \\[     \\left\\{     \\begin{array}{l}             {\\color{magenta}\\dot{\\vec{v}}} = \\frac{1}{m} \\sum {\\color{magenta}\\vec{f}} \\\\              {\\color{magenta}\\dot{\\vec{\\omega}}} = I^{-1} \\sum {\\color{magenta}\\vec{\\tau}}     \\end{array}     \\right. \\] <p>Essas equa\u00e7\u00f5es s\u00e3o gen\u00e9ricas, ou seja, valem pro movimento de transla\u00e7\u00e3o e rota\u00e7\u00e3o de qualquer corpo r\u00edgido, basta substituir o valor das somat\u00f3rias de for\u00e7as e torques.</p> <p>Exerc\u00edcio 7</p> <p>Substitua as somat\u00f3rias de for\u00e7as e torques definidos inicialmente e determine as equa\u00e7\u00f5es cin\u00e9ticas.</p> <p>Dica: cuidado com os sistemas de coordenadas em que eles est\u00e3o descritos.</p> a) Escreva \\({\\color{magenta}\\dot{\\vec{v}}}\\) em fun\u00e7\u00e3o dos estados do sistema. \\[ \\begin{align*}     {\\color{magenta}\\dot{\\vec{v}}} &amp;= \\frac{1}{m} \\sum {\\color{magenta}\\vec{f}} \\\\     {\\color{magenta}\\dot{\\vec{v}}} &amp;= \\frac{1}{m} \\left( - m {\\color{magenta}\\vec{g}} + {\\color{magenta}\\vec{f}_t} \\right) \\\\     {\\color{magenta}\\dot{\\vec{v}}} &amp;= - {\\color{magenta}\\vec{g}} + \\frac{1}{m} {\\color{magenta}\\vec{f}_t} \\\\     {\\color{magenta}\\dot{\\vec{v}}} &amp;= - {\\color{magenta}\\vec{g}} + \\frac{1}{m} R^T {\\color{cyan}\\vec{f}_t\\,'} \\\\     \\begin{bmatrix}         0 \\\\         {\\color{magenta}\\dot{v}_y} \\\\         {\\color{magenta}\\dot{v}_z}     \\end{bmatrix}     &amp;= -     \\begin{bmatrix}         0 \\\\         0 \\\\         g     \\end{bmatrix}      + \\frac{1}{m}     \\begin{bmatrix}         1 &amp; 0 &amp; 0 \\\\         0 &amp; \\cos{\\color{magenta}\\phi} &amp; -\\sin{\\color{magenta}\\phi} \\\\         0 &amp; \\sin{\\color{magenta}\\phi} &amp; \\cos{\\color{magenta}\\phi}     \\end{bmatrix}     \\begin{bmatrix}         0 \\\\         0 \\\\         {\\color{#65DD18}f_t}     \\end{bmatrix} \\\\     \\begin{bmatrix}         0 \\\\         {\\color{magenta}\\dot{v}_y} \\\\         {\\color{magenta}\\dot{v}_z}     \\end{bmatrix}     &amp;=     \\begin{bmatrix}         0 \\\\         - \\frac{1}{m} \\sin{\\color{magenta}\\phi} {\\color{#65DD18}f_t} \\\\         - g + \\frac{1}{m} \\cos{\\color{magenta}\\phi} {\\color{#65DD18}f_t}     \\end{bmatrix}  \\end{align*}   \\] b) Escreva \\({\\color{magenta}\\dot{\\vec{\\omega}}}\\) em fun\u00e7\u00e3o dos estados do sistema. \\[ \\begin{align*}     {\\color{magenta}\\dot{\\vec{\\omega}}} &amp;= I^{-1} \\sum {\\color{magenta}\\vec{\\tau}} \\\\     {\\color{magenta}\\dot{\\vec{\\omega}}} &amp;= I^{-1} {\\color{magenta}\\vec{\\tau}_x} \\\\     \\begin{bmatrix}         {\\color{magenta}\\dot{\\omega}_x} \\\\         0 \\\\         0     \\end{bmatrix}     &amp;=      \\begin{bmatrix}         I_{xx} &amp; 0 &amp; 0 \\\\         0 &amp; I_{yy} &amp; 0 \\\\         0 &amp; 0 &amp; I_{zz}     \\end{bmatrix}^{-1}     \\begin{bmatrix}         {\\color{#65DD18}\\tau_x} \\\\         0 \\\\         0     \\end{bmatrix} \\\\     \\begin{bmatrix}         {\\color{magenta}\\dot{\\omega}_x} \\\\         0 \\\\         0     \\end{bmatrix}     &amp;=      \\begin{bmatrix}         \\frac{1}{I_{xx}} &amp; 0 &amp; 0 \\\\         0 &amp; \\frac{1}{I_{yy}} &amp; 0 \\\\         0 &amp; 0 &amp; \\frac{1}{I_{zz}}     \\end{bmatrix}     \\begin{bmatrix}         {\\color{#65DD18}\\tau_x} \\\\         0 \\\\         0     \\end{bmatrix} \\\\     \\begin{bmatrix}         {\\color{magenta}\\dot{\\omega}_x} \\\\         0 \\\\         0     \\end{bmatrix}     &amp;=      \\begin{bmatrix}         \\frac{1}{I_{xx}} {\\color{#65DD18}\\tau_x} \\\\         0 \\\\         0     \\end{bmatrix} \\end{align*} \\] <p>Se juntarmos as equa\u00e7\u00f5es cin\u00e9ticas e cinem\u00e1ticas, obtemos a din\u00e2mica completa do sistema:</p> \\[ \\left\\{ \\begin{array}{l}     {\\color{magenta}\\dot{y}} = {\\color{magenta}v_y} \\\\      {\\color{magenta}\\dot{z}} = {\\color{magenta}v_z} \\\\     {\\color{magenta}\\dot{\\phi}} = {\\color{magenta}\\omega_x} \\\\      {\\color{magenta}\\dot{v}_y} = - \\frac{1}{m} \\sin {\\color{magenta}\\phi} {\\color{#65DD18}f_t} \\\\      {\\color{magenta}\\dot{v}_z} = -g + \\frac{1}{m} \\cos {\\color{magenta}\\phi} {\\color{#65DD18}f_t} \\\\      {\\color{magenta}\\dot{\\omega}_x} = \\frac{1}{I_{xx}} {\\color{#65DD18}\\tau_x} \\end{array} \\right. \\] <p>Note que as equa\u00e7\u00f5es acima s\u00e3o exatamente iguais \u00e0s obtidas utilizando a nota\u00e7\u00e3o escalar. </p>"},{"location":"pages/modeling/2d_model/#sistema-movel_1","title":"Sistema m\u00f3vel","text":"<p>N\u00e3o podemos aplicar a 2\u00aa lei de Newton no sistema de coordenadas m\u00f3vel pois ele n\u00e3o \u00e9 um sistema de coordenadas inercial(1):</p> <ol> <li>Que n\u00e3o acelera ou rotaciona.</li> </ol> \\[ \\xcancel{ \\left\\{ \\begin{array}{l}         \\sum {\\color{cyan}\\vec{f}\\,'} = \\frac{d}{dt} {\\color{cyan}\\vec{p}\\,'} \\\\          \\sum {\\color{cyan}\\vec{\\tau}\\,'} = \\frac{d}{dt} {\\color{cyan}\\vec{h}\\,'} \\end{array} \\right. } \\] <p>No entanto, \u00e9 poss\u00edvel aplicar ela no sistema de coordenadas inercial e efetuar algumas transforma\u00e7\u00f5es para o sistema de coordenadas m\u00f3vel.</p> <p>Exerc\u00edcio 8</p> <p>Exerc\u00edcio 9</p> <p>Determine as equa\u00e7\u00f5es cin\u00e9ticas vetoriais, isto \u00e9, as equa\u00e7\u00f5es das derivadas dos vetores de velocidades (\\({\\color{cyan}\\dot{\\vec{v}}\\,'}\\) e \\({\\color{cyan}\\dot{\\vec{\\omega}}\\,'}\\)) em fun\u00e7\u00e3o das somat\u00f3rias de for\u00e7as e torques(1).</p> <ol> <li> <p>O produto vetorial \\({\\color{cyan}\\vec{\\omega}\\,'} \\times\\):</p> \\[ \\begin{align}     {\\color{cyan}\\vec{\\omega}\\,'} \\times \\vec{v} &amp;=      \\begin{bmatrix}     {\\color{cyan}\\omega_x\\,'} \\\\     0 \\\\     0     \\end{bmatrix}      \\times     \\begin{bmatrix}     v_1 \\\\     v_2 \\\\     v_3     \\end{bmatrix} \\\\     {\\color{cyan}\\vec{\\omega}\\,'} \\times \\vec{v} &amp;=      \\begin{bmatrix}     0 \\\\     - {\\color{cyan}\\omega_x\\,'} v_3 \\\\     {\\color{cyan}\\omega_x\\,'} v_2      \\end{bmatrix} \\end{align} \\] <p>Tamb\u00e9m pode ser representado pelo produto de uma matriz anti-sim\u00e9trica \\({\\color{cyan}\\tilde{\\omega}\\,'}\\):</p> \\[ \\begin{align}     {\\color{cyan}\\tilde{\\omega}\\,'} \\vec{v} &amp;=      \\begin{bmatrix}         0 &amp; 0 &amp; 0 \\\\         0 &amp; 0 &amp; -{\\color{cyan}\\omega_x\\,'} \\\\         0 &amp; {\\color{cyan}\\omega_x\\,'} &amp; 0     \\end{bmatrix}       \\begin{bmatrix}     v_1 \\\\     v_2 \\\\     v_3     \\end{bmatrix} \\\\     {\\color{cyan}\\tilde{\\omega}\\,'} \\vec{v} &amp;=      \\begin{bmatrix}     0 \\\\     - {\\color{cyan}\\omega_x\\,'} v_3 \\\\     {\\color{cyan}\\omega_x\\,'} v_2      \\end{bmatrix} \\end{align} \\] <p>Se expandirmos o termo \\(R \\dot{R}^T\\):</p> \\[ \\begin{align}     R \\dot{R}^T &amp;=      \\begin{bmatrix}         1 &amp; 0 &amp; 0 \\\\         0 &amp; \\cos{\\color{magenta}\\phi} &amp; \\sin{\\color{magenta}\\phi} \\\\         0 &amp; -\\sin{\\color{magenta}\\phi} &amp; \\cos{\\color{magenta}\\phi}     \\end{bmatrix}        {     \\left(     \\frac{d}{dt}     \\begin{bmatrix}         1 &amp; 0 &amp; 0 \\\\         0 &amp; \\cos{\\color{magenta}\\phi} &amp; \\sin{\\color{magenta}\\phi} \\\\         0 &amp; -\\sin{\\color{magenta}\\phi} &amp; \\cos{\\color{magenta}\\phi}     \\end{bmatrix}      \\right)     }^{T} \\\\     R \\dot{R}^T &amp;=      \\begin{bmatrix}         1 &amp; 0 &amp; 0 \\\\         0 &amp; \\cos{\\color{magenta}\\phi} &amp; \\sin{\\color{magenta}\\phi} \\\\         0 &amp; -\\sin{\\color{magenta}\\phi} &amp; \\cos{\\color{magenta}\\phi}     \\end{bmatrix}        {     \\begin{bmatrix}         0 &amp; 0 &amp; 0 \\\\         0 &amp; -\\sin{\\color{magenta}\\phi}{\\color{cyan}\\omega_x\\,'} &amp; \\cos{\\color{magenta}\\phi}{\\color{cyan}\\omega_x\\,'} \\\\         0 &amp; -\\cos{\\color{magenta}\\phi}{\\color{cyan}\\omega_x\\,'} &amp; -\\sin{\\color{magenta}\\phi}{\\color{cyan}\\omega_x\\,'}     \\end{bmatrix}      }^{T} \\\\     R \\dot{R}^T &amp;=      \\begin{bmatrix}         1 &amp; 0 &amp; 0 \\\\         0 &amp; \\cos{\\color{magenta}\\phi} &amp; \\sin{\\color{magenta}\\phi} \\\\         0 &amp; -\\sin{\\color{magenta}\\phi} &amp; \\cos{\\color{magenta}\\phi}     \\end{bmatrix}        \\begin{bmatrix}         0 &amp; 0 &amp; 0 \\\\         0 &amp; -\\sin{\\color{magenta}\\phi}{\\color{cyan}\\omega_x\\,'} &amp; -\\cos{\\color{magenta}\\phi}{\\color{cyan}\\omega_x\\,'} \\\\         0 &amp; \\cos{\\color{magenta}\\phi}{\\color{cyan}\\omega_x\\,'} &amp; -\\sin{\\color{magenta}\\phi}{\\color{cyan}\\omega_x\\,'}     \\end{bmatrix} \\\\     R \\dot{R}^T &amp;=      \\begin{bmatrix}         0 &amp; 0 &amp; 0 \\\\         0 &amp; -\\cancel{\\cos{\\color{magenta}\\phi}\\sin{\\color{magenta}\\phi}{\\color{cyan}\\omega_x\\,'}} + \\cancel{\\sin{\\color{magenta}\\phi}\\cos{\\color{magenta}\\phi}{\\color{cyan}\\omega_x\\,'}} &amp; -\\cos^2{\\color{magenta}\\phi}{\\color{cyan}\\omega_x\\,'} -\\sin^2{\\color{magenta}\\phi}{\\color{cyan}\\omega_x\\,'}\\\\         0 &amp; \\sin^2{\\color{magenta}\\phi}{\\color{cyan}\\omega_x\\,'} + \\cos^2{\\color{magenta}\\phi}{\\color{cyan}\\omega_x\\,'} &amp; \\cancel{\\sin{\\color{magenta}\\phi}\\cos{\\color{magenta}\\phi}{\\color{cyan}\\omega_x\\,'}} - \\cancel{\\cos{\\color{magenta}\\phi}\\sin{\\color{magenta}\\phi}{\\color{cyan}\\omega_x\\,'}}     \\end{bmatrix}  \\\\     R \\dot{R}^T &amp;=      \\begin{bmatrix}         0 &amp; 0 &amp; 0 \\\\         0 &amp; 0 &amp; -{\\color{cyan}\\omega_x\\,'} \\cancelto{1}{\\left(\\cos^2{\\color{magenta}\\phi} + \\sin^2{\\color{magenta}\\phi} \\right)} \\\\         0 &amp; {\\color{cyan}\\omega_x\\,'} \\cancelto{1}{\\left(\\sin^2{\\color{magenta}\\phi} + \\cos^2{\\color{magenta}\\phi} \\right)} &amp; 0     \\end{bmatrix} \\\\     R \\dot{R}^T &amp;=      \\begin{bmatrix}         0 &amp; 0 &amp; 0 \\\\         0 &amp; 0 &amp; -{\\color{cyan}\\omega_x\\,'} \\\\         0 &amp; {\\color{cyan}\\omega_x\\,'} &amp; 0     \\end{bmatrix}  \\end{align} \\] <p>Concluimos que \\(R \\dot{R}^T = {\\color{cyan}\\vec{\\omega}\\,'} \\times\\).</p> </li> </ol> a) Escreva \\({\\color{cyan}\\dot{\\vec{v}}\\,'}\\) em fun\u00e7\u00e3o de \\(\\sum{\\color{cyan}\\vec{f}\\,'}\\). \\[ \\begin{align*}     \\sum {\\color{magenta}\\vec{f}} &amp;= \\frac{d}{dt} {\\color{magenta}\\vec{p}} \\\\     \\sum {\\color{magenta}\\vec{f}} &amp;= \\frac{d}{dt} \\left( R^T {\\color{cyan}\\vec{p}\\,'} \\right) \\\\     \\sum {\\color{magenta}\\vec{f}} &amp;= \\dot{R}^T {\\color{cyan}\\vec{p}\\,'} + R^T {\\color{cyan}\\dot{\\vec{p}}\\,'} \\\\     R \\sum {\\color{magenta}\\vec{f}} &amp;= R \\dot{R}^T {\\color{cyan}\\vec{p}\\,'} + \\cancel{R R^T} {\\color{cyan}\\dot{\\vec{p}}\\,'} \\\\     \\sum R {\\color{magenta}\\vec{f}} &amp;= {\\color{cyan}\\vec{\\omega}\\,'} \\times {\\color{cyan}\\vec{p}\\,'} + {\\color{cyan}\\dot{\\vec{p}}\\,'} \\\\     \\sum {\\color{cyan}\\vec{f}\\,'} &amp;= {\\color{cyan}\\vec{\\omega}\\,'} \\times m {\\color{cyan}\\vec{v}\\,'} + m {\\color{cyan}\\dot{\\vec{v}}\\,'} \\\\     {\\color{cyan}\\dot{\\vec{v}}\\,'} &amp;= - {\\color{cyan}\\vec{\\omega}\\,'} \\times {\\color{cyan}\\vec{v}\\,'} + \\frac{1}{m} \\sum {\\color{cyan}\\vec{f}\\,'} \\end{align*}  \\] b) Escreva \\({\\color{cyan}\\dot{\\vec{\\omega}}\\,'}\\) em fun\u00e7\u00e3o de \\(\\sum{\\color{cyan}\\vec{\\tau}\\,'}\\). \\[ \\begin{align*}     \\sum {\\color{magenta}\\vec{\\tau}} &amp;= \\frac{d}{dt} {\\color{magenta}\\vec{h}} \\\\     \\sum {\\color{magenta}\\vec{\\tau}} &amp;= \\frac{d}{dt} \\left( R^T {\\color{cyan}\\vec{h}\\,'} \\right) \\\\     \\sum {\\color{magenta}\\vec{\\tau}} &amp;= \\dot{R}^T {\\color{cyan}\\vec{h}\\,'} + R^T {\\color{cyan}\\dot{\\vec{h}}\\,'} \\\\     R \\sum {\\color{magenta}\\vec{\\tau}} &amp;= R \\dot{R}^T {\\color{cyan}\\vec{h}\\,'} + \\cancel{R R^T} {\\color{cyan}\\dot{\\vec{h}}\\,'} \\\\     \\sum R {\\color{magenta}\\vec{\\tau}} &amp;= {\\color{cyan}\\vec{\\omega}\\,'} \\times {\\color{cyan}\\vec{h}\\,'} + {\\color{cyan}\\dot{\\vec{h}}\\,'} \\\\     \\sum {\\color{cyan}\\vec{\\tau}\\,'} &amp;= {\\color{cyan}\\vec{\\omega}\\,'} \\times I {\\color{cyan}\\vec{\\omega}\\,'} + I {\\color{cyan}\\dot{\\vec{\\omega}}\\,'} \\\\     {\\color{cyan}\\dot{\\vec{\\omega}}\\,'} &amp;= - I^{-1} \\left( {\\color{cyan}\\vec{\\omega}\\,'} \\times I {\\color{cyan}\\vec{\\omega}\\,'} \\right) + I^{-1} \\sum {\\color{cyan}\\vec{\\tau}\\,'} \\end{align*} \\] <p>Voc\u00ea deve ter chegado a:</p> \\[ \\left\\{ \\begin{array}{l}         {\\color{cyan}\\dot{\\vec{v}}\\,'} = - {\\color{cyan}\\vec{\\omega}\\,'} \\times {\\color{cyan}\\vec{v}\\,'} + \\frac{1}{m} \\sum {\\color{cyan}\\vec{f}\\,'} \\\\          {\\color{cyan}\\dot{\\vec{\\omega}}\\,'} = - I^{-1} \\left( {\\color{cyan}\\vec{\\omega}\\,'} \\times I {\\color{cyan}\\vec{\\omega}\\,'} \\right) + I^{-1} \\sum {\\color{cyan}\\vec{\\tau}\\,'} \\end{array} \\right. \\] <p>Essas equa\u00e7\u00f5es s\u00e3o gen\u00e9ricas, ou seja, valem pro movimento de transla\u00e7\u00e3o e rota\u00e7\u00e3o de qualquer corpo r\u00edgido em qualquer sistema de coordenadas (seja ele inercial ou n\u00e3o), basta substituir o valor das somat\u00f3rias de for\u00e7as e torques. </p> <p>Elas tamb\u00e9m s\u00e3o chamadas de equa\u00e7\u00f5es de Newton-Euler, que foi quem generalizou a 2\u00aa lei de Newton de um ponto material em um sistema de coordenadas inercial para um corpo r\u00edgido em um sistema de coordenadas n\u00e3o inercial.</p> <p>Exerc\u00edcio 10</p> <p>Substitua as somat\u00f3rias de for\u00e7as e torques definidos inicialmente e determine as equa\u00e7\u00f5es cin\u00e9ticas.</p> <p>Dica: cuidado com os sistemas de coordenadas em que eles est\u00e3o descritos.</p> a) Escreva \\({\\color{cyan}\\dot{\\vec{v}}\\,'}\\) em fun\u00e7\u00e3o dos estados do sistema. \\[ \\begin{align*}     {\\color{cyan}\\dot{\\vec{v}}\\,'} &amp;= - {\\color{cyan}\\vec{\\omega}\\,'} \\times {\\color{cyan}\\vec{v}\\,'} + \\frac{1}{m} \\sum {\\color{cyan}\\vec{f}\\,'} \\\\      {\\color{cyan}\\dot{\\vec{v}}\\,'} &amp;= - {\\color{cyan}\\vec{\\omega}\\,'} \\times {\\color{cyan}\\vec{v}\\,'} + \\frac{1}{m} \\left( - m {\\color{cyan}\\vec{g}\\,'} + {\\color{cyan}\\vec{f}\\,'} \\right) \\\\     {\\color{cyan}\\dot{\\vec{v}}\\,'} &amp;= - {\\color{cyan}\\vec{\\omega}\\,'} \\times {\\color{cyan}\\vec{v}\\,'} - R {\\color{magenta}\\vec{g}} + \\frac{1}{m} {\\color{cyan}\\vec{f}\\,'} \\\\      \\begin{bmatrix}         0 \\\\         {\\color{cyan}\\dot{v}_y\\,'} \\\\         {\\color{cyan}\\dot{v}_z\\,'}     \\end{bmatrix}     &amp;=     -     \\begin{bmatrix}         {\\color{cyan}\\omega_x\\,'} \\\\         0 \\\\         0     \\end{bmatrix}     \\times     \\begin{bmatrix}         0 \\\\         {\\color{cyan}v_y\\,'} \\\\         {\\color{cyan}v_z\\,'}     \\end{bmatrix}     -     \\begin{bmatrix}         1 &amp; 0 &amp; 0 \\\\         0 &amp; \\cos{\\color{magenta}\\phi} &amp; \\sin{\\color{magenta}\\phi} \\\\         0 &amp; -\\sin{\\color{magenta}\\phi} &amp; \\cos{\\color{magenta}\\phi}     \\end{bmatrix}     \\begin{bmatrix}         0 \\\\         0 \\\\         g     \\end{bmatrix}     + \\frac{1}{m}     \\begin{bmatrix}         0 \\\\         0 \\\\         {\\color{#65DD18}f_t}     \\end{bmatrix} \\\\     \\begin{bmatrix}         0 \\\\         {\\color{cyan}\\dot{v}_y\\,'} \\\\         {\\color{cyan}\\dot{v}_z\\,'}     \\end{bmatrix}     &amp;=     \\begin{bmatrix}         0 \\\\         {\\color{cyan}\\omega_x\\,' v_z\\,'} - g \\sin{\\color{magenta}\\phi} \\\\         -{\\color{cyan}\\omega_x\\,' v_y\\,'} - g \\cos{\\color{magenta}\\phi} + \\frac{1}{m} {\\color{#65DD18}f_t}     \\end{bmatrix} \\end{align*}   \\] b) Escreva \\({\\color{cyan}\\dot{\\vec{\\omega}}\\,'}\\) em fun\u00e7\u00e3o dos estados do sistema. \\[ \\begin{align*}     {\\color{cyan}\\dot{\\vec{\\omega}}\\,'} &amp;= - I^{-1} \\left( {\\color{cyan}\\omega\\,'} \\times I {\\color{cyan}\\vec{\\omega}\\,'} \\right) + I^{-1} \\sum {\\color{cyan}\\vec{\\tau}\\,'} \\\\      {\\color{cyan}\\dot{\\vec{\\omega}}\\,'} &amp;= - I^{-1} \\left( {\\color{cyan}\\omega\\,'} \\times I {\\color{cyan}\\vec{\\omega}\\,'} \\right) + I^{-1} {\\color{cyan}\\vec{\\tau}_x\\,'} \\\\      \\begin{bmatrix}         {\\color{cyan}\\dot{\\omega}_x\\,'} \\\\         0 \\\\         0     \\end{bmatrix}     &amp;= -     \\begin{bmatrix}         I_{xx} &amp; 0 &amp; 0 \\\\         0 &amp; I_{yy} &amp; 0 \\\\         0 &amp; 0 &amp; I_{zz}     \\end{bmatrix}^{-1}     \\left(      \\begin{bmatrix}         {\\color{cyan}\\omega_x\\,'} \\\\         0 \\\\         0     \\end{bmatrix}     \\times     \\begin{bmatrix}         I_{xx} &amp; 0 &amp; 0 \\\\         0 &amp; I_{yy} &amp; 0 \\\\         0 &amp; 0 &amp; I_{zz}     \\end{bmatrix}     \\begin{bmatrix}         {\\color{cyan}\\omega_x\\,'} \\\\         0 \\\\         0     \\end{bmatrix}     \\right)     +     \\begin{bmatrix}         I_{xx} &amp; 0 &amp; 0 \\\\         0 &amp; I_{yy} &amp; 0 \\\\         0 &amp; 0 &amp; I_{zz}     \\end{bmatrix}^{-1}     \\begin{bmatrix}         {\\color{#65DD18}\\tau_x} \\\\         0 \\\\         0     \\end{bmatrix} \\\\     \\begin{bmatrix}         {\\color{cyan}\\dot{\\omega}_x\\,'} \\\\         0 \\\\         0     \\end{bmatrix}     &amp;= -     \\begin{bmatrix}         \\frac{1}{I_{xx}} &amp; 0 &amp; 0 \\\\         0 &amp; \\frac{1}{I_{yy}} &amp; 0 \\\\         0 &amp; 0 &amp; \\frac{1}{I_{zz}}     \\end{bmatrix}     \\left(      \\begin{bmatrix}         {\\color{cyan}\\omega_x\\,'} \\\\         0 \\\\         0     \\end{bmatrix}     \\times     \\begin{bmatrix}         I_{xx} {\\color{cyan}\\omega_x\\,'} \\\\         0 \\\\         0     \\end{bmatrix}     \\right)     +     \\begin{bmatrix}         \\frac{1}{I_{xx}} &amp; 0 &amp; 0 \\\\         0 &amp; \\frac{1}{I_{yy}} &amp; 0 \\\\         0 &amp; 0 &amp; \\frac{1}{I_{zz}}     \\end{bmatrix}     \\begin{bmatrix}         {\\color{#65DD18}\\tau_x} \\\\         0 \\\\         0     \\end{bmatrix} \\\\     \\begin{bmatrix}         {\\color{cyan}\\dot{\\omega}_x\\,'} \\\\         0 \\\\         0     \\end{bmatrix}     &amp;=      \\begin{bmatrix}         \\frac{1}{I_{xx}} {\\color{#65DD18}\\tau_x} \\\\         0 \\\\         0     \\end{bmatrix} \\end{align*} \\] <p>Se juntarmos as equa\u00e7\u00f5es cin\u00e9ticas e cinem\u00e1ticas, obtemos a din\u00e2mica completa do sistema:</p> \\[ \\left\\{ \\begin{array}{l}     {\\color{magenta}\\dot{y}} =  {\\color{cyan}v_y\\,'} \\cos {\\color{magenta}\\phi} -  {\\color{cyan}v_z\\,'} \\sin {\\color{magenta}\\phi} \\\\      {\\color{magenta}\\dot{z}} =  {\\color{cyan}v_y\\,'} \\sin {\\color{magenta}\\phi} +  {\\color{cyan}v_z\\,'} \\cos {\\color{magenta}\\phi} \\\\     {\\color{magenta}\\dot{\\phi}} =  {\\color{cyan}\\omega_x\\,'} \\\\      {\\color{cyan}\\dot{v}_y\\,'} = {\\color{cyan}v_z\\,' \\omega_x\\,'} - g \\sin {\\color{magenta}\\phi} \\\\      {\\color{cyan}\\dot{v}_z\\,'} = - {\\color{cyan}v_y\\,' \\omega_x\\,'} - g \\cos {\\color{magenta}\\phi} + \\frac{1}{m} {\\color{#65DD18}f_t} \\\\      {\\color{cyan}\\dot{\\omega}_x\\,'} = \\frac{1}{I_{xx}} {\\color{#65DD18}\\tau_x} \\end{array} \\right. \\] <p>Note que as equa\u00e7\u00f5es acima s\u00e3o exatamente iguais \u00e0s obtidas utilizando a nota\u00e7\u00e3o escalar. </p>"},{"location":"pages/modeling/2d_model/#linearizacao","title":"Lineariza\u00e7\u00e3o","text":"<p>O sistema obtido \u00e9 n\u00e3o-linear. Para lineariz\u00e1-lo, podemos considerar aproxima\u00e7\u00f5es quando os estados est\u00e3o bem pr\u00f3ximos de suas posi\u00e7\u00f5es de equil\u00edbrio. Neste caso, fun\u00e7\u00f5es trigonom\u00e9tricas podem ser aproximadas (ex: \\(\\cos{\\color{magenta}\\phi} \\approx 1\\) e \\(\\sin{\\color{magenta}\\phi} \\approx {\\color{magenta}\\phi}\\)) (1), assim como o produto entre dois estados (ex: \\({\\color{cyan}v_z\\,' \\omega_x\\,'} \\approx 0\\)).</p> <ol> <li>Essas aproxima\u00e7\u00f5es valem apenas para \u00e2ngulos em radianos menores que \\(10^{\\circ}\\).</li> </ol> <p>Exerc\u00edcio 11</p> <p>Determine as equa\u00e7\u00f5es din\u00e2micas do sistema linearizado.</p> Resposta \\[ \\left\\{ \\begin{array}{l}     {\\color{magenta}\\dot{y}} =  {\\color{cyan}v_y\\,'} \\cancelto{1}{\\cos {\\color{magenta}\\phi}} -  {\\color{cyan}v_z\\,'} \\cancelto{{\\color{magenta}\\phi}}{\\sin {\\color{magenta}\\phi}} \\\\      {\\color{magenta}\\dot{z}} =  {\\color{cyan}v_y\\,'} \\cancelto{{\\color{magenta}\\phi}}{\\sin {\\color{magenta}\\phi}} +  {\\color{cyan}v_z\\,'} \\cancelto{1}{\\cos {\\color{magenta}\\phi}} \\\\     {\\color{magenta}\\dot{\\phi}} =  {\\color{cyan}\\omega_x\\,'} \\\\      {\\color{cyan}\\dot{v}_y\\,'} = \\cancelto{0}{\\color{cyan}v_z\\,' \\omega_x\\,'} - g \\cancelto{{\\color{magenta}\\phi}}{\\sin {\\color{magenta}\\phi}} \\\\      {\\color{cyan}\\dot{v}_z\\,'} = - \\cancelto{0}{\\color{cyan}v_y\\,' \\omega_x\\,'} - g \\cancelto{1}{\\cos {\\color{magenta}\\phi}} + \\frac{1}{m} {\\color{#65DD18}f_t} \\\\      {\\color{cyan}\\dot{\\omega}_x\\,'} = \\frac{1}{I_{xx}} {\\color{#65DD18}\\tau_x} \\end{array} \\right. \\qquad \\longrightarrow \\qquad \\left\\{ \\begin{array}{l}     {\\color{magenta}\\dot{y}} =  {\\color{cyan}v_y\\,'} - \\cancelto{0}{{\\color{cyan}v_z\\,'} {\\color{magenta}\\phi}} \\\\     {\\color{magenta}\\dot{z}} =  \\cancelto{0}{{\\color{cyan}v_y\\,'} {\\color{magenta}\\phi}} + {\\color{cyan}v_z\\,'} \\\\     {\\color{magenta}\\dot{\\phi}} =  {\\color{cyan}\\omega_x\\,'} \\\\      {\\color{cyan}\\dot{v}_y\\,'} = - g {\\color{magenta}\\phi} \\\\      {\\color{cyan}\\dot{v}_z\\,'} = -g + \\frac{1}{m} {\\color{#65DD18}f_t} \\\\      {\\color{cyan}\\dot{\\omega}_x\\,'} = \\frac{1}{I_{xx}} {\\color{#65DD18}\\tau_x} \\end{array} \\right. \\qquad \\longrightarrow \\qquad \\left\\{ \\begin{array}{l}     {\\color{magenta}\\dot{y}} =  {\\color{cyan}v_y\\,'} \\\\     {\\color{magenta}\\dot{z}} =  {\\color{cyan}v_z\\,'} \\\\     {\\color{magenta}\\dot{\\phi}} =  {\\color{cyan}\\omega_x\\,'} \\\\      {\\color{cyan}\\dot{v}_y\\,'} = - g {\\color{magenta}\\phi} \\\\      {\\color{cyan}\\dot{v}_z\\,'} = -g + \\frac{1}{m} {\\color{#65DD18}f_t} \\\\      {\\color{cyan}\\dot{\\omega}_x\\,'} = \\frac{1}{I_{xx}} {\\color{#65DD18}\\tau_x} \\end{array} \\right. \\] <p>Voc\u00ea deve ter chegado a:</p> \\[ \\left\\{ \\begin{array}{l}     {\\color{magenta}\\dot{y}} =  {\\color{cyan}v_y\\,'} \\\\     {\\color{magenta}\\dot{z}} =  {\\color{cyan}v_z\\,'} \\\\     {\\color{magenta}\\dot{\\phi}} =  {\\color{cyan}\\omega_x\\,'} \\\\      {\\color{cyan}\\dot{v}_y\\,'} = - g {\\color{magenta}\\phi} \\\\      {\\color{cyan}\\dot{v}_z\\,'} = -g + \\frac{1}{m} {\\color{#65DD18}f_t} \\\\      {\\color{cyan}\\dot{\\omega}_x\\,'} = \\frac{1}{I_{xx}} {\\color{#65DD18}\\tau_x} \\end{array} \\right.     \\] <p>Apesar lembrar as equa\u00e7\u00f5es diferenciais obtidas no sistema de coordenadas inercial, ela possui uma diferen\u00e7a muito importante, que aparece exatamente na din\u00e2mica horizontal: a acelera\u00e7\u00e3o \\({\\color{cyan}\\dot{v}_y\\,'}\\) n\u00e3o depende da for\u00e7a \\({\\color{#65DD18}f_t}\\) mas sim do \u00e2ngulo \\({\\color{magenta}\\phi}\\).</p> <p>Isso fica evidente ao representarmos as equa\u00e7\u00f5es diferenciais em um diagrama de blocos:</p> <p></p> <p>Observe o seguinte:</p> <ul> <li>A for\u00e7a \\({\\color{#65DD18}f_t}\\) integra duas vezes at\u00e9 a posi\u00e7\u00e3o \\({\\color{magenta}z}\\) (2\u00aa lei de Newton para transla\u00e7\u00e3o), atuando de forma desacoplada na din\u00e2mica de posi\u00e7\u00e3o vertical.</li> <li>O torque \\({\\color{#65DD18}\\tau_x}\\) integra duas vezes at\u00e9 o \u00e2ngulo \\({\\color{magenta}\\phi}\\) (2\u00aa lei de Newton para rota\u00e7\u00e3o), e, integrando mais duas vezes, chega-se a posi\u00e7\u00e3o \\({\\color{magenta}y}\\). </li> <li>Portanto, de \\({\\color{#65DD18}\\tau_x}\\) a \\({\\color{magenta}y}\\) h\u00e1 um integrador qu\u00e1druplo, resultado do acoplamento entre a din\u00e2mica de rota\u00e7\u00e3o e a din\u00e2mica de posi\u00e7\u00e3o horizontal. </li> <li>O sinal negativo em \\(- g\\) decorre da conven\u00e7\u00e3o de eixos adotada (uma rota\u00e7\u00e3o positiva em torqno de \\({\\color{magenta}x}\\) implica em um deslocamento negativo ao longo de \\({\\color{magenta}y}\\)).</li> </ul>"},{"location":"pages/modeling/3d_model/","title":"Modelo 3D","text":"<p>Agora, vamos deduzir as equa\u00e7\u00f5es diferenciais que descrevem a din\u00e2mica 3D de um quadric\u00f3ptero. Neste modelo completo, o drone pode se mover e girar livremente no espa\u00e7o, o que traz toda a riqueza \u2014 e tamb\u00e9m a dificuldade \u2014 do problema. Para represent\u00e1-lo, ser\u00e1 necess\u00e1rio recorrer \u00e0 \u00e1lgebra vetorial e \u00e0s matrizes de rota\u00e7\u00e3o, que permitem descrever posi\u00e7\u00f5es, velocidades e orienta\u00e7\u00f5es em tr\u00eas dimens\u00f5es.</p>"},{"location":"pages/modeling/3d_model/#introducao","title":"Introdu\u00e7\u00e3o","text":"<p>A din\u00e2mica 3D possui 6 graus de liberdade (3 de transla\u00e7\u00e3o e 3 de rota\u00e7\u00e3o) e, portanto, devemos obter 12 equa\u00e7\u00f5es diferenciais (2 para cada grau de liberdade).</p> <p></p> <p>\u00c9 muito mais f\u00e1cil trabalhar com a nota\u00e7\u00e3o vetorial e aplicar as equa\u00e7\u00f5es de Newton-Euler 2 vezes (uma para transla\u00e7\u00e3o e outra para rota\u00e7\u00e3o) do que 6 vezes com a nota\u00e7\u00e3o escalar (uma para cada grau de liberdade).</p> <p>As posi\u00e7\u00f5es e \u00e2ngulos ser\u00e3o descritos no sistema de coordenadas inercial, j\u00e1 as velocidades lineares e angulares no sistema de coordenadas m\u00f3vel. Dessa forma, os vetores de estados do nosso sistema ser\u00e3o \\({\\color{magenta}\\vec{r}}\\), \\({\\color{magenta}\\vec{\\delta}}\\), \\({\\color{cyan}{\\vec{v}}\\,'}\\) e \\({\\color{cyan}{\\vec{\\omega}}\\,'}\\), onde:</p> \\[ {\\color{magenta}\\vec{r}} = \\begin{bmatrix}     {\\color{magenta}x} \\\\     {\\color{magenta}y} \\\\     {\\color{magenta}z} \\\\ \\end{bmatrix} \\qquad {\\color{magenta}\\vec{\\delta}} = \\begin{bmatrix}     {\\color{magenta}\\phi} \\\\     {\\color{magenta}\\theta} \\\\     {\\color{magenta}\\psi} \\\\ \\end{bmatrix} \\qquad {\\color{cyan}{\\vec{v}}\\,'} = \\begin{bmatrix}     {\\color{cyan}v_x\\,'} \\\\     {\\color{cyan}v_y\\,'} \\\\     {\\color{cyan}v_z\\,'} \\\\ \\end{bmatrix} \\qquad {\\color{cyan}{\\vec{\\omega}}\\,'} = \\begin{bmatrix}     {\\color{cyan}\\omega_x\\,'} \\\\     {\\color{cyan}\\omega_y\\,'} \\\\     {\\color{cyan}\\omega_z\\,'} \\\\ \\end{bmatrix} \\qquad \\]"},{"location":"pages/modeling/3d_model/#cinematica","title":"Cinem\u00e1tica","text":"<p>J\u00e1 deduzimos a matriz de rota\u00e7\u00e3o utilizando os \u00e2ngulos de Euler:</p> \\[ \\begin{bmatrix}     {\\color{magenta}x} \\\\     {\\color{magenta}y} \\\\     {\\color{magenta}z} \\\\ \\end{bmatrix} = \\underbrace{ \\begin{bmatrix}     \\cos{\\color{magenta}\\theta}\\cos{\\color{magenta}\\psi} &amp; \\cos{\\color{magenta}\\theta}\\sin{\\color{magenta}\\psi} &amp; -\\sin{\\color{magenta}\\theta} \\\\      \\sin{\\color{magenta}\\phi}\\sin{\\color{magenta}\\theta}\\cos{\\color{magenta}\\psi} - \\cos{\\color{magenta}\\phi}\\sin{\\color{magenta}\\psi} &amp; \\sin{\\color{magenta}\\phi}\\sin{\\color{magenta}\\theta}\\sin{\\color{magenta}\\psi} + \\cos{\\color{magenta}\\phi}\\cos{\\color{magenta}\\psi} &amp; \\sin{\\color{magenta}\\phi}\\cos{\\color{magenta}\\theta} \\\\      \\cos{\\color{magenta}\\phi}\\sin{\\color{magenta}\\theta}\\cos{\\color{magenta}\\psi} + \\sin{\\color{magenta}\\phi}\\sin{\\color{magenta}\\psi} &amp; \\cos{\\color{magenta}\\phi}\\sin{\\color{magenta}\\theta}\\sin{\\color{magenta}\\psi} - \\sin{\\color{magenta}\\phi}\\cos{\\color{magenta}\\psi} &amp; \\cos{\\color{magenta}\\phi}\\cos{\\color{magenta}\\theta}  \\end{bmatrix} }_{R} \\begin{bmatrix}     {\\color{cyan}x\\,'} \\\\     {\\color{cyan}y\\,'} \\\\     {\\color{cyan}z\\,'} \\\\ \\end{bmatrix} \\]"},{"location":"pages/modeling/3d_model/#translacao","title":"Transla\u00e7\u00e3o","text":"<p>Exerc\u00edcio 1</p> <p>Determine \\({\\color{magenta}\\dot{\\vec{r}}}\\) em fun\u00e7\u00e3o dos estados do sistema.</p> Resposta \\[ \\begin{align*}     {\\color{magenta}\\dot{\\vec{r}}} &amp;= R^T {\\color{cyan}{\\vec{v}}\\,'} \\\\     \\begin{bmatrix}         {\\color{magenta}\\dot{x}} \\\\         {\\color{magenta}\\dot{y}} \\\\         {\\color{magenta}\\dot{z}} \\\\     \\end{bmatrix}     &amp;=     \\begin{bmatrix}         \\cos{\\color{magenta}\\theta}\\cos{\\color{magenta}\\psi} &amp; \\sin{\\color{magenta}\\phi}\\sin{\\color{magenta}\\theta}\\cos{\\color{magenta}\\psi} - \\cos{\\color{magenta}\\phi}\\sin{\\color{magenta}\\psi} &amp; \\cos{\\color{magenta}\\phi}\\sin{\\color{magenta}\\theta}\\cos{\\color{magenta}\\psi} + \\sin{\\color{magenta}\\phi}\\sin{\\color{magenta}\\psi} \\\\         \\cos{\\color{magenta}\\theta}\\sin{\\color{magenta}\\psi} &amp; \\sin{\\color{magenta}\\phi}\\sin{\\color{magenta}\\theta}\\sin{\\color{magenta}\\psi} + \\cos{\\color{magenta}\\phi}\\cos{\\color{magenta}\\psi} &amp; \\cos{\\color{magenta}\\phi}\\sin{\\color{magenta}\\theta}\\sin{\\color{magenta}\\psi} - \\sin{\\color{magenta}\\phi}\\cos{\\color{magenta}\\psi} \\\\         -\\sin{\\color{magenta}\\theta} &amp; \\sin{\\color{magenta}\\phi}\\cos{\\color{magenta}\\theta} &amp; \\cos{\\color{magenta}\\phi}\\cos{\\color{magenta}\\theta}     \\end{bmatrix}     \\begin{bmatrix}         {\\color{cyan}v_x\\,'} \\\\         {\\color{cyan}v_y\\,'} \\\\         {\\color{cyan}v_z\\,'} \\\\     \\end{bmatrix} \\\\     \\begin{bmatrix}         {\\color{magenta}\\dot{x}} \\\\         {\\color{magenta}\\dot{y}} \\\\         {\\color{magenta}\\dot{z}} \\\\     \\end{bmatrix}     &amp;=     \\begin{bmatrix}         {\\color{cyan}v_x\\,'} \\cos{\\color{magenta}\\theta}\\cos{\\color{magenta}\\psi} + {\\color{cyan}v_y\\,'} \\left( \\sin{\\color{magenta}\\phi}\\sin{\\color{magenta}\\theta}\\cos{\\color{magenta}\\psi} - \\cos{\\color{magenta}\\phi}\\sin{\\color{magenta}\\psi} \\right) + {\\color{cyan}v_z\\,'} \\left( \\cos{\\color{magenta}\\phi}\\sin{\\color{magenta}\\theta}\\cos{\\color{magenta}\\psi} + \\sin{\\color{magenta}\\phi}\\sin{\\color{magenta}\\psi} \\right) \\\\         {\\color{cyan}v_x\\,'} \\cos{\\color{magenta}\\theta}\\sin{\\color{magenta}\\psi} + {\\color{cyan}v_y\\,'} \\left( \\sin{\\color{magenta}\\phi}\\sin{\\color{magenta}\\theta}\\sin{\\color{magenta}\\psi} + \\cos{\\color{magenta}\\phi}\\cos{\\color{magenta}\\psi} \\right) + {\\color{cyan}v_z\\,'} \\left( \\cos{\\color{magenta}\\phi}\\sin{\\color{magenta}\\theta}\\sin{\\color{magenta}\\psi} - \\sin{\\color{magenta}\\phi}\\cos{\\color{magenta}\\psi} \\right) \\\\         - {\\color{cyan}v_x\\,'} \\sin{\\color{magenta}\\theta} + {\\color{cyan}v_y\\,'}  \\sin{\\color{magenta}\\phi}\\cos{\\color{magenta}\\theta} + {\\color{cyan}v_z\\,'}  \\cos{\\color{magenta}\\phi}\\cos{\\color{magenta}\\theta}     \\end{bmatrix} \\end{align*} \\]"},{"location":"pages/modeling/3d_model/#rotacao","title":"Rota\u00e7\u00e3o","text":"<p>Exerc\u00edcio 2</p> <p>Determine \\({\\color{magenta}\\dot{\\vec{\\delta}}}\\) em fun\u00e7\u00e3o dos estados do sistema.</p> Resposta <p>Suponhamos que o referencial m\u00f3vel esteja em movimento rotacional em torno da origem, cujo vetor velocidade angular \\({\\color{cyan}\\vec{\\omega}\\,'}\\) \u00e9 dado por:</p> \\[ {\\color{cyan}\\vec{\\omega}\\,'} =  \\begin{bmatrix}     {\\color{cyan}\\omega_x\\,'} \\\\     {\\color{cyan}\\omega_y\\,'} \\\\     {\\color{cyan}\\omega_z\\,'} \\end{bmatrix} \\] <p>Como o vetor \\({\\color{magenta}\\vec{r}}\\) \u00e9 fixo no sistema de coordenadas inercial, sua derivada temporal, vista pelo sistema inercial, \u00e9 nula:</p> \\[     {\\color{magenta}\\dot{\\vec{r}}} = \\vec{0} \\] <p>Por outro lado, sua derivada temporal, vista pelo sistema fixo ao corpo, depende do vetor velocidade angular do sistema fixo ao corpo(1):</p> <ol> <li>O sinal negativo aparece porque, se o sistema de coordenadas do corpo gira em uma dire\u00e7\u00e3o, o vetor ser\u00e1 visto pelo sistema fixo ao corpo como girando na dire\u00e7\u00e3o oposta.</li> </ol> \\[ {\\color{cyan}\\dot{\\vec{r}}\\,'} = -{\\color{cyan}\\vec{\\omega}\\,'}\\times{\\color{cyan}\\vec{r}\\,'} \\] <p>Outra forma de representar essa equa\u00e7\u00e3o \u00e9:</p> \\[ {\\color{cyan}\\dot{\\vec{r}}\\,'} = -{\\color{cyan}\\tilde{\\omega}\\,'}{\\color{cyan}\\vec{r}\\,'} \\] <p>Onde \\(\\tilde{\\omega},'\\) \u00e9 a velocidade angular representada como uma matriz antissim\u00e9trica correspondente ao seu produto vetorial:</p> \\[ {\\color{cyan}\\tilde{\\omega}\\,'} = {\\color{cyan}\\vec{\\omega}\\,'} \\times = \\begin{bmatrix}     0 &amp; -{\\color{cyan}\\omega_z\\,'} &amp; {\\color{cyan}\\omega_y\\,'} \\\\     {\\color{cyan}\\omega_z\\,'} &amp; 0 &amp; -{\\color{cyan}\\omega_x\\,'} \\\\     -{\\color{cyan}\\omega_y\\,'} &amp; {\\color{cyan}\\omega_x\\,'} &amp; 0 \\end{bmatrix} \\] <p>Diferenciando a equa\u00e7\u00e3o anterior e utilizando essa propriedade, obt\u00e9m-se:</p> \\[\\begin{align}     {\\color{cyan}\\dot{\\vec{r}}\\,'} &amp;= \\frac{d}{dt} \\left( {\\color{cyan}\\vec{r}\\,'} \\right) \\nonumber \\\\     {\\color{cyan}\\dot{\\vec{r}}\\,'} &amp;= \\frac{d}{dt} \\left( R {\\color{magenta}\\vec{r}} \\right) \\nonumber \\\\      {\\color{cyan}\\dot{\\vec{r}}\\,'} &amp;= \\dot{R}{\\color{magenta}\\vec{r}} + R \\cancelto{\\vec{0}}{{\\color{magenta}\\dot{\\vec{r}}}} \\nonumber \\\\      {\\color{cyan}\\dot{\\vec{r}}\\,'} &amp;= \\dot{R} \\left(R^T {\\color{cyan}\\vec{r}\\,'}\\right) \\nonumber \\\\      {\\color{cyan}\\dot{\\vec{r}}\\,'} &amp;= \\dot{R}R^T {\\color{cyan}\\vec{r}\\,'} \\end{align}\\] <p>Comparando essa equa\u00e7\u00e3o com a anterior, \u00e9 poss\u00edvel obter a matriz antissim\u00e9trica da velocidade angular em termos da matriz de rota\u00e7\u00e3o e sua derivada temporal:</p> \\[  {\\color{cyan}\\tilde{\\omega}\\,'} = -\\dot{R}R^T  \\] <p>Os \u00e2ngulos de Euler n\u00e3o s\u00e3o um vetor e n\u00e3o podem ser facilmente isolados. Entretanto, substituindo \\(R\\) e \\(\\dot{R}\\), as velocidades angulares podem ser escritas em fun\u00e7\u00e3o dos \u00e2ngulos de Euler e de suas derivadas temporais em nota\u00e7\u00e3o matricial:</p> \\[ \\begin{bmatrix}     {\\color{cyan}\\omega_x\\,'} \\\\     {\\color{cyan}\\omega_y\\,'} \\\\     {\\color{cyan}\\omega_z\\,'} \\end{bmatrix} =  \\begin{bmatrix}     1 &amp; 0 &amp; - \\sin{\\color{magenta}\\theta} \\\\     0 &amp; \\cos{\\color{magenta}\\phi} &amp; \\sin{\\color{magenta}\\phi}\\cos{\\color{magenta}\\theta} \\\\     0 &amp; -\\sin{\\color{magenta}\\phi} &amp; \\cos{\\color{magenta}\\phi}\\cos{\\color{magenta}\\theta} \\\\ \\end{bmatrix} \\begin{bmatrix}     {\\color{magenta}\\dot{\\phi}} \\\\     {\\color{magenta}\\dot{\\theta}} \\\\     {\\color{magenta}\\dot{\\psi}} \\end{bmatrix} \\] <p>Invertendo a matriz acima, as derivadas temporais dos \u00e2ngulos de Euler podem ser escritas em fun\u00e7\u00e3o deles pr\u00f3prios e das velocidades angulares:</p> \\[ \\begin{bmatrix}     {\\color{magenta}\\dot{\\phi}} \\\\     {\\color{magenta}\\dot{\\theta}} \\\\     {\\color{magenta}\\dot{\\psi}} \\end{bmatrix} =  \\begin{bmatrix}      1 &amp; \\sin{\\color{magenta}\\phi}\\tan{\\color{magenta}\\theta} &amp; \\cos{\\color{magenta}\\phi}\\tan{\\color{magenta}\\theta} \\\\     0 &amp; \\cos{\\color{magenta}\\phi} &amp; - \\sin{\\color{magenta}\\phi}\\\\     0 &amp; \\sin{\\color{magenta}\\phi}\\sec{\\color{magenta}\\theta} &amp; \\cos{\\color{magenta}\\phi}\\sec{\\color{magenta}\\theta}  \\end{bmatrix} \\begin{bmatrix}     {\\color{cyan}\\omega_x\\,'} \\\\     {\\color{cyan}\\omega_y\\,'} \\\\     {\\color{cyan}\\omega_z\\,'} \\end{bmatrix} \\] <p>Esta \u00faltima equa\u00e7\u00e3o \u00e9 a equa\u00e7\u00e3o cinem\u00e1tica de um corpo r\u00edgido utilizando \u00e2ngulos de Euler com a sequ\u00eancia de rota\u00e7\u00f5es \\(z-y-z\\). </p> <p>Como temos alguns termos \\(\\tan{\\color{magenta}\\theta}\\) e \\(\\sec{\\color{magenta}\\theta}\\), podemos colocar o \\(\\frac{1}{\\cos{\\color{magenta}\\theta}}\\) em evid\u00eancia:</p> \\[ \\begin{bmatrix}     {\\color{magenta}\\dot{\\phi}} \\\\     {\\color{magenta}\\dot{\\theta}} \\\\     {\\color{magenta}\\dot{\\psi}} \\end{bmatrix} =  \\frac{1}{\\cos{\\color{magenta}\\theta}} \\begin{bmatrix}      \\cos{\\color{magenta}\\theta} &amp; \\sin{\\color{magenta}\\phi}\\sin{\\color{magenta}\\theta} &amp; \\cos{\\color{magenta}\\phi}\\sin{\\color{magenta}\\theta} \\\\     0 &amp; \\cos{\\color{magenta}\\phi} \\cos{\\color{magenta}\\theta} &amp; - \\sin{\\color{magenta}\\phi} \\cos{\\color{magenta}\\theta} \\\\     0 &amp; \\sin{\\color{magenta}\\phi} &amp; \\cos{\\color{magenta}\\phi} \\end{bmatrix} \\begin{bmatrix}     {\\color{cyan}\\omega_x\\,'} \\\\     {\\color{cyan}\\omega_y\\,'} \\\\     {\\color{cyan}\\omega_z\\,'} \\end{bmatrix} \\] <p>Isso evidencia a singularidade que ocorre quando \\(\\theta = \\pm 90^{\\circ}\\).</p>"},{"location":"pages/modeling/3d_model/#cinetica","title":"Cin\u00e9tica","text":"<p>J\u00e1 deduzimos as equa\u00e7\u00f5es de Newton-Euler:</p> \\[ \\left\\{ \\begin{array}{l}         {\\color{cyan}\\dot{\\vec{v}}\\,'} = - {\\color{cyan}\\vec{\\omega}\\,'} \\times {\\color{cyan}\\vec{v}\\,'} + \\frac{1}{m} \\sum {\\color{cyan}\\vec{f}\\,'} \\\\          {\\color{cyan}\\dot{\\vec{\\omega}}\\,'} = - I^{-1} \\left( {\\color{cyan}\\vec{\\omega}\\,'} \\times I {\\color{cyan}\\vec{\\omega}\\,'} \\right) + I^{-1} \\sum {\\color{cyan}\\vec{\\tau}\\,'} \\end{array} \\right. \\]"},{"location":"pages/modeling/3d_model/#translacao_1","title":"Transla\u00e7\u00e3o","text":"<p>O vetor de for\u00e7as do drone \\({\\color{cyan}\\vec{f}_d\\,'}\\) \u00e9 mais f\u00e1cil de ser escrito no sistema de coordenadas m\u00f3vel:</p> \\[ {\\color{cyan}\\vec{f_d}\\,'} =  \\begin{bmatrix}     0 \\\\     0 \\\\     {\\color{#65DD18}f_t}  \\end{bmatrix} \\] <p>Exerc\u00edcio 3</p> <p>Determine \\({\\color{cyan}\\dot{\\vec{v}}\\,'}\\) em fun\u00e7\u00e3o dos estados do sistema.</p> <p>Dics: substitua as somat\u00f3rias de for\u00e7as \\(\\sum {\\color{cyan}\\vec{f}\\,'}\\) na equa\u00e7\u00e3o de Newton-Euler de transla\u00e7\u00e3o.</p> Resposta \\[ \\begin{align*}     {\\color{cyan}\\dot{\\vec{v}}\\,'} &amp;= - {\\color{cyan}\\vec{\\omega}\\,'} \\times {\\color{cyan}\\vec{v}\\,'} + \\frac{1}{m} \\sum {\\color{cyan}\\vec{f}\\,'} \\\\      {\\color{cyan}\\dot{\\vec{v}}\\,'} &amp;= - {\\color{cyan}\\vec{\\omega}\\,'} \\times {\\color{cyan}\\vec{v}\\,'} + \\frac{1}{m} \\left( - m {\\color{cyan}\\vec{g}\\,'} + {\\color{cyan}\\vec{f}_d\\,'} \\right) \\\\     {\\color{cyan}\\dot{\\vec{v}}\\,'} &amp;= - {\\color{cyan}\\vec{\\omega}\\,'} \\times {\\color{cyan}\\vec{v}\\,'} - R {\\color{magenta}\\vec{g}} + \\frac{1}{m} {\\color{cyan}\\vec{f}_d\\,'} \\\\      \\begin{bmatrix}         {\\color{cyan}\\dot{v}_x\\,'} \\\\         {\\color{cyan}\\dot{v}_y\\,'} \\\\         {\\color{cyan}\\dot{v}_z\\,'}     \\end{bmatrix}     &amp;=     -     \\begin{bmatrix}         {\\color{cyan}\\omega_x\\,'} \\\\         {\\color{cyan}\\omega_y\\,'} \\\\         {\\color{cyan}\\omega_z\\,'}     \\end{bmatrix}     \\times     \\begin{bmatrix}         {\\color{cyan}v_x\\,'} \\\\         {\\color{cyan}v_y\\,'} \\\\         {\\color{cyan}v_z\\,'}     \\end{bmatrix}     -     \\begin{bmatrix}              \\text{c}{\\color{magenta}\\theta}\\text{c}{\\color{magenta}\\psi} &amp; \\text{c}{\\color{magenta}\\theta}\\text{s}{\\color{magenta}\\psi} &amp; -\\text{s}{\\color{magenta}\\theta} \\\\              - \\text{c}{\\color{magenta}\\phi}\\text{s}{\\color{magenta}\\psi} + \\text{s}{\\color{magenta}\\phi}\\text{s}{\\color{magenta}\\theta}\\text{c}{\\color{magenta}\\psi}  &amp; \\text{c}{\\color{magenta}\\phi}\\text{c}{\\color{magenta}\\psi} + \\text{s}{\\color{magenta}\\phi}\\text{s}{\\color{magenta}\\theta}\\text{s}{\\color{magenta}\\psi} &amp; \\text{s}{\\color{magenta}\\phi}\\text{c}{\\color{magenta}\\theta} \\\\              \\text{s}{\\color{magenta}\\phi}\\text{s}{\\color{magenta}\\psi} + \\text{c}{\\color{magenta}\\phi}\\text{s}{\\color{magenta}\\theta}\\text{c}{\\color{magenta}\\psi} &amp; - \\text{s}{\\color{magenta}\\phi}\\text{c}{\\color{magenta}\\psi} + \\text{c}{\\color{magenta}\\phi}\\text{s}{\\color{magenta}\\theta}\\text{s}{\\color{magenta}\\psi}  &amp; \\text{c}{\\color{magenta}\\phi}\\text{c}{\\color{magenta}\\theta} \\end{bmatrix}     \\begin{bmatrix}         0 \\\\         0 \\\\         g     \\end{bmatrix}     + \\frac{1}{m}     \\begin{bmatrix}         0 \\\\         0 \\\\         {\\color{#65DD18}f_t}     \\end{bmatrix} \\\\     \\begin{bmatrix}         {\\color{cyan}\\dot{v}_x\\,'} \\\\         {\\color{cyan}\\dot{v}_y\\,'} \\\\         {\\color{cyan}\\dot{v}_z\\,'}     \\end{bmatrix}     &amp;=     \\begin{bmatrix}         - {\\color{cyan}\\omega_y\\,' v_z\\,'} + {\\color{cyan}\\omega_z\\,' v_y\\,'} + g \\sin{\\color{magenta}\\theta} \\\\         - {\\color{cyan}\\omega_z\\,' v_x\\,'} + {\\color{cyan}\\omega_x\\,' v_z\\,'} - g \\sin{\\color{magenta}\\phi}\\cos{\\color{magenta}\\theta} \\\\         - {\\color{cyan}\\omega_x\\,' v_y\\,'} + {\\color{cyan}\\omega_y\\,' v_x\\,'} - g \\cos{\\color{magenta}\\phi}\\cos{\\color{magenta}\\theta} + \\frac{1}{m} {\\color{#65DD18}f_t}     \\end{bmatrix} \\end{align*} \\]"},{"location":"pages/modeling/3d_model/#rotacao_1","title":"Rota\u00e7\u00e3o","text":"<p>O vetor de torques do drone \\({\\color{cyan}\\vec{\\tau}_d\\,'}\\) \u00e9 mais f\u00e1cil de ser escrito no sistema de coordenadas m\u00f3vel:</p> \\[ {\\color{cyan}\\vec{\\tau_d}\\,'} =  \\begin{bmatrix}     {\\color{#65DD18}\\tau_x} \\\\     0 \\\\     0 \\end{bmatrix} \\] <p>Exerc\u00edcio 4</p> <p>Determine \\({\\color{cyan}\\dot{\\vec{\\omega}}\\,'}\\) em fun\u00e7\u00e3o dos estados do sistema.</p> <p>Dics: substitua as somat\u00f3rias de torques \\(\\sum {\\color{cyan}\\vec{\\tau}\\,'}\\) na equa\u00e7\u00e3o de Newton-Euler de rota\u00e7\u00e3o.</p> Resposta \\[ \\begin{align*}     {\\color{cyan}\\dot{\\vec{\\omega}}\\,'} &amp;= - I^{-1} \\left( {\\color{cyan}\\omega\\,'} \\times I {\\color{cyan}\\vec{\\omega}\\,'} \\right) + I^{-1} \\sum {\\color{cyan}\\vec{\\tau}\\,'} \\\\      {\\color{cyan}\\dot{\\vec{\\omega}}\\,'} &amp;= - I^{-1} \\left( {\\color{cyan}\\omega\\,'} \\times I {\\color{cyan}\\vec{\\omega}\\,'} \\right) + I^{-1} {\\color{cyan}\\vec{\\tau}_d\\,'} \\\\      \\begin{bmatrix}         {\\color{cyan}\\dot{\\omega}_x\\,'} \\\\         {\\color{cyan}\\dot{\\omega}_y\\,'} \\\\         {\\color{cyan}\\dot{\\omega}_z\\,'}     \\end{bmatrix}     &amp;= -     \\begin{bmatrix}         I_{xx} &amp; 0 &amp; 0 \\\\         0 &amp; I_{yy} &amp; 0 \\\\         0 &amp; 0 &amp; I_{zz}     \\end{bmatrix}^{-1}     \\left(      \\begin{bmatrix}         {\\color{cyan}\\omega_x\\,'} \\\\         {\\color{cyan}\\omega_y\\,'} \\\\         {\\color{cyan}\\omega_z\\,'}     \\end{bmatrix}     \\times     \\begin{bmatrix}         I_{xx} &amp; 0 &amp; 0 \\\\         0 &amp; I_{yy} &amp; 0 \\\\         0 &amp; 0 &amp; I_{zz}     \\end{bmatrix}     \\begin{bmatrix}         {\\color{cyan}\\omega_x\\,'} \\\\         {\\color{cyan}\\omega_y\\,'} \\\\         {\\color{cyan}\\omega_z\\,'}     \\end{bmatrix}     \\right)     +     \\begin{bmatrix}         I_{xx} &amp; 0 &amp; 0 \\\\         0 &amp; I_{yy} &amp; 0 \\\\         0 &amp; 0 &amp; I_{zz}     \\end{bmatrix}^{-1}     \\begin{bmatrix}         {\\color{#65DD18}\\tau_x} \\\\         {\\color{#65DD18}\\tau_y} \\\\         {\\color{#65DD18}\\tau_z}     \\end{bmatrix} \\\\     \\begin{bmatrix}         {\\color{cyan}\\dot{\\omega}_x\\,'} \\\\         {\\color{cyan}\\dot{\\omega}_y\\,'} \\\\         {\\color{cyan}\\dot{\\omega}_z\\,'}     \\end{bmatrix}     &amp;= -     \\begin{bmatrix}         \\frac{1}{I_{xx}} &amp; 0 &amp; 0 \\\\         0 &amp; \\frac{1}{I_{yy}} &amp; 0 \\\\         0 &amp; 0 &amp; \\frac{1}{I_{zz}}     \\end{bmatrix}     \\left(      \\begin{bmatrix}         {\\color{cyan}\\omega_x\\,'} \\\\         {\\color{cyan}\\omega_y\\,'} \\\\         {\\color{cyan}\\omega_z\\,'}     \\end{bmatrix}     \\times     \\begin{bmatrix}         I_{xx} {\\color{cyan}\\omega_x\\,'} \\\\         I_{yy} {\\color{cyan}\\omega_y\\,'} \\\\         I_{zz} {\\color{cyan}\\omega_z\\,'}     \\end{bmatrix}     \\right)     +     \\begin{bmatrix}         \\frac{1}{I_{xx}} &amp; 0 &amp; 0 \\\\         0 &amp; \\frac{1}{I_{yy}} &amp; 0 \\\\         0 &amp; 0 &amp; \\frac{1}{I_{zz}}     \\end{bmatrix}     \\begin{bmatrix}         {\\color{#65DD18}\\tau_x} \\\\         {\\color{#65DD18}\\tau_y} \\\\         {\\color{#65DD18}\\tau_z}     \\end{bmatrix} \\\\     \\begin{bmatrix}         {\\color{cyan}\\dot{\\omega}_x\\,'} \\\\         {\\color{cyan}\\dot{\\omega}_y\\,'} \\\\         {\\color{cyan}\\dot{\\omega}_z\\,'}     \\end{bmatrix}     &amp;=      \\begin{bmatrix}         - \\frac{I_{zz}-I_{yy}}{I_{xx}} {\\color{cyan}\\omega_y\\,' \\omega_z\\,'} + \\frac{1}{I_{xx}} {\\color{#65DD18}\\tau_x} \\\\         - \\frac{I_{xx}-I_{zz}}{I_{yy}} {\\color{cyan}\\omega_x\\,' \\omega_z\\,'} + \\frac{1}{I_{yy}} {\\color{#65DD18}\\tau_y} \\\\         - \\frac{I_{yy}-I_{xx}}{I_{zz}} {\\color{cyan}\\omega_x\\,' \\omega_y\\,'} + \\frac{1}{I_{zz}} {\\color{#65DD18}\\tau_z}     \\end{bmatrix} \\end{align*} \\]"},{"location":"pages/modeling/3d_model/#linearizacao","title":"Lineariza\u00e7\u00e3o","text":"<p>Se juntarmos as equa\u00e7\u00f5es cinem\u00e1tica e cin\u00e9ticas, obtemos a din\u00e2mica completa do sistema:</p> \\[ \\left\\{ \\begin{array}{l}     {\\color{magenta}\\dot{x}} = {\\color{cyan}v_x\\,'} \\cos{\\color{magenta}\\theta}\\cos{\\color{magenta}\\psi} + {\\color{cyan}v_y\\,'} \\left( \\sin{\\color{magenta}\\phi}\\sin{\\color{magenta}\\theta}\\cos{\\color{magenta}\\psi} - \\cos{\\color{magenta}\\phi}\\sin{\\color{magenta}\\psi} \\right) + {\\color{cyan}v_z\\,'} \\left( \\cos{\\color{magenta}\\phi}\\sin{\\color{magenta}\\theta}\\cos{\\color{magenta}\\psi} + \\sin{\\color{magenta}\\phi}\\sin{\\color{magenta}\\psi} \\right) \\\\     {\\color{magenta}\\dot{y}} = {\\color{cyan}v_x\\,'} \\cos{\\color{magenta}\\theta}\\sin{\\color{magenta}\\psi} + {\\color{cyan}v_y\\,'} \\left( \\sin{\\color{magenta}\\phi}\\sin{\\color{magenta}\\theta}\\sin{\\color{magenta}\\psi} + \\cos{\\color{magenta}\\phi}\\cos{\\color{magenta}\\psi} \\right) + {\\color{cyan}v_z\\,'} \\left( \\cos{\\color{magenta}\\phi}\\sin{\\color{magenta}\\theta}\\sin{\\color{magenta}\\psi} - \\sin{\\color{magenta}\\phi}\\cos{\\color{magenta}\\psi} \\right) \\\\     {\\color{magenta}\\dot{z}} = - {\\color{cyan}v_x\\,'} \\sin{\\color{magenta}\\theta} + {\\color{cyan}v_y\\,'}  \\sin{\\color{magenta}\\phi}\\cos{\\color{magenta}\\theta} + {\\color{cyan}v_z\\,'}  \\cos{\\color{magenta}\\phi}\\cos{\\color{magenta}\\theta} \\\\     {\\color{magenta}\\dot{\\phi}} = {\\color{cyan}\\omega_x\\,'} + {\\color{cyan}\\omega_y\\,'} \\sin{\\color{magenta}\\phi} \\tan{\\color{magenta}\\theta} + {\\color{cyan}\\omega_z\\,'} \\cos{\\color{magenta}\\phi} \\tan{\\color{magenta}\\theta} \\\\     {\\color{magenta}\\dot{\\theta}} = {\\color{cyan}\\omega_y\\,'} \\cos{\\color{magenta}\\phi} - {\\color{cyan}\\omega_z\\,'} \\sin{\\color{magenta}\\phi} \\\\     {\\color{magenta}\\dot{\\psi}} = {\\color{cyan}\\omega_y\\,'} \\sin{\\color{magenta}\\phi} \\sec{\\color{magenta}\\theta} + {\\color{cyan}\\omega_z\\,'} \\cos{\\color{magenta}\\phi} \\sec{\\color{magenta}\\theta} \\\\         {\\color{cyan}\\dot{v}_x\\,'} =  - {\\color{cyan}\\omega_y\\,' v_z\\,'} + {\\color{cyan}\\omega_z\\,' v_y\\,'} + g \\sin{\\color{magenta}\\theta} \\\\         {\\color{cyan}\\dot{v}_y\\,'} = - {\\color{cyan}\\omega_z\\,' v_x\\,'} + {\\color{cyan}\\omega_x\\,' v_z\\,'} - g \\sin{\\color{magenta}\\phi}\\cos{\\color{magenta}\\theta} \\\\         {\\color{cyan}\\dot{v}_z\\,'} = - {\\color{cyan}\\omega_x\\,' v_y\\,'} + {\\color{cyan}\\omega_y\\,' v_x\\,'} - g \\cos{\\color{magenta}\\phi}\\cos{\\color{magenta}\\theta} + \\frac{1}{m} {\\color{#65DD18}f_t} \\\\         {\\color{cyan}\\dot{\\omega}_x\\,'} = - \\frac{I_{zz}-I_{yy}}{I_{xx}} {\\color{cyan}\\omega_y\\,' \\omega_z\\,'} + \\frac{1}{I_{xx}} {\\color{#65DD18}\\tau_x} \\\\         {\\color{cyan}\\dot{\\omega}_y\\,'} = - \\frac{I_{xx}-I_{zz}}{I_{yy}} {\\color{cyan}\\omega_x\\,' \\omega_z\\,'} + \\frac{1}{I_{yy}} {\\color{#65DD18}\\tau_\\theta} \\\\         {\\color{cyan}\\dot{\\omega}_z\\,'} = - \\frac{I_{yy}-I_{xx}}{I_{zz}} {\\color{cyan}\\omega_x\\,' \\omega_y\\,'} + \\frac{1}{I_{zz}} {\\color{#65DD18}\\tau_\\psi} \\end{array} \\right.   \\] <p>As equa\u00e7\u00f5es acima s\u00e3o completamente n\u00e3o-lineares, o que, al\u00e9m de ser extremamente complexo, foge do escopo do nosso curso.</p> <p>Para linearizar o sistema, podemos considerar aproxima\u00e7\u00f5es quando os estados est\u00e3o bem pr\u00f3ximos de suas posi\u00e7\u00f5es de equil\u00edbrio. Neste caso, fun\u00e7\u00f5es trigonom\u00e9tricas podem ser aproximadas (ex: \\(\\cos{\\color{magenta}\\phi} \\approx 1\\) e \\(\\sin{\\color{magenta}\\phi} \\approx {\\color{magenta}\\phi}\\)) (1), assim como o produto entre dois estados (ex: \\({\\color{cyan}v_z\\,' \\omega_x\\,'} \\approx 0\\)).</p> <ol> <li>Essas aproxima\u00e7\u00f5es valem apenas para \u00e2ngulos em radianos menores que \\(10^{\\circ}\\).</li> </ol> <p>Exerc\u00edcio 5</p> <p>Determine as equa\u00e7\u00f5es din\u00e2micas do sistema linearizado.</p> Resposta \\[ \\left\\{ \\begin{array}{l}     {\\color{magenta}\\dot{x}} = {\\color{cyan}v_x\\,'} \\cancelto{1}{\\cos{\\color{magenta}\\theta}}\\cancelto{1}{\\cos{\\color{magenta}\\psi}} + {\\color{cyan}v_y\\,'}  \\left(\\cancelto{{\\color{magenta}\\phi}}{\\sin{\\color{magenta}\\phi}}\\cancelto{{\\color{magenta}\\theta}}{\\sin{\\color{magenta}\\theta}}\\cancelto{1}{\\cos{\\color{magenta}\\psi}} - \\cancelto{1}{\\cos{\\color{magenta}\\phi}}\\cancelto{{\\color{magenta}\\psi}}{\\sin{\\color{magenta}\\psi}}\\right) + {\\color{cyan}v_z\\,'} \\left( \\cancelto{1}{\\cos{\\color{magenta}\\phi}}\\cancelto{{\\color{magenta}\\theta}}{\\sin{\\color{magenta}\\theta}}\\cancelto{1}{\\cos{\\color{magenta}\\psi}} + \\cancelto{{\\color{magenta}\\phi}}{\\sin{\\color{magenta}\\phi}}\\cancelto{{\\color{magenta}\\psi}}{\\sin{\\color{magenta}\\psi}}\\right) \\\\     {\\color{magenta}\\dot{y}} = {\\color{cyan}v_x\\,'} \\cancelto{1}{\\cos{\\color{magenta}\\theta}}\\cancelto{{\\color{magenta}\\psi}}{\\sin{\\color{magenta}\\psi}} + {\\color{cyan}v_y\\,'} \\left( \\cancelto{{\\color{magenta}\\phi}}{\\sin{\\color{magenta}\\phi}}\\cancelto{{\\color{magenta}\\theta}}{\\sin{\\color{magenta}\\theta}}\\cancelto{{\\color{magenta}\\psi}}{\\sin{\\color{magenta}\\psi}} + \\cancelto{1}{\\cos{\\color{magenta}\\phi}}\\cancelto{1}{\\cos{\\color{magenta}\\psi}} \\right) + {\\color{cyan}v_z\\,'} \\left( \\cancelto{1}{\\cos{\\color{magenta}\\phi}}\\cancelto{{\\color{magenta}\\theta}}{\\sin{\\color{magenta}\\theta}}\\cancelto{{\\color{magenta}\\psi}}{\\sin{\\color{magenta}\\psi}} - \\cancelto{{\\color{magenta}\\phi}}{\\sin{\\color{magenta}\\phi}}\\cancelto{1}{\\cos{\\color{magenta}\\psi}} \\right) \\\\     {\\color{magenta}\\dot{z}} = - {\\color{cyan}v_x\\,'} \\cancelto{{\\color{magenta}\\theta}}{\\sin{\\color{magenta}\\theta}} + {\\color{cyan}v_y\\,'} \\cancelto{{\\color{magenta}\\phi}}{\\sin{\\color{magenta}\\phi}}\\cancelto{1}{\\cos{\\color{magenta}\\theta}} + {\\color{cyan}v_z\\,'} \\cancelto{1}{\\cos{\\color{magenta}\\phi}}\\cancelto{1}{\\cos{\\color{magenta}\\theta}} \\\\     {\\color{magenta}\\dot{\\phi}} = {\\color{cyan}\\omega_x\\,'} + {\\color{cyan}\\omega_y\\,'} \\cancelto{{\\color{magenta}\\phi}}{\\sin{\\color{magenta}\\phi}} \\cancelto{{\\color{magenta}\\theta}}{\\tan{\\color{magenta}\\theta}} + {\\color{cyan}\\omega_z\\,'} \\cancelto{1}{\\cos{\\color{magenta}\\phi}} \\cancelto{{\\color{magenta}\\theta}}{\\tan{\\color{magenta}\\theta}} \\\\     {\\color{magenta}\\dot{\\theta}} = {\\color{cyan}\\omega_y\\,'} \\cancelto{1}{\\cos{\\color{magenta}\\phi}} - {\\color{cyan}\\omega_z\\,'} \\cancelto{{\\color{magenta}\\phi}}{\\sin{\\color{magenta}\\phi}} \\\\     {\\color{magenta}\\dot{\\psi}} = {\\color{cyan}\\omega_y\\,'} \\cancelto{{\\color{magenta}\\phi}}{\\sin{\\color{magenta}\\phi}} \\cancelto{1}{\\sec{\\color{magenta}\\theta}} + {\\color{cyan}\\omega_z\\,'} \\cancelto{1}{\\cos{\\color{magenta}\\phi}} \\cancelto{1}{\\sec{\\color{magenta}\\theta}} \\\\         {\\color{cyan}\\dot{v}_x\\,'} =  - \\cancelto{0}{\\color{cyan}\\omega_y\\,' v_z\\,'} + \\cancelto{0}{\\color{cyan}\\omega_z\\,' v_y\\,'} + g \\cancelto{{\\color{magenta}\\theta}}{\\sin{\\color{magenta}\\theta}} \\\\         {\\color{cyan}\\dot{v}_y\\,'} = - \\cancelto{0}{\\color{cyan}\\omega_z\\,' v_x\\,'} + \\cancelto{0}{\\color{cyan}\\omega_x\\,' v_z\\,'} - g \\cancelto{{\\color{magenta}\\phi}}{\\sin{\\color{magenta}\\phi}}\\cancelto{1}{\\cos{\\color{magenta}\\theta}} \\\\         {\\color{cyan}\\dot{v}_z\\,'} = - \\cancelto{0}{\\color{cyan}\\omega_x\\,' v_y\\,'} + \\cancelto{0}{\\color{cyan}\\omega_y\\,' v_x\\,'} - g \\cancelto{1}{\\cos{\\color{magenta}\\phi}}\\cancelto{1}{\\cos{\\color{magenta}\\theta}} + \\frac{1}{m} {\\color{#65DD18}f_t} \\\\         {\\color{cyan}\\dot{\\omega}_x\\,'} = - \\frac{I_{zz}-I_{yy}}{I_{xx}} \\cancelto{0}{\\color{cyan}\\omega_y\\,' \\omega_z\\,'} + \\frac{1}{I_{xx}} {\\color{#65DD18}\\tau_x} \\\\         {\\color{cyan}\\dot{\\omega}_y\\,'} = - \\frac{I_{xx}-I_{zz}}{I_{yy}} \\cancelto{0}{\\color{cyan}\\omega_x\\,' \\omega_z\\,'} + \\frac{1}{I_{yy}} {\\color{#65DD18}\\tau_\\theta} \\\\         {\\color{cyan}\\dot{\\omega}_z\\,'} = - \\frac{I_{yy}-I_{xx}}{I_{zz}} \\cancelto{0}{\\color{cyan}\\omega_x\\,' \\omega_y\\,'} + \\frac{1}{I_{zz}} {\\color{#65DD18}\\tau_\\psi} \\end{array} \\right.  \\qquad \\longrightarrow \\qquad \\left\\{ \\begin{array}{l}     {\\color{magenta}\\dot{x}} =  {\\color{cyan}v_x\\,'} + \\cancelto{0}{{\\color{cyan}v_y\\,'} \\left( {\\color{magenta}\\phi\\theta} - {\\color{magenta}\\psi} \\right)} + \\cancelto{0}{{\\color{cyan}v_z\\,'} \\left( {\\color{magenta}\\theta} + {\\color{magenta}\\phi\\psi} \\right)} \\\\     {\\color{magenta}\\dot{y}} =  \\cancelto{0}{{\\color{cyan}v_x\\,'}{\\color{magenta}\\psi}}  + {\\color{cyan}v_y\\,'} \\left( \\cancelto{0}{{\\color{magenta}\\phi\\theta\\psi}} + 1 \\right) +  \\cancelto{0}{{\\color{cyan}v_z\\,'} \\left( {\\color{magenta}\\theta\\psi} - {\\color{magenta}\\phi} \\right)} \\\\     {\\color{magenta}\\dot{z}} =  \\cancelto{0}{{\\color{cyan}v_x\\,'}{\\color{magenta}\\theta}} + \\cancelto{0}{{\\color{cyan}v_y\\,'}{\\color{magenta}\\phi}} + {\\color{cyan}v_z\\,'} \\\\     {\\color{magenta}\\dot{\\phi}} =  {\\color{cyan}\\omega_x\\,'} +  \\cancelto{0}{{\\color{cyan}\\omega_y\\,'}{\\color{magenta}\\phi\\theta}} +  \\cancelto{0}{{\\color{cyan}\\omega_z\\,'}{\\color{magenta}\\theta}} \\\\      {\\color{magenta}\\dot{\\theta}} =  {\\color{cyan}\\omega_y\\,'} -  \\cancelto{0}{{\\color{cyan}\\omega_z\\,'}{\\color{magenta}\\phi}} \\\\      {\\color{magenta}\\dot{\\psi}} =  \\cancelto{0}{{\\color{cyan}\\omega_y\\,'}{\\color{magenta}\\phi}} + {\\color{cyan}\\omega_z\\,'} \\\\      {\\color{cyan}\\dot{v}_x\\,'} = g {\\color{magenta}\\theta} \\\\      {\\color{cyan}\\dot{v}_y\\,'} = - g {\\color{magenta}\\phi} \\\\      {\\color{cyan}\\dot{v}_z\\,'} = -g + \\frac{1}{m} {\\color{#65DD18}f_t} \\\\      {\\color{cyan}\\dot{\\omega}_x\\,'} = \\frac{1}{I_{xx}} {\\color{#65DD18}\\tau_x} \\\\     {\\color{cyan}\\dot{\\omega}_y\\,'} = \\frac{1}{I_{yy}} {\\color{#65DD18}\\tau_y} \\\\     {\\color{cyan}\\dot{\\omega}_z\\,'} = \\frac{1}{I_{zz}} {\\color{#65DD18}\\tau_z} \\end{array} \\right.   \\qquad \\longrightarrow \\qquad \\left\\{ \\begin{array}{l}     {\\color{magenta}\\dot{x}} =  {\\color{cyan}v_x\\,'} \\\\     {\\color{magenta}\\dot{y}} =  {\\color{cyan}v_y\\,'} \\\\     {\\color{magenta}\\dot{z}} =  {\\color{cyan}v_z\\,'} \\\\     {\\color{magenta}\\dot{\\phi}} =  {\\color{cyan}\\omega_x\\,'} \\\\      {\\color{magenta}\\dot{\\theta}} =  {\\color{cyan}\\omega_y\\,'} \\\\      {\\color{magenta}\\dot{\\psi}} =  {\\color{cyan}\\omega_z\\,'} \\\\      {\\color{cyan}\\dot{v}_x\\,'} = g {\\color{magenta}\\theta} \\\\      {\\color{cyan}\\dot{v}_y\\,'} = - g {\\color{magenta}\\phi} \\\\      {\\color{cyan}\\dot{v}_z\\,'} = -g + \\frac{1}{m} {\\color{#65DD18}f_t} \\\\      {\\color{cyan}\\dot{\\omega}_x\\,'} = \\frac{1}{I_{xx}} {\\color{#65DD18}\\tau_x} \\\\     {\\color{cyan}\\dot{\\omega}_y\\,'} = \\frac{1}{I_{yy}} {\\color{#65DD18}\\tau_y} \\\\     {\\color{cyan}\\dot{\\omega}_z\\,'} = \\frac{1}{I_{zz}} {\\color{#65DD18}\\tau_z} \\end{array} \\right.     \\] <p>Voc\u00ea deve ter chegado a:</p> \\[ \\left\\{ \\begin{array}{l}     {\\color{magenta}\\dot{x}} =  {\\color{cyan}v_x\\,'} \\\\     {\\color{magenta}\\dot{y}} =  {\\color{cyan}v_y\\,'} \\\\     {\\color{magenta}\\dot{z}} =  {\\color{cyan}v_z\\,'} \\\\     {\\color{magenta}\\dot{\\phi}} =  {\\color{cyan}\\omega_x\\,'} \\\\      {\\color{magenta}\\dot{\\theta}} =  {\\color{cyan}\\omega_y\\,'} \\\\      {\\color{magenta}\\dot{\\psi}} =  {\\color{cyan}\\omega_z\\,'} \\\\      {\\color{cyan}\\dot{v}_x\\,'} = g {\\color{magenta}\\theta} \\\\      {\\color{cyan}\\dot{v}_y\\,'} = - g {\\color{magenta}\\phi} \\\\      {\\color{cyan}\\dot{v}_z\\,'} = -g + \\frac{1}{m} {\\color{#65DD18}f_t} \\\\      {\\color{cyan}\\dot{\\omega}_x\\,'} = \\frac{1}{I_{xx}} {\\color{#65DD18}\\tau_x} \\\\     {\\color{cyan}\\dot{\\omega}_y\\,'} = \\frac{1}{I_{yy}} {\\color{#65DD18}\\tau_y} \\\\     {\\color{cyan}\\dot{\\omega}_z\\,'} = \\frac{1}{I_{zz}} {\\color{#65DD18}\\tau_z} \\end{array} \\right.     \\] <p>Essas equa\u00e7\u00f5es diferenciais podem ser representadas de forma mais simples em um diagrama de blocos:</p> <p></p> <p>Observe o seguinte:</p> <ul> <li>A for\u00e7a \\({\\color{#65DD18}f_t}\\) integra duas vezes at\u00e9 a posi\u00e7\u00e3o \\({\\color{magenta}z}\\) (2\u00aa lei de Newton para transla\u00e7\u00e3o), atuando de forma desacoplada na din\u00e2mica de posi\u00e7\u00e3o vertical.</li> <li> <p>O torque \\({\\color{#65DD18}\\tau_x}\\) integra duas vezes at\u00e9 o \u00e2ngulo \\({\\color{magenta}\\phi}\\) (2\u00aa lei de Newton para rota\u00e7\u00e3o), e, integrando mais duas vezes, chega-se a posi\u00e7\u00e3o \\({\\color{magenta}y}\\)(1). Portanto, de \\({\\color{#65DD18}\\tau_x}\\) a \\({\\color{magenta}y}\\) h\u00e1 um integrador qu\u00e1druplo, resultado do acoplamento entre a din\u00e2mica de rota\u00e7\u00e3o e a din\u00e2mica de posi\u00e7\u00e3o horizontal. </p> <ol> <li>O sinal negativo em \\(- g\\) decorre da conven\u00e7\u00e3o de eixos adotada (uma rota\u00e7\u00e3o positiva em torno de \\({\\color{magenta}x}\\) implica em um deslocamento negativo ao longo de \\({\\color{magenta}y}\\)).</li> </ol> </li> <li> <p>O torque \\({\\color{#65DD18}\\tau_y}\\) integra duas vezes at\u00e9 o \u00e2ngulo \\({\\color{magenta}\\theta}\\) (2\u00aa lei de Newton para rota\u00e7\u00e3o), e, integrando mais duas vezes, chega-se a posi\u00e7\u00e3o \\({\\color{magenta}x}\\)(1). Portanto, de \\({\\color{#65DD18}\\tau_y}\\) a \\({\\color{magenta}x}\\) h\u00e1 um integrador qu\u00e1druplo, resultado do acoplamento entre a din\u00e2mica de rota\u00e7\u00e3o e a din\u00e2mica de posi\u00e7\u00e3o horizontal. </p> <ol> <li>O sinal positivo em \\(g\\) decorre da conven\u00e7\u00e3o de eixos adotada (uma rota\u00e7\u00e3o positiva em torno de \\({\\color{magenta}y}\\) implica em um deslocamento positivo ao longo de \\({\\color{magenta}x}\\)).</li> </ol> </li> <li> <p>O torque \\({\\color{#65DD18}\\tau_z}\\) integra duas vezes at\u00e9 o \u00e2ngulo \\({\\color{magenta}\\psi}\\) (2\u00aa lei de Newton para rota\u00e7\u00e3o), atuando de forma desacoplada na din\u00e2mica de rota\u00e7\u00e3o de guinagem.</p> </li> </ul>"},{"location":"pages/modeling/coordinate_system/","title":"Sistema de coordenadas","text":"<p>No controle de drones, o uso de sistemas de coordenadas \u00e9 fundamental para descrever posi\u00e7\u00f5es e orienta\u00e7\u00f5es relativas. Alguns exemplos comuns s\u00e3o: a posi\u00e7\u00e3o do drone em rela\u00e7\u00e3o ao solo, a orienta\u00e7\u00e3o da c\u00e2mera em rela\u00e7\u00e3o ao drone e a velocidade do drone em rela\u00e7\u00e3o ao vento.</p> <p>A escolha do sistema de coordenadas adequado torna muitos c\u00e1lculos mais simples. Por exemplo, for\u00e7as e torques aerodin\u00e2micos s\u00e3o mais naturalmente descritos em um sistema de coordenadas m\u00f3vel (fixo no drone), enquanto a acelera\u00e7\u00e3o da gravidade \u00e9 melhor representada em um sistema de coordenadas inercial (fixo na Terra).</p>"},{"location":"pages/modeling/coordinate_system/#matriz-de-rotacao","title":"Matriz de rota\u00e7\u00e3o","text":"<p>Quando trabalhamos com diferentes sistemas de coordenadas, precisamos de uma forma matem\u00e1tica para descrever a orienta\u00e7\u00e3o relativa entre eles. Essa fun\u00e7\u00e3o \u00e9 cumprida pelas matrizes de rota\u00e7\u00e3o, que permitem representar rota\u00e7\u00f5es tanto no plano (2D) quanto no espa\u00e7o tridimensional (3D).</p>"},{"location":"pages/modeling/coordinate_system/#2d","title":"2D","text":"<p>Ao descrever a posi\u00e7\u00e3o de um drone, precisamos definir uma refer\u00eancia. Um m\u00e9todo geral \u00e9 utilizar um sistema de coordenadas inercial \\({\\color{magenta}yz}\\) (1).</p> <ol> <li>Fixo na Terra, que n\u00e3o acelera nem rotaciona.</li> </ol> <p></p> <p>J\u00e1 para descrever a atitude (orienta\u00e7\u00e3o) do drone, apenas esse sistema n\u00e3o \u00e9 suficiente. \u00c9 necess\u00e1rio introduzir tamb\u00e9m um sistema de coordenadas m\u00f3vel \\({\\color{cyan}y'z'}\\) (1).</p> <ol> <li>Fixo no drone, que acelera e rotaciona com ele.</li> </ol> <p></p> <p>A atitude do drone \u00e9 dada, portanto, pela orienta\u00e7\u00e3o relativa do sistema m\u00f3vel \\({\\color{cyan}y'z'}\\) em rela\u00e7\u00e3o ao sistema inercial \\({\\color{magenta}yz}\\). Essa orienta\u00e7\u00e3o pode ser representada matematicamente por uma matriz \\(2 \\times 2\\) chamada de matrix de rota\u00e7\u00e3o \\(R\\):</p> \\[ {\\color{cyan} \\begin{bmatrix}     y' \\\\     z' \\end{bmatrix} } = \\underbrace{ \\begin{bmatrix}     r_{11} &amp; r_{12} \\\\     r_{21} &amp; r_{22} \\end{bmatrix} }_{R} {\\color{magenta} \\begin{bmatrix}     y \\\\     z \\end{bmatrix} } \\] <p>Apesar de possuir quatro elementos, essa matriz pode ser descrita em fun\u00e7\u00e3o de um \u00fanico par\u00e2metro: o \u00e2ngulo de rota\u00e7\u00e3o \\(\\phi\\):</p> \\[ R(\\phi)= \\begin{bmatrix}     r_{11}(\\phi) &amp; r_{12}(\\phi)\\\\     r_{21}(\\phi) &amp; r_{22}(\\phi) \\end{bmatrix} \\] <p>Exerc\u00edcio 1</p> <p>Considere que o sistema de coordenadas m\u00f3vel \\({\\color{cyan}y'z'}\\) est\u00e1 rotacionado de um \u00e2ngulo \\(\\phi\\) em rela\u00e7\u00e3o ao sistema de coordenadas inercial \\({\\color{magenta}yz}\\).</p> <p></p> a) Escreva a matriz de rota\u00e7\u00e3o em fun\u00e7\u00e3o do \u00e2ngulo \\(\\phi\\). \\[ R(\\phi) =  \\begin{bmatrix}      \\cos{\\phi} &amp; \\sin{\\phi} \\\\      -\\sin{\\phi} &amp; \\cos{\\phi}  \\end{bmatrix} \\] b) Calcule \\(R(\\phi)\\) para \\(\\phi = \\frac{\\pi}{2} \\, \\text{rad}\\) e interprete o resultado. \\[ R\\left(\\frac{\\pi}{2}\\right)  =  \\begin{bmatrix}      \\cos{\\frac{\\pi}{2}} &amp; \\sin{\\frac{\\pi}{2}} \\\\      -\\sin{\\frac{\\pi}{2}} &amp; \\cos{\\frac{\\pi}{2}}  \\end{bmatrix}  = \\begin{bmatrix}      0 &amp; 1 \\\\      -1 &amp; 0 \\end{bmatrix} \\] <p>O resultado faz sentido: ao rotacionar \\(90^{\\circ}\\), o eixo \\({\\color{cyan}y'}\\) passa a coincidir com \\({\\color{magenta}z}\\), enquanto o eixo \\({\\color{cyan}z'}\\) fica no sentido oposto de \\({\\color{magenta}y}\\).</p> c) Determine o \u00e2ngulo \\(\\phi\\) correspondente \u00e0 matriz  \\(R (\\phi)= \\begin{bmatrix} \\frac{\\sqrt{2}}{2} &amp; \\frac{\\sqrt{2}}{2} \\\\ -\\frac{\\sqrt{2}}{2} &amp; \\frac{\\sqrt{2}}{2} \\end{bmatrix}\\). \\[ \\begin{align*}     \\cos \\phi &amp;= \\frac{\\sqrt{2}}{2} \\\\     \\phi &amp;= \\cos^{-1}\\!\\left(\\frac{\\sqrt{2}}{2}\\right) \\\\     \\phi &amp;= \\frac{\\pi}{4} \\;\\text{rad} \\;\\; (45^\\circ) \\end{align*} \\]"},{"location":"pages/modeling/coordinate_system/#3d","title":"3D","text":"<p>Assim como no plano, no espa\u00e7o a atitude do drone tamb\u00e9m \u00e9 dada pela atitude relativa do sistema de coordenadas m\u00f3vel \\({\\color{cyan}x'y'z'}\\) em rela\u00e7\u00e3o ao sistema de coordenadas inercial \\({\\color{magenta}xyz}\\).</p> <p></p> <p>No entanto, como agora estamos lidando com tr\u00eas dimens\u00f5es, a matriz de rota\u00e7\u00e3o \\(R\\) passa a possuir dimens\u00e3o \\(3 \\times 3\\):</p> \\[ {\\color{cyan} \\begin{bmatrix}     x'\\\\y'\\\\z' \\end{bmatrix} } = \\underbrace{ \\begin{bmatrix}     r_{11} &amp; r_{12} &amp; r_{13}\\\\     r_{21} &amp; r_{22} &amp; r_{23}\\\\     r_{31} &amp; r_{32} &amp; r_{33} \\end{bmatrix} }_{R} {\\color{magenta} \\begin{bmatrix}     x \\\\     y \\\\     z \\end{bmatrix} } \\] <p>De acordo com Leonhard Euler, qualquer atitude no espa\u00e7o pode ser descrita atrav\u00e9s de tr\u00eas rota\u00e7\u00f5es sucessivas em torno de eixos pr\u00e9-definidos e mutuamente ortogonais(1). Dessa forma, os nove elementos da matriz de rota\u00e7\u00e3o podem ser expressos em fun\u00e7\u00e3o de tr\u00eas par\u00e2metros: os \u00e2ngulos de Euler \\(\\phi\\), \\(\\theta\\) e \\(\\psi\\):</p> <ol> <li>Formam um \u00e2ngulo de \\(90^{\\circ}\\) entre si.</li> </ol> \\[\\begin{equation*}         R({\\phi},{\\theta},{\\psi})         =         \\begin{bmatrix}         r_{11}({\\phi},{\\theta},{\\psi}) &amp; r_{12}({\\phi},{\\theta},{\\psi}) &amp; r_{13}({\\phi},{\\theta},{\\psi}) \\\\         r_{21}({\\phi},{\\theta},{\\psi}) &amp; r_{22}({\\phi},{\\theta},{\\psi}) &amp; r_{23}({\\phi},{\\theta},{\\psi}) \\\\         r_{31}({\\phi},{\\theta},{\\psi}) &amp; r_{32}({\\phi},{\\theta},{\\psi}) &amp; r_{33}({\\phi},{\\theta},{\\psi})         \\end{bmatrix} \\end{equation*}\\] <p>Exerc\u00edcio 2</p> <p>Considere que o sistema de coordenadas m\u00f3vel \\({\\color{cyan}x'y'z'}\\) est\u00e1 rotacionado de um \u00e2ngulo \\(\\phi\\) em rela\u00e7\u00e3o ao sistema de coordenadas inercial \\({\\color{magenta}xyz}\\) e em torno do eixo \\({\\color{magenta}x}\\).</p> <p></p> a) Escreva a matriz de rota\u00e7\u00e3o em fun\u00e7\u00e3o do \u00e2ngulo \\(\\phi\\). \\[ R_x(\\phi) =  \\begin{bmatrix}      1 &amp; 0 &amp; 0 \\\\     0 &amp; \\cos\\phi &amp; \\sin\\phi \\\\      0 &amp; -\\sin\\phi &amp; \\cos\\phi  \\end{bmatrix} \\] b) Calcule \\(R_x(\\phi)\\) para \\(\\phi=\\pi \\, \\text{rad}\\) e interprete o resultado. \\[ \\begin{align*}     R_x\\left(\\pi\\right)      =      \\begin{bmatrix}          1 &amp; 0 &amp; 0 \\\\         0 &amp; \\cos \\pi &amp; \\sin \\pi \\\\          0 &amp; -\\sin \\pi &amp; \\cos \\pi     \\end{bmatrix}      =      \\begin{bmatrix}          1 &amp; 0 &amp; 0 \\\\         0 &amp; -1 &amp; 0 \\\\          0 &amp; 0 &amp; -1     \\end{bmatrix} \\end{align*} \\] <p>O resultado faz sentido: uma rota\u00e7\u00e3o de \\(180^\\circ\\) em torno de \\({\\color{magenta}x}\\) inverte os eixos \\({\\color{magenta}y}\\) e \\({\\color{magenta}z}\\), de modo que \\({\\color{cyan}y'}\\) e \\({\\color{cyan}z'}\\) ficam em sentidos opostos a \\({\\color{magenta}y}\\) e \\({\\color{magenta}z}\\), enquanto \\({\\color{cyan}x'}\\) permance alinhado com \\({\\color{magenta}x}\\).</p> <p>Exerc\u00edcio 3</p> <p>Considere que o sistema de coordenadas m\u00f3vel \\({\\color{cyan}x'y'z'}\\) est\u00e1 rotacionado de um \u00e2ngulo \\(\\theta\\) em rela\u00e7\u00e3o ao sistema de coordenadas inercial \\({\\color{magenta}xyz}\\) e em torno do eixo \\({\\color{magenta}y}\\).</p> <p></p> a) Escreva a matriz de rota\u00e7\u00e3o em fun\u00e7\u00e3o do \u00e2ngulo \\(\\theta\\). \\[ R_y(\\theta) =  \\begin{bmatrix}      \\cos\\theta &amp; 0 &amp; -\\sin\\theta \\\\      0 &amp; 1 &amp; 0 \\\\      \\sin\\theta &amp; 0 &amp; \\cos\\theta \\end{bmatrix} \\] b) Calcule \\(R_y(\\theta)\\) para \\(\\theta=\\tfrac{\\pi}{2} \\, \\text{rad}\\) e interprete o resultado. \\[ \\begin{align*}     R_y\\left(\\frac{\\pi}{2}\\right)      =      \\begin{bmatrix}          \\cos\\frac{\\pi}{2} &amp; 0 &amp; -\\sin\\frac{\\pi}{2} \\\\          0 &amp; 1 &amp; 0 \\\\          \\sin\\frac{\\pi}{2} &amp; 0 &amp; \\cos\\frac{\\pi}{2}     \\end{bmatrix}      =      \\begin{bmatrix}          0 &amp; 0 &amp; -1 \\\\          0 &amp; 1 &amp; 0 \\\\          1 &amp; 0 &amp; 0     \\end{bmatrix} \\end{align*} \\] <p>O resultado faz sentido: ao rotacionar \\(90^\\circ\\) em torno de \\({\\color{magenta}y}\\), o eixo \\({\\color{cyan}x'}\\) passa a apontar para o sentido oposto de \\({\\color{magenta}z}\\) e o eixo \\({\\color{cyan}z'}\\) passa a coincidir com \\({\\color{magenta}x}\\), enquanto o eixo \\({\\color{cyan}y'}\\) permance alinhado com \\({\\color{magenta}y}\\).</p> <p>Exerc\u00edcio 4</p> <p>Considere que o sistema de coordenadas m\u00f3vel \\({\\color{cyan}x'y'z'}\\) est\u00e1 rotacionado de um \u00e2ngulo \\(\\psi\\) em rela\u00e7\u00e3o ao sistema de coordenadas inercial \\({\\color{magenta}xyz}\\) e em torno do eixo \\({\\color{magenta}z}\\).</p> <p></p> a) Escreva a matriz de rota\u00e7\u00e3o em fun\u00e7\u00e3o do \u00e2ngulo \\(\\psi\\). \\[ R_z(\\psi) =  \\begin{bmatrix}      \\cos\\psi &amp; \\sin\\psi &amp; 0 \\\\      -\\sin\\psi &amp; \\cos\\psi &amp; 0 \\\\      0 &amp; 0 &amp; 1 \\end{bmatrix} \\] b) Calcule \\(R_z(\\psi)\\) para \\(\\psi=2\\pi \\, \\text{rad}\\) e interprete o resultado. \\[ \\begin{align*}     R_z\\left(2\\pi\\right)      =      \\begin{bmatrix}           \\cos 2\\pi &amp; \\sin 2\\pi &amp; 0 \\\\          -\\sin 2\\pi &amp; \\cos 2\\pi &amp; 0 \\\\          0 &amp; 0 &amp; 1     \\end{bmatrix}      =      \\begin{bmatrix}          1 &amp; 0 &amp; 0 \\\\         0 &amp; 1 &amp; 0 \\\\          0 &amp; 0 &amp; 1     \\end{bmatrix} \\end{align*} \\] <p>O resultado faz sentido: uma rota\u00e7\u00e3o completa de \\(360^\\circ\\) em torno de \\({\\color{magenta}z}\\) devolve \\({\\color{cyan}x'y'z'}\\) exatamente a \\({\\color{magenta}xyz}\\), ou seja, todos os eixos voltam a coincidir.</p>"},{"location":"pages/modeling/coordinate_system/#propriedades","title":"Propriedades","text":"<p>Matrizes de rota\u00e7\u00e3o possuem algumas propriedades fundamentais:</p> <ul> <li>Cada linha e cada coluna tem norma unit\u00e1ria (comprimento igual a 1).</li> <li>Linhas e colunas s\u00e3o ortogonais entre si (o produto escalar entre elas \u00e9 zero).</li> <li>S\u00e3o matrizes ortonormais (sua inversa \u00e9 igual \u00e0 transposta), isto \u00e9, \\(R^{-1} = R^T\\).</li> <li>Possuem determinante unit\u00e1rio, isto \u00e9, \\(\\det (R) = 1\\).</li> </ul> <p>Exerc\u00edcio 5</p> <p>Considere a matriz de rota\u00e7\u00e3o \\(R\\) que relaciona o sistema de coordenadas m\u00f3vel \\({\\color{cyan}x'y'z'}\\) com o sistema de coordenadas inercial \\({\\color{magenta}xyz}\\):</p> \\[ R =  \\begin{bmatrix}      \\frac{\\sqrt{2}}{2} &amp; \\frac{\\sqrt{2}}{2} &amp; 0 \\\\      -\\frac{\\sqrt{2}}{2} &amp; \\frac{\\sqrt{2}}{2} &amp; 0 \\\\      0 &amp; 0 &amp; 1  \\end{bmatrix}    \\] <p>Calcule a matriz de rota\u00e7\u00e3o inversa \\(R^{-1}\\), isto \u00e9, que relaciona o sistema inercial \\({\\color{magenta}xyz}\\) com o sistema m\u00f3vel \\({\\color{cyan}x'y'z'}\\).</p> Resposta \\[ R^{-1} = R^{T} = \\begin{bmatrix}      \\frac{\\sqrt{2}}{2} &amp; -\\frac{\\sqrt{2}}{2} &amp; 0 \\\\      \\frac{\\sqrt{2}}{2} &amp; \\frac{\\sqrt{2}}{2} &amp; 0 \\\\      0 &amp; 0 &amp; 1  \\end{bmatrix} \\]"},{"location":"pages/modeling/coordinate_system/#angulos-de-euler","title":"\u00c2ngulos de Euler","text":"<p>Os \u00e2ngulos de Euler s\u00e3o um conjunto de tr\u00eas rota\u00e7\u00f5es sucessivas em torno de eixos distintos, que permitem levar o sistema de coordenadas inercial \\({\\color{magenta}xyz}\\) at\u00e9 o sistema de coordenadas m\u00f3vel \\({\\color{cyan}x'y'z'}\\).  </p> <p></p> <p>De acordo com a conven\u00e7\u00e3o adotada aqui, usamos:</p> <ul> <li>\\(\\psi\\): rota\u00e7\u00e3o em torno do eixo \\({\\color{magenta}z'}\\) (yaw - guinagem)  </li> <li>\\(\\theta\\): rota\u00e7\u00e3o em torno do eixo \\({\\color{magenta}y'}\\) (pitch - inclina\u00e7\u00e3o)  </li> <li>\\(\\phi\\): rota\u00e7\u00e3o em torno do eixo \\({\\color{magenta}x'}\\) (roll - rolagem)  </li> </ul> <p>A matriz de rota\u00e7\u00e3o total \u00e9 obtida pela composi\u00e7\u00e3o das tr\u00eas matrizes individuais.  </p> \\[ R(\\phi,\\theta,\\psi) =  \\underbrace{ \\begin{bmatrix}      1 &amp; 0 &amp; 0 \\\\     0 &amp; \\cos\\phi &amp; \\sin\\phi \\\\      0 &amp; -\\sin\\phi &amp; \\cos\\phi \\end{bmatrix} }_{R_x(\\phi)} \\underbrace{ \\begin{bmatrix}      \\cos\\theta &amp; 0 &amp; -\\sin\\theta \\\\      0 &amp; 1 &amp; 0 \\\\      \\sin\\theta &amp; 0 &amp; \\cos\\theta  \\end{bmatrix} }_{R_y(\\theta)} \\underbrace{ \\begin{bmatrix}      \\cos\\psi &amp; \\sin\\psi &amp; 0 \\\\      -\\sin\\psi &amp; \\cos\\psi &amp; 0 \\\\      0 &amp; 0 &amp; 1  \\end{bmatrix}    }_{R_z(\\psi)} \\] <p>Note</p> <p>Observe que a primeira rota\u00e7\u00e3o aplicada, \\(R_z(\\psi)\\), aparece mais \u00e0 direita, enquanto a \u00faltima rota\u00e7\u00e3o, \\(R_x(\\phi)\\), aparece mais \u00e0 esquerda. Isso ocorre porque a multiplica\u00e7\u00e3o de matrizes segue a ordem inversa da aplica\u00e7\u00e3o das transforma\u00e7\u00f5es.</p> <p>Exerc\u00edcio 6</p> <p>Determine a matriz de rota\u00e7\u00e3o total \\(R(\\phi,\\theta,\\psi)\\) que relaciona o sistema de coordenadas m\u00f3vel \\({\\color{cyan}x'y'z'}\\) com o sistema de coordenadas inercial \\({\\color{magenta}xyz}\\) em fun\u00e7\u00e3o dos \u00e2ngulos de Euler \\(\\phi\\), \\(\\theta\\) e \\(\\psi\\).</p> <p>Dica: utilize o Symbolic Math Toolbox do MATLAB.</p> Resposta \\[ R (\\phi,\\theta,\\psi) =  \\begin{bmatrix} \\cos\\theta\\cos\\psi &amp; \\cos\\theta\\sin\\psi &amp; -\\sin\\theta \\\\  \\sin\\phi\\sin\\theta\\cos\\psi - \\cos\\phi\\sin\\psi &amp; \\sin\\phi\\sin\\theta\\sin\\psi + \\cos\\phi\\cos\\psi &amp; \\sin\\phi\\cos\\theta \\\\   \\cos\\phi\\sin\\theta\\cos\\psi + \\sin\\phi\\sin\\psi &amp; \\cos\\phi\\sin\\theta\\sin\\psi - \\sin\\phi\\cos\\psi &amp; \\cos\\phi\\cos\\theta  \\end{bmatrix} \\]"},{"location":"pages/modeling/coordinate_system/#singularidades","title":"Singularidades","text":"<p>Singularidades s\u00e3o pontos nos quais uma vari\u00e1vel matem\u00e1tica torna-se indefinida. No caso dos \u00e2ngulos de Euler, \u00e9 uma orienta\u00e7\u00e3o na qual h\u00e1 mais de uma \u00fanica sequ\u00eancia de rota\u00e7\u00f5es poss\u00edveis. </p> <p>Quando a segunda rota\u00e7\u00e3o \u00e9 igual a \\(\\theta = \\frac{\\pi}{2}\\) rad, a dire\u00e7\u00e3o dos eixos da primeira (\\({\\color{cyan}z'}\\)) e terceira (\\({\\color{cyan}x'}\\)) rota\u00e7\u00e3o coincidem, tornando-se imposs\u00edvel discernir os valores de \\(\\psi\\) e \\(\\phi\\).</p> <p>N\u00e3o h\u00e1 acordo sobre a nota\u00e7\u00e3o (sequ\u00eancia de rota\u00e7\u00f5es) utilizada pelos \u00e2ngulos de Euler. Existe um total de 12 combina\u00e7\u00f5es, pois a rota\u00e7\u00e3o seguinte deve sempre ocorrer em um eixo distinto da anterior, conforme a tabela abaixo:</p> Nota\u00e7\u00e3o Eixo da 1\u00aa rota\u00e7\u00e3o Eixo da 2\u00aa rota\u00e7\u00e3o Eixo da 3\u00aa rota\u00e7\u00e3o \\( x\\!-\\!y\\!-\\!x \\) \\( x' \\) \\( y' \\) \\( x' \\) \\( x\\!-\\!y\\!-\\!z \\) \\( z' \\) \\( x\\!-\\!z\\!-\\!x \\) \\( z' \\) \\( x' \\) \\( x\\!-\\!z\\!-\\!y \\) \\( y' \\) \\( y\\!-\\!x\\!-\\!y \\) \\( y' \\) \\( x' \\) \\( y' \\) \\( y\\!-\\!x\\!-\\!z \\) \\( z' \\) \\( y\\!-\\!z\\!-\\!y \\) \\( z' \\) \\( y' \\) \\( y\\!-\\!z\\!-\\!x \\) \\( x' \\) \\( z\\!-\\!x\\!-\\!z \\) \\( z' \\) \\( x' \\) \\( z' \\) \\( z\\!-\\!x\\!-\\!y \\) \\( y' \\) \\( z\\!-\\!y\\!-\\!z \\) \\( y' \\) \\( z' \\) \\( z\\!-\\!y\\!-\\!x \\) \\( x' \\) <p>Note que todas as combina\u00e7\u00f5es possuem singularidades; a \u00fanica diferen\u00e7a \u00e9 o \u00e2ngulo no qual elas ocorrem:</p> <ul> <li>Quando o eixo da primeira e terceira rota\u00e7\u00e3o s\u00e3o iguais (\u00c2ngulos de Euler), as singularidades ocorrem quando a segunda rota\u00e7\u00e3o \u00e9 igual a \\(0 \\, \\text{rad}\\).</li> <li>Quando o eixo da primeira e terceira rota\u00e7\u00e3o s\u00e3o distintos (\u00c2ngulos de Tait\u2013Bryan), as singularidades ocorrem quando a segunda rota\u00e7\u00e3o \u00e9 igual a \\(\\frac{\\pi}{2} \\, \\text{rad}\\). </li> </ul> <p>Como a posi\u00e7\u00e3o de equil\u00edbrio do drone ocorre quando a segunda rota\u00e7\u00e3o \u00e9 igual a \\(0 \\, \\text{rad}\\), utiliza-se a nota\u00e7\u00e3o em que o eixo da primeira e terceira rota\u00e7\u00e3o s\u00e3o distintos (\\(z-y-x\\)), tamb\u00e9m conhecido por yaw, pitch e roll(1).  Assim, a singularidade fica distante de ocorrer (apesar de ainda ser uma possibilidade).</p> <ol> <li>Guinagem (\\(\\psi\\) no eixo \\(z\\)), inclina\u00e7\u00e3o (\\(\\theta\\) no eixo \\(y\\)) e rolagem (\\(\\phi\\) no eixo \\(x\\))</li> </ol> <p>Uma alternativa aos \u00e2ngulos de Euler, que n\u00e3o possuem singularidades, s\u00e3o os quat\u00e9rnios.</p>"},{"location":"pages/setup/firmware/","title":"Firmware","text":"<p>Agora que seu ambiente est\u00e1 pronto, \u00e9 hora de colocar a m\u00e3o no c\u00f3digo do drone.</p> <p>Aqui, voc\u00ea vai aprender a baixar, configurar e compilar o firmware que roda dentro do Crazyflie \u2014 deixando tudo pronto para testar seu pr\u00f3prio c\u00f3digo no drone real.</p>"},{"location":"pages/setup/firmware/#visual-studio-code","title":"Visual Studio Code","text":"<p>Vamos utilizar o Visual Studio Code como IDE (Ambiente de Desenvolvimento Integrado).</p> <ol> <li>Baixe o Visual Studio Code em seu site oficial e instale-o.</li> </ol>"},{"location":"pages/setup/firmware/#clonando","title":"Clonando","text":"<p>Antes de come\u00e7ar a programar, precisamos trazer o c\u00f3digo do firmware para sua m\u00e1quina. Vamos fazer isso em duas etapas: primeiro, voc\u00ea cria uma c\u00f3pia (um fork) do reposit\u00f3rio, e depois clona essa c\u00f3pia para o seu computador.</p>"},{"location":"pages/setup/firmware/#fork","title":"Fork","text":"<ol> <li>Crie um fork do reposit\u00f3rio que cont\u00e9m o firmware para a sua conta do GitHub.</li> </ol>"},{"location":"pages/setup/firmware/#clone","title":"Clone","text":"<ol> <li> <p>Abra o Visual Studio Code</p> </li> <li> <p>Clique em <code>Clone Git Repository...</code></p> </li> <li> <p>Coloque o endere\u00e7o do reposit\u00f3rio forkado para sua conta do GitHub: <pre><code>https://github.com/username/quadcontrol-firmware.git\n</code></pre></p> <p>Aten\u00e7\u00e3o</p> <p>Voc\u00ea deve substituir <code>username</code> pelo seu nome de usu\u00e1rio do GitHub</p> </li> <li> <p>Pressione <code>Enter</code> e selecione o local onde voc\u00ea quer salvar esse reposit\u00f3rio.</p> </li> <li> <p>Quando ele terminar de clonar e perguntar se voc\u00ea gostaria de abrir o reposit\u00f3rio clonado, clique em <code>Open</code>.</p> </li> <li> <p>Abra uma janela do terminal clicando em <code>Terminal</code> &gt; <code>New Terminal</code> (ou usando o atalho <code>Crtl</code>+<code>Shift</code>+<code>'</code>).</p> <p>Aten\u00e7\u00e3o</p> <p>Caso esteja utilizando Windows, ele abre por padr\u00e3o um terminal do PowerShell, mas voc\u00ea deve alternar para um terminal do WSL (Ubuntu): </p> </li> <li> <p>Inicialize todos os subm\u00f3dulos<sup>1</sup> pelo terminal: <pre><code>git submodule update --init --recursive\n</code></pre></p> </li> </ol>"},{"location":"pages/setup/firmware/#organizacao","title":"Organiza\u00e7\u00e3o","text":"<p>O firmware \u00e9 composto por 2 pastas e 2 arquivos:</p> <p></p> <p>Vamos entender cada um deles:</p> <ul> <li><code>crazyflie-firmware</code> - Pasta que cont\u00e9m o firmware do Crazyflie, o qual utilizaremos como subm\u00f3dulo</li> <li><code>src</code> - Pasta que cont\u00e9m os programas que vamos desenvolver ao longo do curso</li> <li><code>Kbuild</code> - Arquivo que define o programa que ser\u00e1 compilado</li> <li><code>radio.config</code> - Arquivo que define o canal de r\u00e1dio utilizado para se comunicar com o Crazyflie</li> </ul> <p>A pasta <code>src</code> possui uma subpasta <code>examples</code> com 2 exemplos de programas: <code>led_blink.c</code> e <code>hello_world.c</code>. Abra esses arquivos para ver alguns exemplos de programa bem simples:</p> Led blinkHello world led_blink.c<pre><code>#include \"FreeRTOS.h\"      // FreeRTOS core definitions (needed for task handling and timing)\n#include \"task.h\"          // FreeRTOS task functions (e.g., vTaskDelay)\n#include \"led.h\"           // LED functions (e.g., ledSet)\n\n// Main application loop\nvoid appMain(void *param)\n{\n    // Infinite loop (runs continuously while the quadcopter is powered on)\n    while (true)\n    {\n        // Turn on left green led\n        ledSet(LED_GREEN_L, true);\n        // Wait for 100 milliseconds (2 Hz loop)\n        vTaskDelay(pdMS_TO_TICKS(500));\n        // Turn off left green led\n        ledSet(LED_GREEN_L, false);\n        // Wait for 100 milliseconds (2 Hz loop)\n        vTaskDelay(pdMS_TO_TICKS(500));\n    }\n}\n</code></pre> hello_world.c<pre><code>#include \"FreeRTOS.h\"      // FreeRTOS core definitions (needed for task handling and timing)\n#include \"task.h\"          // FreeRTOS task functions (e.g., vTaskDelay)\n#include \"debug.h\"         // Debug printing functions (e.g., DEBUG_PRINT)\n\n// Main application loop\nvoid appMain(void *param)\n{\n    // Infinite loop (runs continuously while the quadcopter is powered on)\n    while (true)\n    {\n        // Print message to console\n        DEBUG_PRINT(\"Hello world!\\n\");\n        // Wait for 100 milliseconds (2 Hz loop)\n        vTaskDelay(pdMS_TO_TICKS(500));\n    }\n}\n</code></pre> <p>Definimos qual o programa que vamos compilar atrav\u00e9s do arquivo <code>Kbuild</code>:</p> Kbuild<pre><code>obj-y += src/examples/led_blink.o\n</code></pre> <p>Conforme formos desenvolvendo novos programas, n\u00e3o podemos esquecer de atualizar o arquivo <code>Kbuild</code> com o nome do programa que queremos compilar. </p> <p>Aten\u00e7\u00e3o</p> <p>Note que a extens\u00e3o do arquivo aqui \u00e9 <code>.o</code> e n\u00e3o <code>.c</code>. O importante \u00e9 o nome do programa estar igual.</p>"},{"location":"pages/setup/firmware/#configurando","title":"Configurando","text":"<p>Agora que voc\u00ea j\u00e1 tem o c\u00f3digo na sua m\u00e1quina, vamos ajustar algumas configura\u00e7\u00f5es importantes: o canal de r\u00e1dio que ser\u00e1 usado para comunica\u00e7\u00e3o e a plataforma de hardware do drone. Esses ajustes garantem que tudo esteja alinhado com o seu Crazyflie antes de compilar o c\u00f3digo.</p>"},{"location":"pages/setup/firmware/#radio","title":"Radio","text":"<ol> <li> <p>Abra o arquivo <code>radio.config</code></p> </li> <li> <p>Altere o canal do r\u00e1dio conforme a numera\u00e7\u00e3o do seu Crazyflie.  radio.config<pre><code>RADIO_CHANNEL=1\n</code></pre></p> </li> </ol>"},{"location":"pages/setup/firmware/#submodulo","title":"Subm\u00f3dulo","text":"<ol> <li> <p>Navegue at\u00e9 a p\u00e1gina <code>crazyflie-firmware/src/modules/src</code> e abra o arquivo <code>stabilizer.c</code>.</p> </li> <li> <p>Comente as linhas 223-226, 326 e 356, conforme abaixo<sup>2</sup>: stabilizer.c<pre><code>static void setMotorRatios(const motors_thrust_pwm_t* motorPwm)\n{\n  // motorsSetRatio(MOTOR_M1, motorPwm-&gt;motors.m1);\n  // motorsSetRatio(MOTOR_M2, motorPwm-&gt;motors.m2);\n  // motorsSetRatio(MOTOR_M3, motorPwm-&gt;motors.m3);\n  // motorsSetRatio(MOTOR_M4, motorPwm-&gt;motors.m4);\n}\n</code></pre> stabilizer.c<pre><code>      //stateEstimator(&amp;state, stabilizerStep);\n</code></pre> stabilizer.c<pre><code>      } else {\n        // motorsStop();\n      }\n</code></pre></p> </li> </ol>"},{"location":"pages/setup/firmware/#plataforma","title":"Plataforma","text":"<ol> <li>Configure o firmware para a plataforma do Crazyflie 2.1 Brushless rodando o seguinte c\u00f3digo no terminal: <pre><code>make cf21bl_defconfig\n</code></pre></li> </ol>"},{"location":"pages/setup/firmware/#compilando","title":"Compilando","text":"<p>Com o c\u00f3digo ajustado, \u00e9 hora de transformar ele em algo que o drone entenda. Vamos compilar o firmware e envi\u00e1-lo para o Crazyflie. Esse processo ser\u00e1 repetido sempre que voc\u00ea quiser testar uma nova vers\u00e3o do seu programa.</p>"},{"location":"pages/setup/firmware/#build","title":"Build","text":"<ol> <li>Compile o firmware: <pre><code>make\n</code></pre></li> </ol>"},{"location":"pages/setup/firmware/#flash","title":"Flash","text":"<ol> <li> <p>Programe o firmware no Crazyflie: <pre><code>make cload\n</code></pre></p> <p>Aten\u00e7\u00e3o</p> <ul> <li>O Crazyflie 2.1 Brushless precisa estar ligado</li> <li>O Crazyradio PA precisa estar conectado na porta USB</li> </ul> </li> </ol>"},{"location":"pages/setup/firmware/#testando","title":"Testando","text":"<p>Tudo pronto! Agora vamos conectar no drone com o Crazyflie Client e verificar se ele est\u00e1 rodando o seu c\u00f3digo corretamente. Se tudo estiver certo, voc\u00ea ver\u00e1 as mensagens aparecendo no console \u2014 e o seu drone estar\u00e1 oficialmente sob seu controle.</p> <ol> <li>Abra o Crazyflie Client <pre><code>cfclient\n</code></pre></li> <li> <p>Clique no bot\u00e3o <code>Scan</code> </p> </li> <li> <p>Selecione o Crazyflie correspondente</p> </li> <li> <p>Clique no bot\u00e3o <code>Connect</code></p> </li> <li> <p>Verifique se o quadricoptero est\u00e1 respondendo (tens\u00e3o da bateria, estado dos sensores, etc.)</p> </li> <li> <p>Clique em <code>View</code> &gt; <code>Toolboxes</code> &gt; <code>Console</code></p> </li> <li> <p>Verifique se aparecem as mensagens do seu c\u00f3digo (\"Hello world!\")</p> </li> </ol> <p>Caso n\u00e3o apare\u00e7a, muito provavelmente \u00e9 por que voc\u00ea est\u00e1 rodando o programa <code>led_blink.c</code> e n\u00e3o <code>hello_world.c</code>. Modifique seu arquivo <code>Kbuild</code> para o programa correto e, em seguida, compile e envie o programa para o quadricoptero.</p> <ol> <li> <p>Subm\u00f3dulos do Git s\u00e3o como \"reposit\u00f3rios dentro de reposit\u00f3rios\". Esse comando garante que voc\u00ea tenha o c\u00f3digo do firmware oficial (<code>crazyflie-firmware</code>) que est\u00e1 referenciado como subm\u00f3dulo.\u00a0\u21a9</p> </li> <li> <p>Fazemos isso para contornar o algoritmo propriet\u00e1rio do controlador do Crazyflie (ele vai continuar rodando em segundo plano, mas vamos ignorar seus comandos para podermos usar os nossos).\u00a0\u21a9</p> </li> </ol>"},{"location":"pages/setup/hardware/","title":"Hardware","text":"<p>Neste curso, voc\u00ea vai programar um drone real e ver ele voar com os algoritmos que voc\u00ea mesmo desenvolveu. Mas, pra isso, voc\u00ea precisa de um conjunto espec\u00edfico de equipamentos \u2014 compactos, mas poderosos.</p> <p>Se voc\u00ea est\u00e1 matriculado na eletiva, tudo isso ser\u00e1 fornecido a voc\u00ea. Mas \u00e9 importante entender o que \u00e9 cada componente, por que eles s\u00e3o essenciais e como se conectam.</p>"},{"location":"pages/setup/hardware/#crazyflie-21-brushless","title":"Crazyflie 2.1 Brushless","text":"<p>O Crazyflie 2.1 Brushless \u00e9 o cora\u00e7\u00e3o do sistema: um minidrone open-source com a estrutura baseada numa placa de circuito impresso (PCB). Compacto, robusto e com:</p> <ul> <li>Processador ARM (Cortex-M4 168 MHz)</li> <li>Motores BLDC (08028-10000KV)</li> <li>Controladores dos motores BLDC (5A ESCs)</li> <li>IMU embutida (BMI088)</li> </ul> <p>A vers\u00e3o brushless foi lan\u00e7ada recentemente (2025) e traz mais pot\u00eancia e durabilidade para os motores.</p>"},{"location":"pages/setup/hardware/#crazyradio-20","title":"Crazyradio 2.0","text":"<p>O Crazyradio 2.0 \u00e9 um dongle que permite comunica\u00e7\u00e3o sem fio entre o seu computador e o drone. Com ele, voc\u00ea pode:</p> <ul> <li>Fazer upload de firmware</li> <li>Enviar comandos em tempo real</li> <li>Receber dados da telemetria</li> </ul> <p>Ele se conecta via USB e funciona com as ferramentas oficiais da Bitcraze.</p>"},{"location":"pages/setup/hardware/#flow-deck-v2","title":"Flow deck v2","text":"<p>O Flow deck v2 \u00e9 um pequeno m\u00f3dulo que se encaixa embaixo do drone e adiciona dois sensores fundamentais para o voo aut\u00f4nomo:</p> <ul> <li>Proximidade (VL53L1x)</li> <li>Fluxo \u00f3ptico (PMW3901)</li> </ul> <p>Com eles, o drone consegue medir a altura em rela\u00e7\u00e3o ao ch\u00e3o e o deslocamente lateral com base no movimento do solo \u2014 o que \u00e9 essencial para estimar sua posi\u00e7\u00e3o no espa\u00e7o.</p>"},{"location":"pages/setup/hardware/#resumo-do-kit","title":"Resumo do kit","text":"<p>Esses componentes tamb\u00e9m s\u00e3o oferecidos na forma de um kit pela Bitcraze, o STEM bundle - Crazyflie 2.1 Brushless. Voc\u00ea receber\u00e1 exatamente esse kit:</p> <ul> <li>Crazyflie 2.1 Brushless  </li> <li>Crazyradio 2.0  </li> <li>Flow Deck v2  </li> </ul> <p>Al\u00e9m de cabos e acess\u00f3rios, com tudo pronto para transformar c\u00f3digo em voo real. \ud83d\ude80</p>"},{"location":"pages/setup/software/","title":"Software","text":"<p>Antes de come\u00e7ar a programar o drone, vamos instalar os programas e componentes que o ambiente de desenvolvimento precisa para funcionar direitinho.</p> <p>Siga cada passo com aten\u00e7\u00e3o, conforme seu sistema operacional, para garantir que tudo fique pronto e funcionando sem problemas.</p>"},{"location":"pages/setup/software/#git","title":"Git","text":"WindowsMac <ol> <li> <p>Baixe o Git em seu site oficial e instale-o.</p> </li> <li> <p>Verifique a instala\u00e7\u00e3o do Git pelo PowerShell: <pre><code>git --version\n</code></pre></p> </li> </ol> <p>O Mac j\u00e1 vem de f\u00e1brica com o Git instalado.</p>"},{"location":"pages/setup/software/#python","title":"Python","text":"WindowsMac <p>Aten\u00e7\u00e3o</p> <p>N\u00e3o pule essa etapa mesmo que voc\u00ea j\u00e1 tenha uma distribui\u00e7\u00e3o do Python instalada em seu computador, pois precisar\u00e1 instalar uma distribui\u00e7\u00e3o espec\u00edfica (3.11.9) para tudo funcionar. Mas fique tranquilo, qualquer distribui\u00e7\u00e3o j\u00e1 instalada continuar\u00e1 funcionando normalmente.</p> <ol> <li> <p>Baixe o Python 3.11.9 em seu site oficial e instale-o.</p> </li> <li> <p>Certifique-se de marcar a caixa <code>[\u2713] Add python.exe to PATH</code> durante a instala\u00e7\u00e3o.</p> </li> <li> <p>Verifique a instala\u00e7\u00e3o do Python e do PIP (Gerenciador de Pacotes Python) pelo PowerShell: <pre><code>python --version\npip --version\n</code></pre></p> </li> </ol> <p>O Mac j\u00e1 vem de f\u00e1brica com o Python instalado.</p>"},{"location":"pages/setup/software/#crazyflie-client","title":"Crazyflie Client","text":"WindowsMac <ol> <li> <p>Instale o Crazyflie Client usando o PIP pelo PowerShell: <pre><code>pip install cfclient\n</code></pre></p> </li> <li> <p>Verifique a instala\u00e7\u00e3o do Crazyflie Client abrindo ele pelo PowerShell: <pre><code>cfclient\n</code></pre></p> </li> </ol> <p>Dica</p> <p>Caso prefira criar um \u00edcone na \u00e1rea de trabalho para o Crazyflie Client, siga o passo a passo abaixo:</p> <ol> <li> <p>Clique com o bot\u00e3o direito na \u00e1rea de trabalho e depois em <code>Novo</code> &gt; <code>Atalho</code></p> </li> <li> <p>No campo de destino, coloque \"cfclient\" e clique em <code>Avan\u00e7ar</code></p> </li> <li> <p>No campo de nome, coloque \"Crazyflie Client\" e clique em <code>Concluir</code></p> </li> </ol> <ol> <li> <p>Instale o Crazyflie Client pelo Terminal: <pre><code>python3 -m pip install cfclient\n</code></pre></p> </li> <li> <p>Verifique a instala\u00e7\u00e3o do Crazyflie Client abrindo ele pelo Terminal: <pre><code>cfclient\n</code></pre></p> </li> </ol> <p>Aten\u00e7\u00e3o</p> <p>Caso o comando acima n\u00e3o abra o Crazyflie Client, pode ser que seu endere\u00e7o n\u00e3o esteja no PATH. Para verificar onde ele foi instalado e colocar ele no PATH, basta rodar o comando abaixo no Terminal<sup>1</sup>: <pre><code>cfclient_path=$(dirname $(which cfclient)) &amp;&amp; echo \"export PATH=\\\"$cfclient_path:\\$PATH\\\"\" &gt;&gt; ~/.zshrc\n</code></pre></p> <p>Dica</p> <p>Caso prefira criar um \u00edcone na mesa para o Crazyflie Client, siga o passo a passo abaixo:</p> <ol> <li> <p>Abra o Automator</p> </li> <li> <p>Clique em <code>Novo Documento</code> &gt; <code>Aplicativo</code></p> </li> <li> <p>Na biblioteca de a\u00e7\u00f5es, d\u00ea duplo clique em <code>Executar Script de Shell</code></p> </li> <li> <p>No campo de script, cole: <pre><code>python3 -m cfclient.gui\n</code></pre></p> </li> <li> <p>Clique em <code>Arquivo</code> &gt; <code>Salvar</code></p> </li> <li> <p>No campo de nome, coloque \"Crazyflie Client\" e clique em <code>Concluir</code></p> </li> </ol>"},{"location":"pages/setup/software/#arm-toolchain","title":"ARM Toolchain","text":"WindowsMac <ol> <li> <p>Instale o WSL (Subsistema do Windows para Linux) pelo PowerShell executando ele como administrador: <pre><code>wsl --install\n</code></pre></p> </li> <li> <p>Ap\u00f3s a instala\u00e7\u00e3o, reinicie o computador.</p> </li> <li> <p>Depois que o computador tiver reiniciado, ele abrir\u00e1 automaticamente o terminal WSL (Ubuntu). Caso ele n\u00e3o abra, voc\u00ea pode abri-lo pelo PowerShell: <pre><code>wsl\n</code></pre></p> </li> <li> <p>Na primeira vez, ser\u00e1 solicitado que voc\u00ea crie um nome de usu\u00e1rio para o Linux e defina uma senha (n\u00e3o necessariamente a mesma do Windows). </p> <p>Aten\u00e7\u00e3o</p> <p>Os comandos a seguir devem ser executados no terminal WSL (Ubuntu) e n\u00e3o no PowerShell</p> </li> <li> <p>Atualize a lista de pacotes: <pre><code>sudo apt update\n</code></pre></p> </li> <li> <p>Instale o Make: <pre><code>sudo apt install make \n</code></pre></p> </li> <li> <p>Verifique a instala\u00e7\u00e3o do Make: <pre><code>make --version\n</code></pre></p> </li> <li> <p>Instale o toolchain ARM embarcado: <pre><code>sudo apt install gcc-arm-none-eabi\n</code></pre></p> </li> <li> <p>Verifique a instala\u00e7\u00e3o do toolchain ARM embarcado: <pre><code>arm-none-eabi-gcc --version\n</code></pre></p> </li> <li> <p>Instale o toolchain GCC: <pre><code>sudo apt install gcc\n</code></pre></p> </li> <li> <p>Verifique a instala\u00e7\u00e3o do toolchain GCC: <pre><code>gcc --version\n</code></pre></p> </li> </ol> <ol> <li> <p>Instale o Homebrew: <pre><code>/bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\"\n</code></pre></p> </li> <li> <p>Verifique a instala\u00e7\u00e3o do Homebrew: <pre><code>brew --version\n</code></pre></p> </li> <li> <p>Instale o toolchain ARM embarcado: <pre><code>brew install gcc-arm-embedded\n</code></pre></p> </li> <li> <p>Adicione-o ao PATH<sup>1</sup>: <pre><code>echo 'export PATH=\"/opt/homebrew/bin:$PATH\"' &gt;&gt; ~/.zshrc\n</code></pre></p> </li> <li> <p>Verifique a instala\u00e7\u00e3o do toolchain ARM embarcado: <pre><code>arm-none-eabi-gcc --version\n</code></pre></p> </li> <li> <p>Instale os utilit\u00e1rios do GNU Core: <pre><code>brew install coreutils\n</code></pre></p> </li> <li> <p>Adicione-o ao PATH<sup>1</sup>: <pre><code>echo 'export PATH=\"/opt/homebrew/opt/coreutils/libexec/gnubin:$PATH\"' &gt;&gt; ~/.zshrc\n</code></pre></p> </li> <li> <p>Verifique a instala\u00e7\u00e3o do GNU Core: <pre><code>gdate --version\n</code></pre></p> </li> </ol> <ol> <li> <p>Reinicie o Terminal depois para a altera\u00e7\u00e3o fazer efeito.\u00a0\u21a9\u21a9\u21a9</p> </li> </ol>"}]}