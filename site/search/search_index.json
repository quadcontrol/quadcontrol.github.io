{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Bem-vindo!","text":"<p>Este site re\u00fane toda a documenta\u00e7\u00e3o da eletiva de Drones do Insper \u2014 uma esp\u00e9cie de apostila online, cuidadosamente organizada com:</p> <ul> <li>\ud83d\udcda Explica\u00e7\u00f5es te\u00f3ricas e f\u00f3rmulas fundamentais</li> <li>\ud83d\udcbb C\u00f3digos em C, Python e MATLAB</li> <li>\ud83d\uddbc\ufe0f Figuras, diagramas e v\u00eddeos demonstrativos</li> <li>\ud83d\udef8 Exemplos de aplica\u00e7\u00f5es pr\u00e1ticas</li> </ul> <p>Nosso objetivo \u00e9 ensinar conceitos de controle, estima\u00e7\u00e3o e sistemas embarcados de forma pr\u00e1tica e acess\u00edvel, usando um quadricoptero real em laborat\u00f3rio. Explore os t\u00f3picos no menu lateral \u2014 e boa jornada! \ud83d\ude80</p>"},{"location":"#sobre-a-eletiva","title":"Sobre a eletiva","text":"<p>Nesta eletiva, os alunos desenvolvem do zero todo o algoritmo de estima\u00e7\u00e3o e controle de um quadric\u00f3ptero \u2014 o Bitcraze Crazyflie 2.1 Brushless.</p> <p></p> <p>A jornada come\u00e7a com os cl\u00e1ssicos <code>led_blink.c</code> e <code>hello_world.c</code>, e termina com o drone voando sozinho. Ao longo do curso, o aluno:</p> <ul> <li>\ud83e\udde0 Aprende os fundamentos da programa\u00e7\u00e3o embarcada com FreeRTOS</li> <li>\ud83d\udce1 Trabalha com sensores como IMU, Lidar e fluxo \u00f3ptico</li> <li>\u2699\ufe0f Controla motores BLDC via PWM</li> <li>\ud83d\udcbb Implementa em C algoritmos de controle e estima\u00e7\u00e3o de estados</li> </ul> <p>A avalia\u00e7\u00e3o \u00e9 100% pr\u00e1tica: ao final do curso, o drone deve voar at\u00e9 um dos helipontos, cada um com uma nota associada \u00e0 sua dificuldade - quanto mais longe ou de dif\u00edcil acesso o heliponto, maior sua m\u00e9dia final na disciplina.</p> <p></p> <p>Quer ver um pouco disso na pr\u00e1tica? Assista o v\u00eddeo abaixo!</p>"},{"location":"basic_concepts/aerodynamics/","title":"Aerodin\u00e2mica","text":"<p>Esta se\u00e7\u00e3o introduz alguns conceitos b\u00e1sicos sobre aerodin\u00e2mica que s\u00e3o essenciais para entender a f\u00edsica de um drone.</p>"},{"location":"basic_concepts/aerodynamics/#aerofolio","title":"Aerof\u00f3lio","text":"<p>O modelo matem\u00e1tico de um drone, qualquer que seja seu tipo, cont\u00e9m diversos par\u00e2metros aerodin\u00e2micos. No entanto, para obter o conhecimento necess\u00e1rio, come\u00e7aremos examinando as for\u00e7as aerodin\u00e2micas em um aerof\u00f3lio.</p>"},{"location":"basic_concepts/aerodynamics/#forcas-aerodinamicas","title":"For\u00e7as aerodin\u00e2micas","text":"<p>A figura abaixo mostra a sec\u00e7\u00e3o transversal de um aerof\u00f3lio, um corpo te\u00f3rico moldado para produzir sustenta\u00e7\u00e3o quando colocado em um fluxo de ar.</p> <p></p> <p>Apesar de um aerof\u00f3lio ser projetado para produzir uma for\u00e7a desejada de sustenta\u00e7\u00e3o \\(f_l\\) (perpendicular \u00e0 velocidade \\(v\\)), ele tamb\u00e9m produz uma for\u00e7a indesejada de arrasto \\(f_d\\) (paralela \u00e0 velocidade \\(v\\)): $$     f_l = \\frac{1}{2} \\rho A C_l v^2      \\qquad     f_d = \\frac{1}{2} \\rho A C_d v^2  $$</p> <p>Onde:</p> <ul> <li>\\(\\rho\\) - Densidade do ar (\\(kg/m^3\\))</li> <li>\\(A\\) - \u00c1rea de superf\u00edcie (\\(m^2\\))</li> <li>\\(C_l\\) - Coeficiente de sustenta\u00e7\u00e3o (adimensional)</li> <li>\\(C_d\\) - Coeficiente de arrasto (adimensional)</li> <li>\\(v\\) - Velocidade linear do aerof\u00f3lio (\\(m/s\\))</li> </ul>"},{"location":"basic_concepts/aerodynamics/#coeficientes-aerodinamicos","title":"Coeficientes aerodin\u00e2micos","text":"<p>Os coeficientes de sustenta\u00e7\u00e3o e arrasto n\u00e3o s\u00e3o constantes, eles variam conforme as seguintes condi\u00e7\u00f5es aerodin\u00e2micas:</p> <ul> <li>\u00c2ngulo de ataque (\\(\\alpha\\)), que \u00e9 o \u00e2ngulo que a linha m\u00e9dia do aerof\u00f3lio (tamb\u00e9m chamada de ``corda'') faz com o vetor velocidade</li> <li>N\u00famero de Reynolds (\\(\\frac{\\rho v D}{\\mu}\\)), que \u00e9 uma medida adimensional e define o regime de escoamento do ar (laminar ou turbulento)</li> <li>N\u00famero Mach (\\(\\frac{v}{v_s}\\)), que \u00e9 a raz\u00e3o entre a velocidade e a velocidade do som e define o regime de velocidade (subs\u00f4nica, supers\u00f4nica e hipers\u00f4nica)</li> </ul> <p>Para aerof\u00f3lios que se movem a velocidades subs\u00f4nicas (\\(&lt;1.000km/h\\)), apenas o \u00e2ngulo de ataque \\(\\alpha\\), representado na figura abaixo, acaba apresentando uma influ\u00eancia significativa.</p> <p></p> <p>H\u00e1 diversos perfils diferentes para um aerfof\u00f3lio. Um bastante conhecido e utilizado \u00e9 o perfil Clark Y, cujos coeficientes de arrasto e sustenta\u00e7\u00e3o em fun\u00e7\u00e3o do \u00e2ngulo de ataque s\u00e3o bem conhecidos e dados<sup>1</sup> pelo gr\u00e1fico abaixo.</p> <p></p> <p>Enquanto o coeficiente de arrasto s\u00f3 aumenta com o \u00e2ngulo de ataque, o coeficiente de sustenta\u00e7\u00e3o tem um ponto m\u00e1ximo (\\(\\alpha=18^{\\circ}\\)). Esse ponto \u00e9 conhecido como \"estol\" ou simplesmente \"perda de sustenta\u00e7\u00e3o\", e ele ocorre quando o fluxo de ar descola da asa (deixa de seguir o contorno superior da asa gerando uma turbul\u00eancia). Note que o coeficiente de sustenta\u00e7\u00e3o \u00e9 nulo com uma leve inclina\u00e7\u00e3o negativa (\\(\\alpha=-5^{\\circ}\\)), e negativo abaixo disso.</p> <p>Exerc\u00edcio 1</p> <p>Para consolidar esses conceitos, considere um drone de asas fixas (asa voadora) em cruzeiro, isto \u00e9, voando no plano com velocidade constante e as seguintes caracter\u00edsticas<sup>2</sup>:</p> <ul> <li>Massa de \\(40g\\) e comprimento de \\(10cm\\)</li> <li>Asas perfil Clark Y com \\(10cm\\) de envergadura</li> <li>Propulsores com \\(60\\%\\) de efici\u00eancia </li> <li>Bateria de \\(3,7V\\) e \\(350mAh\\)</li> </ul> a) Desenhe o diagrama de corpo livre das for\u00e7as que atuam nesse drone b) Determine a \u00e1rea total das asas do drone assumindo que seu corpo \u00e9 triangular \\[ \\begin{align*}     A &amp;= \\frac{10 \\cdot 10}{2} \\\\     A &amp;= 50 \\text{cm}^2 \\end{align*} \\] c) Determine os coeficientes de arrasto e sustenta\u00e7\u00e3o das asas do drone \\[ \\begin{align*}     C_l &amp;= 0,35 \\\\     C_d &amp;= 0,02 \\end{align*} \\] d) Determine a velocidade do drone \\[ \\begin{align*}     \\sum f_y &amp;= 0 \\\\     f_l - f_p &amp;= 0 \\\\     \\frac{1}{2} \\rho A C_l v^2 - mg &amp;= 0 \\\\     v &amp;= \\sqrt{\\frac{2mg}{\\rho AC_l}} \\\\     v &amp;= \\sqrt{\\frac{2 \\cdot 0,04 \\cdot 9,81}{1,225 \\cdot 50 \\times 10^{-4} \\cdot 0,35}} \\\\     v &amp;= 19,13 \\text{m/s} \\quad (\\approx 69\\text{km/h}) \\end{align*} \\] e) Determine a for\u00e7a de empuxo dos propulsores do drone \\[ \\begin{align*}     \\sum f_x &amp;= 0 \\\\     f_e - f_d &amp;= 0 \\\\     f_e - \\frac{1}{2} \\rho A C_d v^2  &amp;= 0 \\\\     f_e &amp;= \\frac{1}{2} \\rho A C_d v^2 \\\\     f_e &amp;= \\frac{1}{2} 1,225 \\cdot 50 \\times 10^{-4} \\cdot 0,02 \\cdot 19,13^2 \\\\     f_e &amp;= 0,0224 \\text{N} \\end{align*} \\] f) Determine o consumo energ\u00e9tico do drone \\[ \\begin{align*}     P_m &amp;= f_e v \\\\     P_m &amp;= 0,0224 \\cdot 19,13 \\\\     P_m &amp;= 0,429 \\text{W} \\end{align*} \\] \\[ \\begin{align*}     \\eta &amp;= \\frac{P_m}{P_e} \\\\     P_e &amp;= \\frac{P_m}{\\eta} \\\\     P_e &amp;= \\frac{0,429}{0,6} \\\\     P_e &amp;= 0,715 \\text{W} \\end{align*} \\] g) Determine quanto tempo que o drone consegue permanecer no ar \\[ \\begin{align*}     E &amp;= P_e \\Delta t \\\\     e_s i_s &amp;= P_e \\Delta t \\\\     \\Delta t &amp;= \\frac{e_s i_s}{P_e} \\\\     \\Delta t &amp;= \\frac{3,7 \\cdot ( 0,35 \\cdot 3600)}{0,715} \\\\     \\Delta t &amp;= 6.519 \\text{s} \\quad (\\approx 1\\text{h}49\\text{min}) \\end{align*} \\]"},{"location":"basic_concepts/aerodynamics/#helice","title":"H\u00e9lice","text":"<p>Uma h\u00e9lice \u00e9 composta por \\(n\\) p\u00e1s, onde cada p\u00e1 pode ser interpretada como um aerof\u00f3lio.</p>"},{"location":"basic_concepts/aerodynamics/#forcas-e-torques-aerodinamicos","title":"For\u00e7as e torques aerodin\u00e2micos","text":"<p>Quando a h\u00e9lice rotaciona, surgem for\u00e7as de sustenta\u00e7\u00e3o e arrasto em cada uma de suas p\u00e1s, conforme a figura abaixo.</p> <p></p> <p>Onde:</p> <ul> <li>\\(d\\) - Dist\u00e2ncia do centro de press\u00e3o ao eixo de rota\u00e7\u00e3o (\\(m\\))</li> <li>\\(\\omega\\) - Velocidade angular da h\u00e9lice (\\(rad/s\\))</li> </ul> <p>Exerc\u00edcio 2</p> <p>Determine as for\u00e7as de sustenta\u00e7\u00e3o \\(f_l\\) e arrasto \\(f_d\\) nas p\u00e1s da h\u00e9lice em fun\u00e7\u00e3o de sua velocidade angular</p> Resposta \\[ \\begin{align*}     f_l &amp;= \\frac{1}{2} \\rho A C_l v^2 \\\\      f_l &amp;= \\frac{1}{2} \\rho A C_l (\\omega d )^2 \\\\     f_l &amp;= \\frac{1}{2} \\rho A C_l d^2 \\omega^2  \\end{align*} \\] \\[ \\begin{align*}     f_d &amp;= \\frac{1}{2} \\rho A C_d v^2 \\\\      f_d &amp;= \\frac{1}{2} \\rho A C_d (\\omega d )^2 \\\\     f_d &amp;= \\frac{1}{2} \\rho A C_d d^2 \\omega^2  \\end{align*} \\] <p>As for\u00e7as de sustenta\u00e7\u00e3o e arrasto em cada uma das p\u00e1s podem ser representadas por uma \u00fanica for\u00e7a de sustenta\u00e7\u00e3o e torque de arrasto da h\u00e9lice, conforme a figura abaixo.</p> <p></p> <p>Exerc\u00edcio 3</p> <p>Determine a for\u00e7a de sustenta\u00e7\u00e3o \\(f\\) e torque de arrasto \\(\\tau\\) da h\u00e9lice</p> Resposta \\[ \\begin{align*}     f &amp;= 2 f_l \\\\     f &amp;= 2 \\left( \\frac{1}{2} \\rho A C_l d^2 \\omega^2  \\right) \\\\     f &amp;= \\rho A C_l d^2 \\omega^2  \\end{align*} \\] \\[ \\begin{align*}     \\tau &amp;= 2 \\left( d f_d \\right) \\\\      \\tau &amp;= 2 \\left( d \\left( \\frac{1}{2} \\rho A C_d d^2 \\omega^2 \\right) \\right) \\\\     \\tau &amp;= \\rho A C_d d^3 \\omega^2  \\end{align*} \\] <p>Como todos os par\u00e2metros s\u00e3o constantes e apenas a velocidade angular \\(\\omega\\) varia, a for\u00e7a de sustenta\u00e7\u00e3o e torque de arrasto de uma h\u00e9lice podem ser simplificados por:</p> \\[ f = \\underbrace{\\rho A C_l d^2}_{k_l} \\omega^2  \\qquad \\tau = \\underbrace{\\rho A C_d d^3}_{k_d} \\omega^2  \\] <p>Onde:</p> <ul> <li>\\(k_l\\) - Coeficiente de sustenta\u00e7\u00e3o da h\u00e9lice (\\(N.s^2/rad^2\\))</li> <li>\\(k_d\\) - Coeficiente de arrasto da h\u00e9lice (\\(N.m.s^2/rad^2\\))</li> </ul>"},{"location":"basic_concepts/aerodynamics/#constantes-aerodinamicas","title":"Constantes aerodin\u00e2micas","text":"<p>Ou seja, apenas dois par\u00e2metros definem a for\u00e7a e o torque que uma h\u00e9lice produz, que dependem do quadrado de sua velocidade angular:</p> <p></p> \\[ f = k_l \\omega^2  \\qquad \\tau = k_d \\omega^2  \\] <p>Exerc\u00edcio 4</p> <p>Com o aux\u00edlio de uma r\u00e9gua, estime<sup>3</sup> as constantes aerodin\u00e2micas das h\u00e9lices do Bitcraze Crazyflie e anote elas abaixo. Assuma que a h\u00e9lice pode ser aproximada a um perfil Clark Y com \u00e2ngulo de ataque \\(\\alpha = 5^\\circ\\), sendo a constante de sustenta\u00e7\u00e3o igual, por\u00e9m a constante de arrasto 10x maior<sup>4</sup>. </p> Resposta \\[ \\left\\{     \\begin{align*}         \\rho &amp;= 1,225 kg/m^3 \\\\         A &amp;= 2,5 \\cdot 0,5 = 1,25 cm^2 \\\\         d &amp;= 1,5 cm \\\\         C_l &amp;= 0,7 \\\\         C_d &amp;= 0,04 \\cdot 10 = 0,4      \\end{align*} \\right. \\] \\[ \\begin{align*}     k_l &amp;= \\rho A C_l d^2\\\\     k_l &amp;= 1,225 \\cdot (1,25 \\cdot 10^{-4}) \\cdot 0,7 \\cdot (1,5 \\times 10^{-2})^2 \\\\     k_l &amp;= 2,41 \\times10^{-8} \\text{N.s}^2\\text{/rad}^2 \\end{align*} \\] \\[ \\begin{align*}     k_d &amp;= \\rho A C_d d^3 \\\\     k_d &amp;= 1,225 \\cdot (1,25 \\cdot 10^{-4}) \\cdot 0,4 \\cdot (1,5 \\times 10^{-2})^3 \\\\     k_d &amp;= 2,07 \\times10^{-10} \\text{N.m.s}^2\\text{/rad}^2 \\end{align*} \\] <p>Esses dois par\u00e2metros ser\u00e3o determinados experimentalmente (\\(k_l\\) e \\(k_d\\)), e voc\u00ea ver\u00e1 que a chegar\u00e1 em valores muito pr\u00f3ximos aos estimados acima.</p> <p>Exerc\u00edcio 5</p> <p>Para consolidar esses conceitos, considere um drone multi-rotor (quadricoptero) pairando no ar, isto \u00e9, parado no espa\u00e7o com as seguintes caracter\u00edsticas<sup>2</sup>:</p> <ul> <li>Massa de \\(40g\\)</li> <li>H\u00e9lices com constante de sustenta\u00e7\u00e3o de \\(2,0\\times10^{-8} \\text{N}.\\text{s}^2/\\text{rad}^2\\) e constante de arrasto de \\(2,0\\times10^{-10} \\text{N}.\\text{m}.\\text{s}^2\\text{/rad}^2\\)</li> <li>Motores el\u00e9tricos com \\(90\\%\\) de efici\u00eancia </li> <li>Bateria de \\(3,7V\\) e \\(350mAh\\)</li> </ul> a) Desenhe o diagrama de corpo livre das for\u00e7as que atuam nesse drone b) Determine a velocidade angular das h\u00e9lices do drone \\[ \\begin{align*}     \\sum f_y &amp;= 0 \\\\     4 f - f_w &amp;= 0 \\\\     4 k_l \\omega^2 - mg &amp;= 0 \\\\     \\omega &amp;= \\sqrt{\\frac{mg}{4 k_l}} \\\\     \\omega &amp;= \\sqrt{\\frac{0,04 \\cdot 9,81}{4 \\cdot (2,0\\times10^{-8})}} \\\\     \\omega &amp;= 2.215 \\text{rad/s} \\quad (\\approx 21.149\\text{rpm}) \\end{align*} \\] c) Determine o torque dos motores do drone \\[ \\begin{align*}     \\sum \\tau &amp;= 0 \\\\     \\tau_m - \\tau_d &amp;= 0 \\\\     \\tau_m - k_d \\omega^2 &amp;= 0 \\\\     \\tau_m &amp;= k_d \\omega^2 \\\\     \\tau_m &amp;= 2,0 \\times 10 ^{-10} \\cdot 2215^2 \\\\     \\tau_m &amp;= 0,000981 \\text{N.m} \\\\ \\end{align*} \\] d) Determine o consumo energ\u00e9tico do drone \\[ \\begin{align*}     P_m &amp;= 4 \\tau_m \\omega \\\\     P_m &amp;= 4 \\cdot 0,000981 \\cdot 2215 \\\\     P_m &amp;= 8,69 \\text{W} \\end{align*}    \\] \\[ \\begin{align*}     \\eta &amp;= \\frac{P_m}{P_e} \\\\     P_e &amp;= \\frac{P_m}{\\eta} \\\\     P_e &amp;= \\frac{8,69}{0,9} \\\\     P_e &amp;= 9,66 \\text{W} \\end{align*} \\] e) Determine quanto tempo que o drone consegue permanecer no ar \\[ \\begin{align*}     E &amp;= P_e \\Delta t \\\\     e_s i_s &amp;= P_e \\Delta t \\\\     \\Delta t &amp;= \\frac{e_s i_s}{P_e} \\\\     \\Delta t &amp;= \\frac{3,7 (\\cdot 0,35 \\cdot 3600)}{9,66} \\\\     \\Delta t &amp;= 483\\text{s} \\quad (\\approx 8\\text{min}) \\end{align*} \\] <p>Compare este resultado, do drone multi rotor, com o anterior, do drone de asas fixa. Note como o drone de asa fixa consegue permanecer muito mais tempo no ar (&gt;10x), com a desvatagem de n\u00e3o conseguir permanecer parado e nem decolar/pousar na vertical como um drone multi-rotor.</p> <ol> <li> <p>Assumindo que o n\u00famero de Reynolds e o n\u00famero Mach permane\u00e7am dentro de uma determinada faixa de valores.\u00a0\u21a9</p> </li> <li> <p>Considere \\(g = 9,81\\text{m/s}^2\\) e \\(\\rho = 1,225\\text{kg/m}^3\\) \u21a9\u21a9</p> </li> <li> <p>Estamos preocupados apenas com a ordem de grandeza dos resultados.\u00a0\u21a9</p> </li> <li> <p>Devido \u00e0 turbul\u00eancia gerada pela h\u00e9lice.\u00a0\u21a9</p> </li> </ol>"},{"location":"basic_concepts/mixer/","title":"Mixer","text":"<p>Esta se\u00e7\u00e3o descreve as for\u00e7as e torques que atuam em um quadric\u00f3ptero e como elas influenciam o seu comportamento din\u00e2mico.</p>"},{"location":"basic_concepts/mixer/#movimentos-basicos-de-um-quadricoptero","title":"Movimentos b\u00e1sicos de um quadric\u00f3ptero","text":"<p>Um quadric\u00f3ptero possui 4 h\u00e9lices que, uma vez em movimento com velocidades angulares \\(\\omega_1\\), \\(\\omega_2\\), \\(\\omega_3\\) e \\(\\omega_4\\), produzem 4 for\u00e7as de sustenta\u00e7\u00e3o \\(f_1\\), \\(f_2\\), \\(f_3\\) e \\(f_4\\) e 4 torques de arrasto \\(\\tau_1\\), \\(\\tau_2\\), \\(\\tau_3\\) e \\(\\tau_4\\), conforme a figura abaixo.</p> <p></p> <p>Para um quadric\u00f3ptero se movimentar verticalmente, basta variar as velocidades angulares das 4 h\u00e9lices simultaneamente, conforme a figura abaixo.</p> <p>Enquanto que, para um quadric\u00f3ptero rotacionar em torno de seus eixos, basta variar as velocidades angulares de 2 h\u00e9lices simultaneamente, conforme a figura abaixo.</p> <p>Exerc\u00edcio 1</p> <p>Sobre os movimentos de um quadric\u00f3ptero, determine as respostas a seguir. </p> a) Quantas formas diferentes \u00e9 poss\u00edvel transladar um quadric\u00f3ptero <p>3 (ao longo dos eixos \\(x\\), \\(y\\) e \\(z\\))</p> b) Quantas formas diferentes \u00e9 poss\u00edvel rotacionar um quadric\u00f3ptero <p>3 (em torno dos eixos \\(x\\), \\(y\\) e \\(z\\)) </p> c) Quantos graus de liberdade possui um quadric\u00f3ptero <p>6 (3 de transla\u00e7\u00e3o + 3 de rota\u00e7\u00e3o) </p> d) Como o quadric\u00f3ptero realiza movimentos de transla\u00e7\u00e3o no plano (eixos \\(x\\) e \\(y\\)) <p>Atrav\u00e9s de uma composi\u00e7\u00e3o de movimentos de transla\u00e7\u00e3o (ao longo do eixo \\(z\\)) e rota\u00e7\u00e3o (em torno dos eixos \\(x\\) e \\(y\\)) </p>"},{"location":"basic_concepts/mixer/#transformacao-de-entradas","title":"Transforma\u00e7\u00e3o de entradas","text":"<p>As 4 for\u00e7as \\(f_i\\) e 4 torques \\(\\tau_i\\) das h\u00e9lices podem ser representadas por 1 \u00fanica for\u00e7a de propuls\u00e3o total \\(f_t\\) e 3 torques \\(\\tau_x\\), \\(\\tau_y\\) e \\(\\tau_z\\), um em torno de cada eixo do quadric\u00f3ptero, conforme a figura abaixo.</p> <p></p> <p>Na sec\u00e7\u00e3o de aerodin\u00e2mica verificamos que as for\u00e7as e torques das h\u00e9lices s\u00e3o proporcionais ao quadrado de suas velocidades angulares:</p> \\[ \\left\\{ \\begin{array}{l}     f_i = k_l \\omega_i^2 \\\\     \\tau_i = k_d \\omega_i^2 \\\\ \\end{array} \\right. \\] <p>Isso significa que as 4 equa\u00e7\u00f5es determinadas anteriormente podem ser escritas no formato matricial:</p> \\[ \\begin{bmatrix}     f_t \\\\     \\tau_x \\\\     \\tau_y \\\\     \\tau_z \\end{bmatrix} = M  \\begin{bmatrix}     \\omega_1^2 \\\\     \\omega_2^2 \\\\     \\omega_3^2 \\\\     \\omega_4^2 \\end{bmatrix} \\] <p>Onde \\(M\\) \u00e9 uma matriz \\(4\\times4\\) que transforma as velocidades angulares das h\u00e9lices na for\u00e7a total e nos torques de um quadric\u00f3ptero.</p> <p>Exerc\u00edcio 2</p> <p>Determine a matriz \\(M\\) em fun\u00e7\u00e3o das constantes de sustenta\u00e7\u00e3o e arrasto da h\u00e9lice \\(k_l\\) e \\(k_d\\) e do comprimento \\(l\\). </p> Resposta \\[ M =  \\begin{bmatrix}      k_l &amp; k_l &amp; k_l &amp; k_l \\\\      -k_l l &amp; -k_l l &amp; k_l l &amp; k_l l \\\\      -k_l l &amp; k_l l &amp; k_l l &amp; -k_l l  \\\\      -k_d &amp; k_d &amp; -k_d &amp; k_d  \\end{bmatrix} \\] <p>Para obter as velocidades angulares das h\u00e9lices em fun\u00e7\u00e3o da for\u00e7a total e dos torques, basta multiplicar a equa\u00e7\u00e3o anterior pela matriz inversa \\(M^{-1}\\):</p> \\[ \\begin{bmatrix}     \\omega_1^2 \\\\     \\omega_2^2 \\\\     \\omega_3^2 \\\\     \\omega_4^2 \\end{bmatrix} = M^{-1}  \\begin{bmatrix}     f_t \\\\     \\tau_x \\\\     \\tau_y \\\\     \\tau_z \\end{bmatrix} \\] <p>Exerc\u00edcio 3</p> <p>Determine a matriz inversa \\(M^{-1}\\) (dica: utilize o Symbolic Math Toolbox do MATLAB).</p> Resposta \\[ M^{-1} =  \\begin{bmatrix}      \\frac{1}{4 k_l} &amp; - \\frac{1}{4 k_l l} &amp; - \\frac{1}{4 k_l l} &amp; - \\frac{1}{4 k_d}  \\\\      \\frac{1}{4 k_l} &amp; - \\frac{1}{4 k_l l} &amp; \\frac{1}{4 k_l l} &amp; \\frac{1}{4 k_d} \\\\      \\frac{1}{4 k_l} &amp; \\frac{1}{4 k_l l} &amp; \\frac{1}{4 k_l l} &amp; - \\frac{1}{4 k_d} \\\\      \\frac{1}{4 k_l} &amp; \\frac{1}{4 k_l l} &amp; - \\frac{1}{4 k_l l} &amp; \\frac{1}{4 k_d}  \\end{bmatrix} \\]"},{"location":"first_steps/firmware/","title":"Firmware","text":"<p>Esta sec\u00e7\u00e3o cont\u00e9m as instru\u00e7\u00f5es para clonar, configurar, compilar e testar o firmware do Crazyflie.</p>"},{"location":"first_steps/firmware/#visual-studio-code","title":"Visual Studio Code","text":"<p>Vamos utilizar o Visual Studio Code como IDE (Ambiente de Desenvolvimento Integrado).</p> <ol> <li>Baixe o Visual Studio Code em seu site oficial e instale-o.</li> </ol>"},{"location":"first_steps/firmware/#clonando","title":"Clonando","text":"<p>Vamos criar uma c\u00f3pia do reposit\u00f3rio do firmware para que voc\u00ea possa modific\u00e1-lo e compilar localmente.</p>"},{"location":"first_steps/firmware/#fork","title":"Fork","text":"<ol> <li>Crie um fork do reposit\u00f3rio que cont\u00e9m o firmware para a sua conta do GitHub.</li> </ol>"},{"location":"first_steps/firmware/#clone","title":"Clone","text":"<ol> <li> <p>Abra o Visual Studio Code</p> </li> <li> <p>Clique em <code>Clone Git Repository...</code></p> </li> <li> <p>Coloque o endere\u00e7o do reposit\u00f3rio forkado para sua conta do GitHub: <pre><code>https://github.com/username/quadcontrol-firmware.git\n</code></pre></p> <p>Aten\u00e7\u00e3o</p> <p>Voc\u00ea deve substituir <code>username</code> pelo seu nome de usu\u00e1rio do GitHub</p> </li> <li> <p>Pressione <code>Enter</code> e selecione o local onde voc\u00ea quer salvar esse reposit\u00f3rio.</p> </li> <li> <p>Quando ele terminar de clonar e perguntar se voc\u00ea gostaria de abrir o reposit\u00f3rio clonado, clique em <code>Open</code>.</p> </li> <li> <p>Abra uma janela do terminal clicando em <code>Terminal</code> &gt; <code>New Terminal</code> (ou usando o atalho <code>Crtl</code>+<code>Shift</code>+<code>'</code>).</p> <p>Aten\u00e7\u00e3o</p> <p>Caso esteja utilizando Windows, ele abre por padr\u00e3o um terminal do PowerShell, mas voc\u00ea deve alternar para um terminal do WSL (Ubuntu): </p> </li> <li> <p>Inicialize todos os subm\u00f3dulos<sup>1</sup> pelo terminal: <pre><code>git submodule update --init --recursive\n</code></pre></p> </li> </ol>"},{"location":"first_steps/firmware/#organizacao","title":"Organiza\u00e7\u00e3o","text":"<p>O firmware \u00e9 composto por 2 pastas e 2 arquivos:</p> <p></p> <p>Vamos entender cada um deles:</p> <ul> <li><code>crazyflie-firmware</code> - Pasta que cont\u00e9m o firmware do Crazyflie, o qual utilizaremos como subm\u00f3dulo</li> <li><code>src</code> - Pasta que cont\u00e9m os programas que vamos desenvolver ao longo do curso</li> <li><code>Kbuild</code> - Arquivo que define o programa que ser\u00e1 compilado</li> <li><code>radio.config</code> - Arquivo que define o canal de r\u00e1dio utilizado para se comunicar com o Crazyflie</li> </ul> <p>A pasta <code>src</code> possui uma subpasta <code>examples</code> com 2 exemplos de programas: <code>led_blink.c</code> e <code>hello_world.c</code>. Abra esses arquivos para ver alguns exemplos de programa bem simples:</p> Led blinkHello world led_blink.c<pre><code>#include \"FreeRTOS.h\"      // FreeRTOS core definitions (needed for task handling and timing)\n#include \"task.h\"          // FreeRTOS task functions (e.g., vTaskDelay)\n#include \"led.h\"           // LED functions (e.g., ledSet)\n\n// Main application loop\nvoid appMain(void *param)\n{\n    // Infinite loop (runs continuously while the quadcopter is powered on)\n    while (true)\n    {\n        // Turn on left green led\n        ledSet(LED_GREEN_L, true);\n        // Wait for 100 milliseconds (2 Hz loop)\n        vTaskDelay(pdMS_TO_TICKS(500));\n        // Turn off left green led\n        ledSet(LED_GREEN_L, false);\n        // Wait for 100 milliseconds (2 Hz loop)\n        vTaskDelay(pdMS_TO_TICKS(500));\n    }\n}\n</code></pre> hello_world.c<pre><code>#include \"FreeRTOS.h\"      // FreeRTOS core definitions (needed for task handling and timing)\n#include \"task.h\"          // FreeRTOS task functions (e.g., vTaskDelay)\n#include \"debug.h\"         // Debug printing functions (e.g., DEBUG_PRINT)\n\n// Main application loop\nvoid appMain(void *param)\n{\n    // Infinite loop (runs continuously while the quadcopter is powered on)\n    while (true)\n    {\n        // Print message to console\n        DEBUG_PRINT(\"Hello world!\\n\");\n        // Wait for 100 milliseconds (2 Hz loop)\n        vTaskDelay(pdMS_TO_TICKS(500));\n    }\n}\n</code></pre> <p>Definimos qual o programa que vamos compilar atrav\u00e9s do arquivo <code>Kbuild</code>:</p> Kbuild<pre><code>obj-y += src/examples/led_blink.o\n</code></pre> <p>Conforme formos desenvolvendo novos programas, n\u00e3o podemos esquecer de atualizar o arquivo <code>Kbuild</code> com o nome do programa que queremos compilar. </p> <p>Aten\u00e7\u00e3o</p> <p>Note que a extens\u00e3o do arquivo aqui \u00e9 <code>.o</code> e n\u00e3o <code>.c</code>. O importante \u00e9 o nome do programa estar igual.</p>"},{"location":"first_steps/firmware/#configurando","title":"Configurando","text":"<p>Vamos agora ajustar as configura\u00e7\u00f5es do firmware, como canal de r\u00e1dio e plataforma de hardware, para preparar o ambiente de compila\u00e7\u00e3o.</p>"},{"location":"first_steps/firmware/#radio","title":"Radio","text":"<ol> <li> <p>Abra o arquivo <code>radio.config</code></p> </li> <li> <p>Altere o canal do r\u00e1dio conforme a numera\u00e7\u00e3o do seu Crazyflie.  radio.config<pre><code>RADIO_CHANNEL=1\n</code></pre></p> </li> </ol>"},{"location":"first_steps/firmware/#submodulo","title":"Subm\u00f3dulo","text":"<ol> <li> <p>Navegue at\u00e9 a p\u00e1gina <code>crazyflie-firmware</code> &gt; <code>src</code> &gt; <code>modules</code> &gt; <code>src</code> e abra o arquivo <code>stabilizer.c</code>.</p> </li> <li> <p>Comente as linhas 223-226, 326 e 356, conforme abaixo<sup>2</sup>: stabilizer.c<pre><code>static void setMotorRatios(const motors_thrust_pwm_t* motorPwm)\n{\n  // motorsSetRatio(MOTOR_M1, motorPwm-&gt;motors.m1);\n  // motorsSetRatio(MOTOR_M2, motorPwm-&gt;motors.m2);\n  // motorsSetRatio(MOTOR_M3, motorPwm-&gt;motors.m3);\n  // motorsSetRatio(MOTOR_M4, motorPwm-&gt;motors.m4);\n}\n</code></pre> stabilizer.c<pre><code>      //stateEstimator(&amp;state, stabilizerStep);\n</code></pre> stabilizer.c<pre><code>      } else {\n        // motorsStop();\n      }\n</code></pre></p> </li> </ol>"},{"location":"first_steps/firmware/#plataforma","title":"Plataforma","text":"<ol> <li>Configure o firmware para a plataforma do Crazyflie 2.1 Brushless rodando o seguinte c\u00f3digo no terminal: <pre><code>make cf21bl_defconfig\n</code></pre></li> </ol>"},{"location":"first_steps/firmware/#compilando","title":"Compilando","text":"<p>Agora vamos compilar o firmware e grav\u00e1-lo no drone para que ele possa rodar o seu c\u00f3digo. Essa etapa \u00e9 bem simples e dever\u00e1 ser repetida toda vez que quisermos enviar um novo programa ao Crazyflie.</p>"},{"location":"first_steps/firmware/#build","title":"Build","text":"<ol> <li>Compile o firmware: <pre><code>make\n</code></pre></li> </ol>"},{"location":"first_steps/firmware/#flash","title":"Flash","text":"<ol> <li> <p>Programe o firmware no Crazyflie: <pre><code>make cload\n</code></pre></p> <p>Aten\u00e7\u00e3o</p> <ul> <li>O Crazyflie 2.1 Brushless precisa estar ligado</li> <li>O Crazyradio PA precisa estar conectado na porta USB</li> </ul> </li> </ol>"},{"location":"first_steps/firmware/#testando","title":"Testando","text":"<p>Por fim, vamos aprender a usar o Crazyflie Client para conectar ao drone e garantir que tudo est\u00e1 funcionando como esperado.</p> <ol> <li>Abra o Crazyflie Client <pre><code>cfclient\n</code></pre></li> <li> <p>Clique no bot\u00e3o <code>Scan</code> e selecione o Crazyflie correspondente</p> </li> <li> <p>Clique no bot\u00e3o <code>Connect</code></p> </li> <li> <p>Verifique se o quadricoptero est\u00e1 respondendo (tens\u00e3o da bateria, estado dos sensores, etc.)</p> </li> <li> <p>Clique em <code>View</code> &gt; <code>Toolboxes</code> &gt; <code>Console</code></p> </li> <li> <p>Verifique se aparecem as mensagens do seu c\u00f3digo (\"Hello world!\")</p> </li> </ol> <p>Caso n\u00e3o apare\u00e7a, muito provavelmente \u00e9 por que voc\u00ea est\u00e1 rodando o programa <code>led_blink.c</code> e n\u00e3o <code>hello_world.c</code>. Modifique seu arquivo <code>Kbuild</code> para o programa correto e, em seguida, compile e envie o programa para o quadricoptero.</p> <ol> <li> <p>Subm\u00f3dulos do Git s\u00e3o como \"reposit\u00f3rios dentro de reposit\u00f3rios\". Esse comando garante que voc\u00ea tenha o c\u00f3digo do firmware oficial (<code>crazyflie-firmware</code>) que est\u00e1 referenciado como subm\u00f3dulo.\u00a0\u21a9</p> </li> <li> <p>Fazemos isso para contornar o algoritmo propriet\u00e1rio do controlador do Crazyflie (ele vai continuar rodando em segundo plano, mas vamos ignorar seus comandos para podermos usar os nossos).\u00a0\u21a9</p> </li> </ol>"},{"location":"first_steps/installation_chatgpt/","title":"\ud83d\udee0\ufe0f Installation Guide","text":"<p>This guide contains step-by-step instructions for setting up your development environment. Follow each section in order to ensure a proper setup.</p>"},{"location":"first_steps/installation_chatgpt/#prerequisites","title":"\u26a1 Prerequisites","text":"<p>Before starting, make sure you have:</p> <ul> <li>Windows 10 version 2004 or higher (Build 19041+)</li> <li>At least 4GB of RAM</li> <li>Administrator access to your computer</li> <li>Internet connection</li> </ul>"},{"location":"first_steps/installation_chatgpt/#1-arm-toolchain","title":"\ud83d\udce6 1. ARM Toolchain","text":"<p>The ARM Toolchain is required to compile the code that will run on the drone.</p>"},{"location":"first_steps/installation_chatgpt/#a-windows-installation","title":"a) Windows Installation","text":"<ol> <li>Enable WSL (Windows Subsystem for Linux)</li> <li> <p>Open PowerShell as administrator:</p> <ol> <li>Press <code>Win + X</code></li> <li>Select \"Windows PowerShell (Admin)\"</li> <li>Click \"Yes\" in the confirmation window</li> </ol> </li> <li> <p>Run the command:    <pre><code>wsl --install\n</code></pre></p> <p>\u26a0\ufe0f Note: This command may take a few minutes. Please wait for completion.</p> </li> <li> <p>Set up Ubuntu on WSL</p> </li> <li>After installation, restart your computer</li> <li> <p>Open Ubuntu:    <pre><code>wsl\n</code></pre></p> <p>\ud83d\udcdd On first run, you'll need to create a username and password for Ubuntu</p> </li> <li> <p>Install the Tools</p> </li> <li> <p>Update package list:    <pre><code>sudo apt update\n</code></pre></p> </li> <li> <p>Install Make:    <pre><code>sudo apt install make \n</code></pre></p> </li> <li> <p>Install ARM Toolchain:    <pre><code>sudo apt install gcc-arm-none-eabi\n</code></pre></p> </li> </ol>"},{"location":"first_steps/installation_chatgpt/#b-verification","title":"b) Verification","text":"<p>To confirm everything was installed correctly:</p> <ol> <li> <p>Verify Make <pre><code>make --version\n</code></pre></p> <p>\u2705 Should show Make version (e.g., GNU Make 4.3)</p> </li> <li> <p>Verify ARM Toolchain <pre><code>arm-none-eabi-gcc --version\n</code></pre></p> <p>\u2705 Should show GCC version (e.g., arm-none-eabi-gcc 10.3.1)</p> </li> </ol>"},{"location":"first_steps/installation_chatgpt/#2-python","title":"\ud83d\udc0d 2. Python","text":"<p>Python is the main language we'll use to program the drone.</p>"},{"location":"first_steps/installation_chatgpt/#a-installation","title":"a) Installation","text":"<ol> <li>Download Python</li> <li>Go to Python's official website</li> <li> <p>Download the Windows installer (64-bit)</p> </li> <li> <p>Run the installer</p> </li> <li>\u26a0\ufe0f IMPORTANT: Check the box <code>[\u2713] Add python.exe to PATH</code></li> <li>Click \"Install Now\"</li> </ol>"},{"location":"first_steps/installation_chatgpt/#b-verification_1","title":"b) Verification","text":"<p>Run these commands in PowerShell to confirm installation:</p> <pre><code>python --version  # Should show Python 3.11.9\npip --version     # Should show pip version\n</code></pre>"},{"location":"first_steps/installation_chatgpt/#3-crazyflie-client","title":"\ud83d\udd79\ufe0f 3. Crazyflie Client","text":"<p>The Crazyflie Client is the interface we'll use to control the drone.</p>"},{"location":"first_steps/installation_chatgpt/#a-installation_1","title":"a) Installation","text":"<ol> <li>Install the client via pip <pre><code>pip install cfclient\n</code></pre></li> </ol>"},{"location":"first_steps/installation_chatgpt/#b-verification_2","title":"b) Verification","text":"<ol> <li>Launch the client <pre><code>cfclient\n</code></pre> <p>\u2705 Should open the Crazyflie graphical interface</p> </li> </ol>"},{"location":"first_steps/installation_chatgpt/#common-issues","title":"\u2753 Common Issues","text":""},{"location":"first_steps/installation_chatgpt/#wsl-wont-install","title":"WSL won't install","text":"<ul> <li>Check if virtualization is enabled in BIOS</li> <li>Make sure Windows is up to date</li> <li>Run <code>sfc /scannow</code> in PowerShell as administrator</li> </ul>"},{"location":"first_steps/installation_chatgpt/#python-not-recognized","title":"Python not recognized","text":"<ul> <li>Restart PowerShell/computer after installation</li> <li>Verify you checked \"Add to PATH\" during installation</li> <li>Add to PATH manually if needed</li> </ul>"},{"location":"first_steps/installation_chatgpt/#crazyflie-client-wont-open","title":"Crazyflie Client won't open","text":"<ul> <li>Check if all dependencies are installed</li> <li>Try reinstalling with: <code>pip install --upgrade cfclient</code></li> </ul>"},{"location":"first_steps/installation_chatgpt/#need-help","title":"\ud83d\udcde Need Help?","text":"<p>If you encounter any issues during installation: 1. Check the Common Issues section above 2. Consult the official documentation 3. Contact your instructor </p>"},{"location":"first_steps/installations/","title":"Instala\u00e7\u00f5es","text":"<p>Esta sec\u00e7\u00e3o cont\u00e9m as instru\u00e7\u00f5es para instalar todas as ferramentas e depend\u00eancias necess\u00e1rias para o seu ambiente de desenvolvimento. </p> <p>Siga cada passo conforme seu sistema operacional com aten\u00e7\u00e3o, para garantir uma configura\u00e7\u00e3o correta.</p>"},{"location":"first_steps/installations/#git","title":"Git","text":"WindowsMac <ol> <li> <p>Baixe o Git em seu site oficial e instale-o.</p> </li> <li> <p>Verifique a instala\u00e7\u00e3o do Git pelo PowerShell: <pre><code>git --version\n</code></pre></p> </li> </ol> <p>O Mac j\u00e1 vem de f\u00e1brica com o Git instalado.</p>"},{"location":"first_steps/installations/#python","title":"Python","text":"WindowsMac <p>Aten\u00e7\u00e3o</p> <p>N\u00e3o pule essa etapa mesmo que voc\u00ea j\u00e1 tenha uma distribui\u00e7\u00e3o do Python instalada em seu computador, pois precisar\u00e1 instalar uma distribui\u00e7\u00e3o espec\u00edfica (3.11.9) para tudo funcionar. Mas fique tranquilo, qualquer distribui\u00e7\u00e3o j\u00e1 instalada continuar\u00e1 funcionando normalmente.</p> <ol> <li> <p>Baixe o Python 3.11.9 em seu site oficial e instale-o.</p> </li> <li> <p>Certifique-se de marcar a caixa <code>[\u2713] Add python.exe to PATH</code> durante a instala\u00e7\u00e3o.</p> </li> <li> <p>Verifique a instala\u00e7\u00e3o do Python e do PIP (Gerenciador de Pacotes Python) pelo PowerShell: <pre><code>python --version\npip --version\n</code></pre></p> </li> </ol> <p>O Mac j\u00e1 vem de f\u00e1brica com o Python instalado.</p>"},{"location":"first_steps/installations/#crazyflie-client","title":"Crazyflie Client","text":"WindowsMac <ol> <li> <p>Instale o Crazyflie Client usando o PIP pelo PowerShell: <pre><code>pip install cfclient\n</code></pre></p> </li> <li> <p>Verifique a instala\u00e7\u00e3o do Crazyflie Client abrindo ele pelo PowerShell: <pre><code>cfclient\n</code></pre></p> </li> </ol> <p>Dica</p> <p>Caso prefira criar um \u00edcone na \u00e1rea de trabalho para o Crazyflie Client, siga o passo a passo abaixo:</p> <ol> <li> <p>Clique com o bot\u00e3o direito na \u00e1rea de trabalho e depois em <code>Novo</code> &gt; <code>Atalho</code></p> </li> <li> <p>No campo de destino, coloque \"cfclient\" e clique em <code>Avan\u00e7ar</code></p> </li> <li> <p>No campo de nome, coloque \"Crazyflie Client\" e clique em <code>Concluir</code></p> </li> </ol> <ol> <li> <p>Instale o Crazyflie Client pelo Terminal: <pre><code>python3 -m pip install cfclient\n</code></pre></p> </li> <li> <p>Verifique a instala\u00e7\u00e3o do Crazyflie Client abrindo ele pelo Terminal: <pre><code>cfclient\n</code></pre></p> </li> </ol> <p>Aten\u00e7\u00e3o</p> <p>Caso o comando acima n\u00e3o abra o Crazyflie Client, pode ser que seu endere\u00e7o n\u00e3o esteja no PATH. Para verificar onde ele foi instalado e colocar ele no PATH, basta rodar o comando abaixo no Terminal<sup>1</sup>: <pre><code>cfclient_path=$(dirname $(which cfclient)) &amp;&amp; echo \"export PATH=\\\"$cfclient_path:\\$PATH\\\"\" &gt;&gt; ~/.zshrc\n</code></pre></p> <p>Dica</p> <p>Caso prefira criar um \u00edcone na mesa para o Crazyflie Client, siga o passo a passo abaixo:</p> <ol> <li> <p>Abra o Automator</p> </li> <li> <p>Clique em <code>Novo Documento</code> &gt; <code>Aplicativo</code></p> </li> <li> <p>Na biblioteca de a\u00e7\u00f5es, d\u00ea duplo clique em <code>Executar Script de Shell</code></p> </li> <li> <p>No campo de script, cole: <pre><code>python3 -m cfclient.gui\n</code></pre></p> </li> <li> <p>Clique em <code>Arquivo</code> &gt; <code>Salvar</code></p> </li> <li> <p>No campo de nome, coloque \"Crazyflie Client\" e clique em <code>Concluir</code></p> </li> </ol>"},{"location":"first_steps/installations/#arm-toolchain","title":"ARM Toolchain","text":"WindowsMac <ol> <li> <p>Instale o WSL (Subsistema do Windows para Linux) pelo PowerShell executando ele como administrador: <pre><code>wsl --install\n</code></pre></p> </li> <li> <p>Ap\u00f3s a instala\u00e7\u00e3o, reinicie o computador.</p> </li> <li> <p>Depois que o computador tiver reiniciado, ele abrir\u00e1 automaticamente o terminal WSL (Ubuntu). Caso ele n\u00e3o abra, voc\u00ea pode abri-lo pelo PowerShell: <pre><code>wsl\n</code></pre></p> </li> <li> <p>Na primeira vez, ser\u00e1 solicitado que voc\u00ea crie um nome de usu\u00e1rio para o Linux e defina uma senha (n\u00e3o necessariamente a mesma do Windows). </p> <p>Aten\u00e7\u00e3o</p> <p>Os comandos a seguir devem ser executados no terminal WSL (Ubuntu) e n\u00e3o no PowerShell</p> </li> <li> <p>Atualize a lista de pacotes: <pre><code>sudo apt update\n</code></pre></p> </li> <li> <p>Instale o Make: <pre><code>sudo apt install make \n</code></pre></p> </li> <li> <p>Verifique a instala\u00e7\u00e3o do Make: <pre><code>make --version\n</code></pre></p> </li> <li> <p>Instale o toolchain ARM embarcado: <pre><code>sudo apt install gcc-arm-none-eabi\n</code></pre></p> </li> <li> <p>Verifique a instala\u00e7\u00e3o do toolchain ARM embarcado: <pre><code>arm-none-eabi-gcc --version\n</code></pre></p> </li> <li> <p>Instale o toolchain GCC: <pre><code>sudo apt install gcc\n</code></pre></p> </li> <li> <p>Verifique a instala\u00e7\u00e3o do toolchain GCC: <pre><code>gcc --version\n</code></pre></p> </li> </ol> <ol> <li> <p>Instale o Homebrew: <pre><code>/bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\"\n</code></pre></p> </li> <li> <p>Verifique a instala\u00e7\u00e3o do Homebrew: <pre><code>brew --version\n</code></pre></p> </li> <li> <p>Instale o toolchain ARM embarcado: <pre><code>brew install gcc-arm-embedded\n</code></pre></p> </li> <li> <p>Adicione-o ao PATH<sup>1</sup>: <pre><code>echo 'export PATH=\"/opt/homebrew/bin:$PATH\"' &gt;&gt; ~/.zshrc\n</code></pre></p> </li> <li> <p>Verifique a instala\u00e7\u00e3o do toolchain ARM embarcado: <pre><code>arm-none-eabi-gcc --version\n</code></pre></p> </li> <li> <p>Instale os utilit\u00e1rios do GNU Core: <pre><code>brew install coreutils\n</code></pre></p> </li> <li> <p>Adicione-o ao PATH<sup>1</sup>: <pre><code>echo 'export PATH=\"/opt/homebrew/opt/coreutils/libexec/gnubin:$PATH\"' &gt;&gt; ~/.zshrc\n</code></pre></p> </li> <li> <p>Verifique a instala\u00e7\u00e3o do GNU Core: <pre><code>gdate --version\n</code></pre></p> </li> </ol> <ol> <li> <p>Reinicie o Terminal depois para a altera\u00e7\u00e3o fazer efeito.\u00a0\u21a9\u21a9\u21a9</p> </li> </ol>"},{"location":"first_steps/installations_old/","title":"Instala\u00e7\u00f5es","text":"<p>Esta sec\u00e7\u00e3o cont\u00e9m as instru\u00e7\u00f5es para instalar todas as ferramentas e depend\u00eancias necess\u00e1rias para o seu ambiente de desenvolvimento. </p> <p>Siga cada passo conforme seu sistema operacional com aten\u00e7\u00e3o, para garantir uma configura\u00e7\u00e3o correta.</p>"},{"location":"first_steps/installations_old/#windows","title":"Windows","text":"<p>Caso seu sistema operacional seja Windows, siga o passo a passo abaixo:</p>"},{"location":"first_steps/installations_old/#git","title":"Git","text":"<ol> <li> <p>Baixe o Git em seu site oficial e instale-o.</p> </li> <li> <p>Verifique a instala\u00e7\u00e3o do Git pelo PowerShell: <pre><code>git --version\n</code></pre></p> </li> </ol>"},{"location":"first_steps/installations_old/#python","title":"Python","text":"<p>Aten\u00e7\u00e3o</p> <p>N\u00e3o pule essa etapa mesmo que voc\u00ea j\u00e1 tenha uma distribui\u00e7\u00e3o do Python instalado em seu computador, pois precisar\u00e1 instalar uma distribui\u00e7\u00e3o espec\u00edfica (3.11.9) para tudo funcionar. Mas fique tranquilo, qualquer distribui\u00e7\u00e3o j\u00e1 instalada continuar\u00e1 funcionando normalmente.</p> <ol> <li> <p>Baixe o Python 3.11.9 em seu site oficial e instale-o.</p> </li> <li> <p>Certifique-se de marcar a caixa <code>[\u2713] Add python.exe to PATH</code> durante a instala\u00e7\u00e3o.</p> </li> <li> <p>Verifique a instala\u00e7\u00e3o do Python e do PIP (Gerenciador de Pacotes Python) pelo PowerShell: <pre><code>python --version\npip --version\n</code></pre></p> </li> </ol>"},{"location":"first_steps/installations_old/#crazyflie-client","title":"Crazyflie Client","text":"<ol> <li> <p>Instale o Crazyflie Client usando o PIP pelo PowerShell: <pre><code>pip install cfclient\n</code></pre></p> </li> <li> <p>Verifique a instala\u00e7\u00e3o do Crazyflie Client abrindo ele pelo PowerShell: <pre><code>cfclient\n</code></pre></p> </li> </ol> <p>Dica</p> <p>Caso prefira criar um \u00edcone na \u00e1rea de trabalho para o Crazyflie Client, siga o passo a passo abaixo:</p> <ol> <li> <p>Clique com o bot\u00e3o direito na \u00e1rea de trabalho e depois em <code>Novo</code> &gt; <code>Atalho</code></p> </li> <li> <p>No campo de destino, coloque \"cfclient\" e clique em <code>Avan\u00e7ar</code></p> </li> <li> <p>No campo de nome, coloque \"Crazyflie Client\" e clique em <code>Concluir</code></p> </li> </ol>"},{"location":"first_steps/installations_old/#arm-toolchain","title":"ARM Toolchain","text":"<ol> <li> <p>Instale o WSL (Subsistema do Windows para Linux) pelo PowerShell executando ele como administrador: <pre><code>wsl --install\n</code></pre></p> </li> <li> <p>Ap\u00f3s a instala\u00e7\u00e3o, reinicie o computador.</p> </li> <li> <p>Depois que o computador tiver reiniciado, ele abrir\u00e1 automaticamente o terminal WSL (Ubuntu). Caso ele n\u00e3o abra, voc\u00ea pode abri-lo pelo PowerShell: <pre><code>wsl\n</code></pre></p> </li> <li> <p>Na primeira vez, ser\u00e1 solicitado que voc\u00ea crie um nome de usu\u00e1rio para o Linux e defina uma senha (n\u00e3o necessariamente a mesma do Windows). </p> <p>Aten\u00e7\u00e3o</p> <p>Os comandos a seguir devem ser executados no terminal WSL (Ubuntu) e n\u00e3o no PowerShell</p> </li> <li> <p>Atualize a lista de pacotes: <pre><code>sudo apt update\n</code></pre></p> </li> <li> <p>Instale o Make: <pre><code>sudo apt install make \n</code></pre></p> </li> <li> <p>Verifique a instala\u00e7\u00e3o do Make: <pre><code>make --version\n</code></pre></p> </li> <li> <p>Instale o toolchain ARM embarcado: <pre><code>sudo apt install gcc-arm-none-eabi\n</code></pre></p> </li> <li> <p>Verifique a instala\u00e7\u00e3o do toolchain ARM embarcado: <pre><code>arm-none-eabi-gcc --version\n</code></pre></p> </li> <li> <p>Instale o toolchain GCC: <pre><code>sudo apt install gcc\n</code></pre></p> </li> <li> <p>Verifique a instala\u00e7\u00e3o do toolchain GCC: <pre><code>gcc --version\n</code></pre></p> </li> </ol>"},{"location":"first_steps/installations_old/#mac","title":"Mac","text":"<p>Caso seu sistema operacional seja Mac<sup>1</sup>, siga o passo a passo abaixo:</p>"},{"location":"first_steps/installations_old/#crazyflie-client_1","title":"Crazyflie Client","text":"<ol> <li> <p>Instale o Crazyflie Client pelo Terminal: <pre><code>python3 -m pip install cfclient\n</code></pre></p> </li> <li> <p>Verifique a instala\u00e7\u00e3o do Crazyflie Client abrindo ele pelo Terminal: <pre><code>cfclient\n</code></pre></p> </li> </ol> <p>Aten\u00e7\u00e3o</p> <p>Caso o comando acima n\u00e3o abra o Crazyflie Client, pode ser que seu endere\u00e7o n\u00e3o esteja no PATH. Para verificar onde ele foi instalado e colocar ele no PATH, basta rodar o comando abaixo no Terminal<sup>2</sup>: <pre><code>cfclient_path=$(dirname $(which cfclient)) &amp;&amp; echo \"export PATH=\\\"$cfclient_path:\\$PATH\\\"\" &gt;&gt; ~/.zshrc\n</code></pre></p> <p>Dica</p> <p>Caso prefira criar um \u00edcone na mesa para o Crazyflie Client, siga o passo a passo abaixo:</p> <ol> <li> <p>Abra o Automator</p> </li> <li> <p>Clique em <code>Novo Documento</code> &gt; <code>Aplicativo</code></p> </li> <li> <p>No biblioteca de a\u00e7\u00f5es, d\u00ea duplo clique em <code>Executar Script de Shell</code></p> </li> <li> <p>No campo de script, cole: <pre><code>python3 -m cfclient.gui\n</code></pre></p> </li> <li> <p>Clique em <code>Arquivo</code> &gt; <code>Salvar</code></p> </li> <li> <p>No campo de nome, coloque \"Crazyflie Client\" e clique em <code>Concluir</code></p> </li> </ol>"},{"location":"first_steps/installations_old/#arm-toolchain_1","title":"ARM Toolchain","text":"<ol> <li> <p>Instale o Homebrew: <pre><code>/bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\"\n</code></pre></p> </li> <li> <p>Verifique a instala\u00e7\u00e3o do Homebrew: <pre><code>brew --version\n</code></pre></p> </li> <li> <p>Instale o toolchain ARM embarcado: <pre><code>brew install gcc-arm-embedded\n</code></pre></p> </li> <li> <p>Adicione-o ao PATH<sup>2</sup>: <pre><code>echo 'export PATH=\"/opt/homebrew/bin:$PATH\"' &gt;&gt; ~/.zshrc\n</code></pre></p> </li> <li> <p>Verifique a instala\u00e7\u00e3o do toolchain ARM embarcado: <pre><code>arm-none-eabi-gcc --version\n</code></pre></p> </li> <li> <p>Instale os utilit\u00e1rios do GNU Core: <pre><code>brew install coreutils\n</code></pre></p> </li> <li> <p>Adicione-o ao PATH<sup>2</sup>: <pre><code>echo 'export PATH=\"/opt/homebrew/opt/coreutils/libexec/gnubin:$PATH\"' &gt;&gt; ~/.zshrc\n</code></pre></p> </li> <li> <p>Verifique a instala\u00e7\u00e3o do GNU Core: <pre><code>gdate --version\n</code></pre></p> </li> </ol> WindowsMac <p>Conte\u00fado para Windows...</p> <p>Conte\u00fado para Mac...</p> <ol> <li> <p>O Mac j\u00e1 vem de f\u00e1brica com o Git e o Python instalados, por isso que essas etapas foram omitidas aqui.\u00a0\u21a9</p> </li> <li> <p>Reinicie o Terminal depois para a altera\u00e7\u00e3o fazer efeito.\u00a0\u21a9\u21a9\u21a9</p> </li> </ol>"},{"location":"first_steps/motors/","title":"Motores","text":"<p>Nesta sec\u00e7\u00e3o, vamos fazer o drone girar um de seus motores pela primeira vez. Esse \u00e9 o seu primeiro contato com controle real de hardware, um passo fundamental rumo ao voo aut\u00f4nomo.</p> <p>Vamos criar um programa simples que liga o motor 1 com 10% de pot\u00eancia, sempre que o drone estiver armado (ou seja, autorizado a voar).</p>"},{"location":"first_steps/motors/#visao-geral","title":"Vis\u00e3o geral","text":"<p>Antes de come\u00e7ar, \u00e9 importante entender alguns conceitos:</p> <ul> <li>Armar o drone significa autorizar o funcionamento dos motores. Isso \u00e9 feito manualmente pelo operador atrav\u00e9s do Crazyflie Client e verificado no c\u00f3digo com a fun\u00e7\u00e3o <code>supervisorIsArmed()</code>.</li> <li>O controle dos motores \u00e9 feito atrav\u00e9s da fun\u00e7\u00e3o <code>motorsSetRatio(id, ratio)</code>, onde <code>id</code> corresponde ao motor que vai ser acionado e <code>ratio</code> \u00e0 sua pot\u00eancia.<ul> <li>O Crazyflie possui quatro motores, identificados como <code>MOTOR_M1</code>, <code>MOTOR_M2</code>, <code>MOTOR_M3</code> e <code>MOTOR_M4</code>.</li> <li>A pot\u00eancia vai de <code>0</code> (desligado) at\u00e9 <code>UINT16_MAX</code> (pot\u00eancia m\u00e1xima).</li> </ul> </li> <li>Em FreeRTOS, um delay \u00e9 realizado atrav\u00e9s da fun\u00e7\u00e3o <code>vTaskDelay(pdMS_TO_TICKS(xTimeInMs))</code>, que recebe um tempo em milissegundos e o converte para ticks do sistema.</li> </ul>"},{"location":"first_steps/motors/#codigo","title":"C\u00f3digo","text":"<p>Crie um arquivo chamado <code>motors.c</code> dentro da pasta <code>src/examples</code> com o seguinte conte\u00fado:</p> motors.c<pre><code>#include \"FreeRTOS.h\"      // FreeRTOS core definitions (needed for task handling and timing)\n#include \"task.h\"          // FreeRTOS task functions (e.g., vTaskDelay)\n#include \"supervisor.h\"    // Functions to check flight status (e.g., supervisorIsArmed)\n#include \"motors.h\"        // Low-level motor control interface (e.g., motorsSetRatio)\n#include \"debug.h\"         // Debug printing functions (e.g., DEBUG_PRINT)\n\n// Main application loop\nvoid appMain(void *param)\n{\n    // Infinite loop (runs continuously while the drone is powered on)\n    while (true)\n    {\n        // Check if the drone is armed (i.e., ready to receive motor commands)\n        if (supervisorIsArmed())\n        {\n            // If armed, turn on motor 1 with 10% power\n            motorsSetRatio(MOTOR_M1, 0.1f * UINT16_MAX);\n        }\n        else\n        {\n            // If not armed, stop motor 1\n            motorsSetRatio(MOTOR_M1, 0);\n        }\n        // Wait for 100 milliseconds before checking again (10 Hz loop)\n        vTaskDelay(pdMS_TO_TICKS(100));\n    }\n}\n</code></pre> <p>Voc\u00ea pode simplesmente copiar e colar o c\u00f3digo acima. Mas \u00e9 importante que voc\u00ea leia e entenda o que cada linha est\u00e1 fazendo (o c\u00f3digo est\u00e1 bem comentado).</p>"},{"location":"first_steps/motors/#compilando","title":"Compilando","text":"<p>Para que o firmware compile seu novo programa, modifique o arquivo <code>Kbuild</code>:</p> Kbuild<pre><code>obj-y += src/examples/motors.o\n</code></pre> <p>Em seguida, compile e programe o quadricoptero.</p>"},{"location":"first_steps/motors/#testando","title":"Testando","text":"<p>Para testar o funcionamento, siga as etapas abaixo:</p> <ol> <li>Abra o Crazyflie Client e conecte-se ao drone.</li> <li>Clique no bot\u00e3o <code>Arm</code>.</li> <li>O motor 1 deve come\u00e7ar a girar com 10% de pot\u00eancia.</li> <li>Ao clicar em <code>Disarm</code>, o motor deve parar imediatamente.</li> </ol> <p>Aten\u00e7\u00e3o</p> <p>O motor vai girar, mas o drone n\u00e3o vai levantar voo, pois estamos controlando apenas um motor isolado com baixa pot\u00eancia.</p> <p>Voc\u00ea acaba de escrever seu primeiro programa que interage com o hardware real do drone \u2014 controlando motores com seguran\u00e7a. Um passo simples, mas poderoso, no caminho do voo aut\u00f4nomo.</p>"},{"location":"first_steps/sensors/","title":"Sensores","text":"<p>Nesta sec\u00e7\u00e3o, vamos aprender como ler os dados dos sensores do drone em tempo real. Esses dados s\u00e3o fundamentais para tarefas como estabiliza\u00e7\u00e3o, controle, navega\u00e7\u00e3o e autonomia.</p> <p>Vamos criar um programa que l\u00ea e imprime no console os seguintes sensores:</p> <ul> <li>Aceler\u00f4metro (\\(a_x\\), \\(a_y\\) e \\(a_z\\))</li> <li>Girosc\u00f3pio (\\(g_x\\), \\(g_y\\) e \\(g_z\\))</li> <li>Lidar (\\(d\\))</li> <li>Fluxo \u00f3ptico (\\(p_x\\) e \\(p_y\\))</li> </ul>"},{"location":"first_steps/sensors/#visao-geral","title":"Vis\u00e3o geral","text":"<p>Antes de come\u00e7ar, \u00e9 importante entender alguns conceitos:</p> <ul> <li>Os sensores no Crazyflie s\u00e3o processados por um sistema de estima\u00e7\u00e3o que envia os dados via uma fila interna. Usamos a fun\u00e7\u00e3o <code>estimatorDequeue(&amp;m)</code>, para preencher a estrutura <code>measurement_t m</code>, que cont\u00e9m diferentes tipos de leitura, identificados por <code>m.type</code>.</li> <li>O sistema coleta dados continuamente em alta frequ\u00eancia, que v\u00eam da IMU (aceler\u00f4metro e girosc\u00f3pio), do lidar e da c\u00e2mera de fluxo \u00f3ptico.</li> <li>Usamos <code>DEBUG_PRINT()</code> para exibir os valores no console serial.</li> </ul>"},{"location":"first_steps/sensors/#codigo","title":"C\u00f3digo","text":"<p>Crie um arquivo chamado <code>sensors.c</code> dentro da pasta <code>src/examples</code> com o seguinte conte\u00fado:</p> sensors.c<pre><code>#include \"FreeRTOS.h\"   // FreeRTOS core definitions (needed for task handling and timing)\n#include \"task.h\"       // FreeRTOS task functions (e.g., vTaskDelay)\n#include \"supervisor.h\" // Functions to check flight status (e.g., supervisorIsArmed)\n#include \"debug.h\"      // Debug printing functions (e.g., DEBUG_PRINT)\n#include \"estimator.h\"  // Estimator functions (e.g., estimatorDequeue)\n\n// Sensors data\nfloat ax, ay, az; // Accelerometer [m/s^2]\nfloat gx, gy, gz; // Gyroscope [rad/s]\nfloat d;          // Range [m]\nfloat px, py;     // Optical flow [pixels]\n\n// Main application loop\nvoid appMain(void *param)\n{\n    // Infinite loop (runs continuously while the drone is powered on)\n    while (true)\n    {\n        // Get sensor data from queue\n        measurement_t m;\n        while (estimatorDequeue(&amp;m))\n        {\n            switch (m.type)\n            {\n            case MeasurementTypeGyroscope:\n                gx = m.data.gyroscope.gyro.x;\n                gy = m.data.gyroscope.gyro.y;\n                gz = m.data.gyroscope.gyro.z;\n                break;\n            case MeasurementTypeAcceleration:\n                ax = m.data.acceleration.acc.x;\n                ay = m.data.acceleration.acc.y;\n                az = m.data.acceleration.acc.z;\n                break;\n            case MeasurementTypeTOF:\n                d = m.data.tof.distance;\n            case MeasurementTypeFlow:\n                px = m.data.flow.dpixelx;\n                py = m.data.flow.dpixely;\n            default:\n                break;\n            }\n        }\n        // Print sensor data to console\n        DEBUG_PRINT(\"Acc: %4.2f %4.2f %4.2f | Gyr: %6.2f %6.2f %6.2f | Dis: %4.2f | Flow: %2.0f %2.0f %6.4f\\n\",(double)ax,(double)ay,(double)az,(double)gx,(double)gy,(double)gz,(double)d,(double)px,(double)py);\n        // Wait for 100 milliseconds before checking again (10 Hz loop)\n        vTaskDelay(pdMS_TO_TICKS(100));\n    }\n}\n</code></pre> <p>Voc\u00ea pode simplesmente copiar e colar o c\u00f3digo acima. Mas \u00e9 importante que voc\u00ea leia e entenda o que cada linha est\u00e1 fazendo (o c\u00f3digo est\u00e1 bem comentado).</p>"},{"location":"first_steps/sensors/#compilando","title":"Compilando","text":"<p>Para que o firmware compile seu novo programa, modifique o arquivo <code>Kbuild</code>:</p> Kbuild<pre><code>obj-y += src/examples/sensors.o\n</code></pre> <p>Em seguida, compile e programe o quadricoptero.</p>"},{"location":"first_steps/sensors/#testando","title":"Testando","text":"<p>Para testar o funcionamento, siga as etapas abaixo:</p> <ol> <li>Abra o Crazyflie Client e conecte-se ao drone.</li> <li>Clique em <code>View</code> &gt; <code>Toolboxes</code> &gt; <code>Console</code></li> <li>Verifique se os dados dos sensores est\u00e3o sendo impressos</li> </ol> <p>Aten\u00e7\u00e3o</p> <p>Movimente o drone com a m\u00e3o e observe a varia\u00e7\u00e3o dos sensores em tempo real.</p> <p>Agora voc\u00ea sabe como acessar dados brutos dos sensores do drone. Esses dados s\u00e3o a base para algoritmos de controle, filtros e navega\u00e7\u00e3o. A partir daqui, voc\u00ea ter\u00e1 todo o poder necess\u00e1rio para construir sistemas embarcados inteligentes \u2014 do jeito que quiser!</p>"},{"location":"identification/drag_constant/","title":"Identifica\u00e7\u00e3o da constante de arrasto","text":"<p>Nesta sec\u00e7\u00e3o, voc\u00ea ir\u00e1 determinar experimentalmente a constante de arrasto das h\u00e9lices \\(k_d\\).</p>"},{"location":"identification/drag_constant/#fundamentos-teoricos","title":"Fundamentos te\u00f3ricos","text":"<p>As h\u00e9lices de um quadricoptero atuam como superf\u00edcies aerodin\u00e2micas, acelerando o fluxo de ar atrav\u00e9s delas. Isso consome energia das baterias e produz for\u00e7as de sustenta\u00e7\u00e3o e torques de arrasto no quadricoptero. J\u00e1 deduzimos que o torque de arrasto de uma h\u00e9lice \\(\\tau\\) \u00e9 proporcional \u00e0 velocidade angular da h\u00e9lice \\(\\omega\\) ao quadrado.</p> <p></p> \\[     \\tau = k_d \\omega^2 \\] <p>Onde:</p> <ul> <li>\\(k_d\\) - Constante de arrasto (\\(N.m.s^2\\))   </li> </ul>"},{"location":"identification/drag_constant/#procedimento-experimental","title":"Procedimento experimental","text":"<p>As etapas para coletar os dados s\u00e3o as seguintes:</p> <ol> <li>Garanta que a bateria do drone est\u00e1 carregada </li> <li>Prenda o drone no dispositivo e posicione um cron\u00f4metro ao seu lado</li> <li>Arme o drone apertando o bot\u00e3o <code>Arm</code> no CFClient</li> <li>Comece a filmar com seu celular no modo c\u00e2mera lenta</li> <li>Ligue os motores com o Command Based Flight Control do CFClient</li> <li>Espere o drone dar duas voltas e pare de filmar</li> <li>Repita as etapas 3-6 tr\u00eas vezes</li> </ol> <p>Ap\u00f3s o experimento, voc\u00ea dever\u00e1 coletar dados para preencher a tabela abaixo.</p> \\(\\psi \\, (^{\\circ})\\) \\(t_1 \\, (s)\\) \\(t_2 \\, (s)\\) \\(t_3 \\, (s)\\) \\(0\\) \\(90\\) \\(180\\) \\(270\\) \\(360\\) \\(450\\) \\(540\\) \\(630\\) \\(720\\)"},{"location":"identification/drag_constant/#analise-de-dados","title":"An\u00e1lise de dados","text":""},{"location":"identification/lift_constant/","title":"Identifica\u00e7\u00e3o da constante de sustenta\u00e7\u00e3o","text":"<p>Nesta sec\u00e7\u00e3o, voc\u00ea ir\u00e1 determinar experimentalmente a constante de sustenta\u00e7\u00e3o das h\u00e9lices \\(k_l\\).</p>"},{"location":"identification/lift_constant/#fundamentos-teoricos","title":"Fundamentos te\u00f3ricos","text":"<p>As h\u00e9lices de um quadricoptero atuam como superf\u00edcies aerodin\u00e2micas, acelerando o fluxo de ar atrav\u00e9s delas. Isso consome energia das baterias e produz for\u00e7as de sustenta\u00e7\u00e3o e torques de arrasto no quadricoptero. J\u00e1 deduzimos que a for\u00e7a de sustenta\u00e7\u00e3o de uma h\u00e9lice \\(f\\) \u00e9 proporcional \u00e0 velocidade angular da h\u00e9lice \\(\\omega\\) ao quadrado.</p> <p></p> \\[     \\tau = k_l \\omega^2 \\] <p>Onde:</p> <ul> <li>\\(k_l\\) - Constante de sustenta\u00e7\u00e3o (\\(N.s^2\\))   </li> </ul>"},{"location":"identification/lift_constant/#procedimento-experimental","title":"Procedimento experimental","text":"<p>Para medir a for\u00e7a de de sustenta\u00e7\u00e3o \\(f\\) da h\u00e9lice, voc\u00ea pode utilizar um suporte e uma balan\u00e7a. Para prender o quadcoptero no suporte, voc\u00ea precisa encaix\u00e1-lo pela lateral e depois prender dois parafusos. </p> <p>O suporte possui um im\u00e3 em sua base que deixa ele bem firma na balan\u00e7a. Voc\u00ea pode zerar a balan\u00e7a com o quadcoptero apertando o bot\u00e3o <code>T</code>, assim, qualquer for\u00e7a de sustenta\u00e7\u00e3o que as h\u00e9lices produzirem vai gerar uma leitura negativa na balan\u00e7a.</p> <p>Voc\u00ea deve carregar no drone um programa que ligue os quatro motores com um determinado valor de velocidade angular \\(\\omega\\). Ser\u00e3o levantados dados de peso na balan\u00e7a para 10 valores distintos de \\(omega\\) (\\(200rad/s\\) at\u00e9 \\(2.000rad/s\\)), e, para cada valor de \\(\\omega\\), voc\u00ea dever\u00e1 realizar o experimento 3 vezes e tirar uma m\u00e9dia. Para facilitar o experimento, voc\u00ea pode controlar o valor de \\(\\omega\\) com os bot\u00f5es <code>Up</code> e <code>Down</code> do Command Based Flight Control atrav\u00e9s do CFClient.</p> <p></p> <p>O c\u00f3digo abaixo possui um exemplo de programa que faz exatamente isso.</p> lab3_experiment.c<pre><code>#include \"FreeRTOS.h\"      // FreeRTOS core definitions (needed for task handling and timing)\n#include \"task.h\"          // FreeRTOS task functions (e.g., vTaskDelay)\n#include \"supervisor.h\"    // Functions to check flight status (e.g., supervisorIsArmed)\n#include \"commander.h\"     // Access to commanded setpoints (e.g., commanderGetSetpoint)\n#include \"motors.h\"        // Low-level motor control interface (e.g., motorsSetRatio)\n#include \"debug.h\"         // Debug printing functions (e.g., DEBUG_PRINT)\n\n// Motor constants (derived in Lab 2)\n// These represent coefficients of the quadratic model: PWM = a_2 * omega^2 + a_1 * omega\nconst float a_2 = 6.18e-8;\nconst float a_1 = 2.34e-4;\n\n// Global variables to store the desired setpoint, the current state (not used here), \n// the computed PWM value, and the desired angular velocity (omega)\nsetpoint_t setpoint;\nstate_t state;\nfloat pwm;\nfloat omega;\n\n// Main application\nvoid appMain(void *param)\n{\n    // Infinite loop (runs forever)\n    while (true)\n    {\n        // Check if the drone is armed (i.e., ready to fly)\n        if (supervisorIsArmed())\n        {\n            // Fetch the latest setpoint from the commander and also fetch the current estimated state (not used here)\n            commanderGetSetpoint(&amp;setpoint, &amp;state);\n\n            // Compute an angular velocity value proportional to the commanded altitude (Z axis position)\n            // The altitude command increases in 0.5 m steps, and we want the angular velocity to increase \n            // by 200 rad/s for each step. Therefore, we multiply Z by 400.0 so that: 0.5 m \u2192 200 rad/s\n            omega = (setpoint.position.z) * 400.0f;\n\n            // Print the computed omega value to the debug console (rounded to nearest integer)\n            DEBUG_PRINT(\"Omega (rad/s): %.0f\\n\", (double)omega);\n\n            // Convert angular velocity to PWM using the motor model: PWM = a_2 * omega^2 + a_1 * omega\n            pwm = a_2 * omega * omega + a_1 * omega;\n        }\n        else\n        {\n            // If not armed, stop the motors (set PWM to zero)\n            pwm = 0.0f;\n        }\n\n        // Send the PWM signal to all four motors (M1\u2013M4), scaling it to match the expected range [0, UINT16_MAX]\n        motorsSetRatio(MOTOR_M1, pwm * UINT16_MAX);\n        motorsSetRatio(MOTOR_M2, pwm * UINT16_MAX);\n        motorsSetRatio(MOTOR_M3, pwm * UINT16_MAX);\n        motorsSetRatio(MOTOR_M4, pwm * UINT16_MAX);\n\n        // Wait for 100 milliseconds before running the next iteration (10 Hz control loop)\n        vTaskDelay(pdMS_TO_TICKS(100));\n    }\n}\n</code></pre> <p>As etapas para coletar os dados s\u00e3o as seguintes:</p> <ol> <li>Garanta que a bateria do drone est\u00e1 carregada </li> <li>Prenda o drone no dispositivo e zere a balan\u00e7a presionando o bot\u00e3o <code>T</code></li> <li>Arme o drone apertando o bot\u00e3o <code>Arm</code> no CFClient</li> <li>Ligue o motor com um valor espec\u00edfico de velocidade angular \\(\\omega\\) com o Command Based Flight Control do CFClient</li> <li>Anote o n\u00famero que aparece na tela</li> <li>Repita as etapas 4-5 para outros valores de sinal PWM</li> </ol> <p>Ap\u00f3s o experimento, voc\u00ea dever\u00e1 coletar dados para preencher a tabela abaixo.</p> \\(\\omega \\, (rad/s)\\) \\(W_1 \\, (g)\\) \\(W_2 \\, (g)\\) \\(W_3 \\, (g)\\) \\(600\\) \\(800\\) \\(1200\\) \\(1400\\) \\(1600\\) \\(1800\\) \\(2000\\) \\(2200\\) \\(2400\\)"},{"location":"identification/lift_constant/#analise-de-dados","title":"An\u00e1lise de Dados","text":"<p>Utilizando os dados coletados, voc\u00ea dever\u00e1 ajustar uma curva que correlacione a velocidade angular \\(\\omega\\) com a for\u00e7a de sustenta\u00e7\u00e3o \\(f\\) da h\u00e9lice (note que voc\u00ea precisa converter a a leitura da balan\u00e7a de \\(g\\) para \\(N\\) e dividir por 4, dado que estamos interessados na for\u00e7a de uma \u00fanica h\u00e9lice).</p> <p></p> <p>Voc\u00ea j\u00e1 sabe que o melhor ajuste para esta curva \u00e9 uma fun\u00e7\u00e3o polinomial de 2\u00ba grau cujos termos de ordem um e zero s\u00e3o nulos:</p> \\[     f = k_l \\omega^2 \\] <p>Determine o valor de \\(k_l\\) fazendo esse ajuste de curva (dica: utilize o Curve Fitting Toolbox do MATLAB). Anote o valor obtido em algum lugar pois ele ser\u00e1 utilizado em breve.</p>"},{"location":"identification/lift_constant/#validacao-dos-resultados","title":"Valida\u00e7\u00e3o dos resultados","text":"<p>Compare o resultado obtido com o estimado anteriormente. \u00c9 esperado que a constante de sustenta\u00e7\u00e3o \\(k_l\\) seja da ordem de grandeza de \\(10^{-8}N.s^2\\). </p>"},{"location":"identification/motor_coeficients/","title":"Identifica\u00e7\u00e3o dos coeficientes do motor","text":"<p>Nesta sec\u00e7\u00e3o, voc\u00ea ir\u00e1 determinar experimentalmente os coeficientes do motor el\u00e9trico.</p>"},{"location":"identification/motor_coeficients/#fundamentos-teoricos","title":"Fundamentos te\u00f3ricos","text":"<p>O PWM (\"pulse width modulation\") \u00e9 uma t\u00e9cnica para controlar a pot\u00eancia de um sinal utilizando uma comuta\u00e7\u00e3o digital. Ao mudar rapidamente o sinal entre o m\u00e1ximo e zero (\"on-off\"), e variando a fra\u00e7\u00e3o de tempo que o sinal est\u00e1 no m\u00e1ximo, pode-se controlar a pot\u00eancia transmitida (isto \u00e9, modulando a largura do pulso).</p> <p> </p> <p>Este \u00e9 o mecanismo utilizado pelo Crazyflie para acionar seus motores. J\u00e1 sabemos que no c\u00f3digo \u00e9 poss\u00edvel definir um valor real entre <code>0.0</code> e <code>1.0</code> que corresponde ao sinal PWM do motor. </p> <p>Voc\u00ea ir\u00e1 implementar uma fun\u00e7\u00e3o que, dada uma velocidade angular desejada \\(\\omega\\), determine o sinal PWM correspondente. </p>"},{"location":"identification/motor_coeficients/#procedimento-experimental","title":"Procedimento experimental","text":"<p>Para medir a velocidade angular \\(\\omega\\) da h\u00e9lice, voc\u00ea pode utilizar um instrumento de medi\u00e7\u00e3o do n\u00famero de rota\u00e7\u00f5es chamado tac\u00f4metro. Para utiliz\u00e1-lo, voc\u00ea deve fixar um pequeno peda\u00e7o de fita refletora em uma das h\u00e9lices. Certifique-se de usar apenas um pequeno peda\u00e7o de fita e aplicar suavemente na h\u00e9lice, caso contr\u00e1rio voc\u00ea interferir\u00e1 no fluxo de ar e obter\u00e1 dados ruins. </p> <p></p> <p>O tac\u00f4metro pode detectar quando a tira passa pelo seu feixe de luz, assim, a velocidade de rota\u00e7\u00e3o \u00e9 calculada contando quantas vezes a tira passa em um determinado per\u00edodo de tempo. O tac\u00f4metro DT-2234C+ registra a velocidade angular enquanto voc\u00ea pressiona o bot\u00e3o <code>TEST</code> e, uma vez que este bot\u00e3o \u00e9 liberado, ele armazena os valores m\u00ednimo, m\u00e1ximo e m\u00e9dio, que voc\u00ea pode conferir apertando o bot\u00e3o <code>MEM</code>.</p> <p></p> <p>Voc\u00ea deve carregar no drone um programa que ligue apenas o motor cuja h\u00e9lice est\u00e1 com o peda\u00e7o de fita refletora com um determinado valor de sinal PWM. Ser\u00e3o levantados dados de velocidade angular da h\u00e9lice para 10 valores distintos de sinal PWM (<code>0.1</code> at\u00e9 <code>1.0</code>), e, para cada valor de sinal PWM, voc\u00ea dever\u00e1 realizar o experimento 3 vezes e tirar uma m\u00e9dia. Para facilitar o experimento, voc\u00ea pode controlar o valor do PWM com os bot\u00f5es <code>Up</code> e <code>Down</code> do Command Based Flight Control atrav\u00e9s do CFClient.</p> <p></p> <p>O c\u00f3digo abaixo possui um exemplo de programa que faz exatamente isso.</p> lab2_experiment.c<pre><code>#include \"FreeRTOS.h\"      // FreeRTOS core definitions (needed for task handling and timing)\n#include \"task.h\"          // FreeRTOS task functions (e.g., vTaskDelay)\n#include \"supervisor.h\"    // Functions to check flight status (e.g., supervisorIsArmed)\n#include \"commander.h\"     // Access to commanded setpoints (e.g., commanderGetSetpoint)\n#include \"motors.h\"        // Low-level motor control interface (e.g., motorsSetRatio)\n\n// Global variables to store the desired setpoint, the current state (not used here) and the computed PWM value.\nsetpoint_t setpoint;\nstate_t state;\nfloat pwm;\n\n// Main application\nvoid appMain(void *param)\n{\n    // Infinite loop (runs forever)\n    while (true)\n    {\n        // Check if the drone is armed (i.e., ready to fly)\n        if (supervisorIsArmed())\n        {\n            // Fetch the latest setpoint from the commander and also fetch the current estimated state (not used here)\n            commanderGetSetpoint(&amp;setpoint, &amp;state);\n\n            // Compute a PWM value proportional to the commanded altitude (Z axis position)\n            // The altitude command increases in 0.5 m steps, and we want the PWM to increase by 0.1 for each step.\n            // Therefore, we divide Z by 5.0 so that: 0.5 m \u2192 0.1 PWM\n            pwm = (setpoint.position.z) / 5.0f;\n        }\n        else\n        {\n            // If not armed, stop the motor (set PWM to zero)\n            pwm = 0.0f;\n        }\n        // Send the PWM signal to motor M1, scaling it to match the expected range [0, UINT16_MAX]\n        motorsSetRatio(MOTOR_M1, pwm * UINT16_MAX);\n        // Wait for 100 milliseconds before running the next iteration (10 Hz control loop)\n        vTaskDelay(pdMS_TO_TICKS(100));\n    }\n}\n</code></pre> <p>As etapas para coletar um dado s\u00e3o as seguintes:</p> <ol> <li>Garanta que a bateria do drone est\u00e1 carregada </li> <li>Prenda o drone na mesa com uma fita crepe</li> <li>Arme o drone apertando o bot\u00e3o <code>Arm</code> no CFClient</li> <li>Ligue o motor com um valor espec\u00edfico de sinal PWM com o Command Based Flight Control do CFClient</li> <li>Aponte o tac\u00f4metro para a h\u00e9lice segurando a aproximadamente \\(30cm\\) de dist\u00e2ncia e, em seguida, pressione o bot\u00e3o <code>TEST</code> </li> <li>Mantenha o bot\u00e3o <code>TEST</code> pressionado o tempo todo, certificando-se de que o feixe aponta para onde a faixa refletora passa  </li> <li>Mantenha essa posi\u00e7\u00e3o por alguns segundos e solte o bot\u00e3o <code>TEST</code> </li> <li>Pressione o bot\u00e3o <code>MEM</code> uma vez e espere aparecer a segunda leitura, que corresponde \u00e0 velocidade m\u00e1xima (em \\(rpm\\)) observada durante o experimento  </li> <li>Anote o n\u00famero que aparece na tela</li> <li>Repita as etapas 4-9 para outros valores de sinal PWM</li> </ol> <p>Ap\u00f3s o experimento, voc\u00ea dever\u00e1 coletar dados para preencher a tabela abaixo.</p> PWM N1 (rpm) N2 (rpm) N3 (rpm) <code>0.1</code> <code>0.2</code> <code>0.3</code> <code>0.4</code> <code>0.5</code> <code>0.6</code> <code>0.7</code> <code>0.8</code> <code>0.9</code> <code>1.0</code>"},{"location":"identification/motor_coeficients/#analise-de-dados","title":"An\u00e1lise de Dados","text":"<p>Utilizando os dados coletados, voc\u00ea dever\u00e1 ajustar uma curva que correlacione a velocidade angular das h\u00e9lice \\(\\omega\\) com o sinal PWM correspondente do motor (note que voc\u00ea precisa converter a velocidade angular de \\(rpm\\) para \\(rad/s\\)).</p> <p></p> <p>H\u00e1 diversos tipos de fun\u00e7\u00f5es de ajuste para esta curva (linear, exponencial, polinomial, etc.):</p> \\[     \\text{PWM} = f(\\omega) \\] <p>Para definir qual \u00e9 melhor para este caso, \u00e9 necess\u00e1rio se aprofundar na din\u00e2mica do sistema. O esquema eletromec\u00e2nico de um motor el\u00e9trico com uma h\u00e9lice pode ser visto no diagrama abaixo<sup>1</sup>.</p> <p></p> <p>Onde:</p> <ul> <li>\\(e_a\\) - Tens\u00e3o de armadura (\\(V\\))</li> <li>\\(i_a\\) - Corrente de armadura (\\(A\\))</li> <li>\\(R_a\\) - Resist\u00eancia de armadura (\\(\\Omega\\))</li> <li>\\(L_a\\) - Indut\u00e2ncia de armadura (\\(H\\))</li> <li>\\(e_b\\) - Tens\u00e3o contra-eletromotriz (\\(V\\))</li> <li>\\(\\omega\\) - Velocidade angular do motor/h\u00e9lice (\\(rad/s\\))</li> <li>\\(\\tau_m\\) - Torque do motor (\\(N.m\\))</li> <li>\\(k_d\\) - Constante de arrasto da h\u00e9lice (\\(N.m.s^2/rad^2\\))</li> <li>\\(b\\) - Coeficiente de atrito viscoso do motor (\\(N.m.s/rad\\))</li> <li>\\(I\\) - Momento de in\u00e9rcia do motor/h\u00e9lice (\\(kg.m^2\\))</li> </ul> <p>Exerc\u00edcio 1</p> <p>Aplique a lei de Kirchoff das tens\u00f5es no circuito de armadura.</p> Resposta \\[ \\begin{align*}     \\sum_{i=1}^n e_i &amp;= 0 \\\\     e_a - R_a i_a - L_a \\frac{d}{dt} i_a - e_b &amp;= 0 \\end{align*} \\] <p>Exerc\u00edcio 2</p> <p>Aplique a 2\u00ba lei de Newton em torno do eixo do motor.</p> Resposta \\[ \\begin{align*}     \\sum_{i=1}^n \\tau_i &amp;= I \\frac{d}{dt} \\omega \\\\     \\tau_m - k_d \\omega^2 - b \\omega &amp;= I \\frac{d}{dt} \\omega \\end{align*} \\] <p>Em um motor de corrente cont\u00ednua, o torque do motor \\(\\tau_m\\) \u00e9 diretamente proporcional \u00e0 corrente de armadura \\(i_a\\), e a tens\u00e3o contra-eletromotriz \\(e_b\\) \u00e9 diretamente proporcional \u00e0 velocidade angular \\(\\omega\\):</p> \\[ \\tau_m = K_m i_a  \\qquad e_b = K_m \\omega    \\] <p>Onde:</p> <ul> <li>\\(K_m\\) - Constante de torque do motor (\\(N.m/A\\) ou \\(V.s/rad\\)).</li> </ul> <p>Exerc\u00edcio 3</p> <p>Substitua o torque do motor \\(\\tau_m\\) e a tens\u00e3o contra-eletromotriz \\(e_b\\) nas duas equa\u00e7\u00f5es diferenciais obtidas anteriormente.</p> Resposta \\[ \\left\\{     \\begin{array}{l}         L_a \\dfrac{d}{dt} i_a + R_a i_a + K_m \\omega = e_a \\\\ \\\\         I \\dfrac{d}{dt} \\omega + k_d \\omega^2 + b \\omega - K_m i_a = 0     \\end{array} \\right. \\] <p>Quando o motor entra em regime, a corrente de armadura \\(i_a\\) e a velocidade angular \\(\\omega\\) tornam-se constantes (essa \u00e9 a defini\u00e7\u00e3o de ``regime''):</p> \\[     \\dfrac{d}{dt} i_a = 0 \\qquad \\dfrac{d}{dt} \\omega = 0 \\] <p>Exerc\u00edcio 4</p> <p>Iguale as derivadas da corrente de armadura \\(i_a\\) e da velocidade angular \\(\\omega\\) a zero e isole a corrente de armadura \\(i_a\\) nas duas equa\u00e7\u00f5es.</p> Resposta \\[ \\begin{align*}         L_a \\cancelto{0}{\\dfrac{d}{dt} i_a} + R_a i_a + K_m \\omega &amp;= e_a \\\\         R_a i_a &amp;= e_a - K_m \\omega \\\\         i_a &amp;= \\dfrac{1}{R_a} e_a - \\dfrac{K_m}{R_a} \\omega \\end{align*} \\] \\[ \\begin{align*}     I \\cancelto{0}{\\dfrac{d}{dt} \\omega} + k_d \\omega^2 + b \\omega - K_m i_a &amp;= 0 \\\\     K_m i_a &amp;= k_d \\omega^2 + b \\omega \\\\     i_a &amp;= \\dfrac{k_d}{K_m} \\omega^2 + \\dfrac{b}{K_m} \\omega \\end{align*} \\] <p>Exerc\u00edcio 5</p> <p>Iguale a corrente de armadura \\(i_a\\) obtida em cada uma das equa\u00e7\u00f5es e isole a tens\u00e3o de armadura \\(e_a\\) na equa\u00e7\u00e3o.</p> Resposta \\[ \\begin{align*}     \\dfrac{1}{R_a} e_a - \\dfrac{K_m}{R_a} \\omega &amp;= \\dfrac{k_d}{K_m} \\omega^2 + \\dfrac{b}{K_m} \\omega\\\\     \\dfrac{1}{R_a} e_a &amp;= \\dfrac{k_d}{K_m} \\omega^2 + \\dfrac{b}{K_m} \\omega + \\dfrac{K_m}{R_a} \\omega \\\\     e_a &amp;= \\dfrac{R_a k_d}{K_m} \\omega^2 + \\dfrac{R_a b + K_m^2}{K_m} \\omega \\end{align*} \\] <p>O sinal PWM \u00e9 a raz\u00e3o entre a tens\u00e3o de armadura \\(e_a\\) e a tens\u00e3o da bateria \\(e_s\\):</p> \\[     \\text{PWM} = \\frac{e_a}{e_s} \\] <p>Exerc\u00edcio 6</p> <p>Substitua a tens\u00e3o de armadura \\(e_a\\) na equa\u00e7\u00e3o anterior e isole o sinal PWM na equa\u00e7\u00e3o.</p> Resposta \\[ \\begin{align*}     e_a &amp;= \\dfrac{R_a k_d}{K_m} \\omega^2 + \\dfrac{R_a b + K_m^2}{K_m} \\omega \\\\     e_s \\text{PWM} &amp;= \\dfrac{R_a k_d}{K_m} \\omega^2 + \\dfrac{R_a b + K_m^2}{K_m} \\omega \\\\     \\text{PWM} &amp;= \\dfrac{R_a k_d}{K_me_s} \\omega^2 + \\dfrac{R_a b + K_m^2}{K_me_s} \\omega \\end{align*} \\] <p>Voc\u00ea deve ter chegado a:</p> \\[     \\text{PWM} =\\dfrac{R_a k_d}{K_me_s} \\omega^2 + \\dfrac{R_a b + K_m^2}{K_me_s} \\omega \\] <p>Como \\(R_a\\), \\(k_d\\), \\(b\\), \\(K_m\\) e \\(e_s\\) s\u00e3o par\u00e2metros constantes, podemos agrup\u00e1-los em duas constantes:</p> \\[     \\text{PWM} = \\underbrace{\\dfrac{R_a k_d}{K_me_s}}_{a_2} \\omega^2 + \\underbrace{\\dfrac{R_a b + K_m^2}{K_me_s}}_{a_1} \\omega \\] <p>Ou seja, o tipo de fun\u00e7\u00e3o mais adequado para realizar esse ajuste de curva \u00e9 uma fun\u00e7\u00e3o polinomial de 2\u00ba grau cujo termo de ordem zero \u00e9 nulo:</p> \\[     \\text{PWM} = a_2 \\omega^2 + a_1 \\omega + \\cancelto{0}{a_0}   \\] <p>Dessa forma, ao inv\u00e9s de determinar os valores de cada par\u00e2metro (\\(R_a\\), \\(k_d\\), \\(b\\), \\(K_m\\) e \\(e_s\\)), voc\u00ea ir\u00e1 determinar experimentalmente apenas os valores das constantes \\(a_2\\) e \\(a_1\\) (dica: utilize o Curve Fitting Toolbox do MATLAB).</p>"},{"location":"identification/motor_coeficients/#validacao-dos-resultados","title":"Valida\u00e7\u00e3o dos resultados","text":"<p>Uma vez determinadas as constantes \\(a_2\\) e \\(a_1\\), declare os seus valores no c\u00f3digo (linhas 10 e 11) e modifique seu programa para que, dada uma velocidade angular \\(\\omega\\) comandada (linhas 30 e 35), ele determine o sinal PWM correspondente (linha 41) e envie isso ao motor M1 (linha 50).</p> lab2_validation.c<pre><code>#include \"FreeRTOS.h\"      // FreeRTOS core definitions (needed for task handling and timing)\n#include \"task.h\"          // FreeRTOS task functions (e.g., vTaskDelay)\n#include \"supervisor.h\"    // Functions to check flight status (e.g., supervisorIsArmed)\n#include \"commander.h\"     // Access to commanded setpoints (e.g., commanderGetSetpoint)\n#include \"motors.h\"        // Low-level motor control interface (e.g., motorsSetRatio)\n#include \"debug.h\"         // Debug printing functions (e.g., DEBUG_PRINT)\n\n// Motor constants (derived in Lab 2)\n// These represent coefficients of the quadratic model: PWM = a_2 * omega^2 + a_1 * omega\nconst float a_2 = 0.0f;\nconst float a_1 = 0.0f;\n\n// Global variables to store the desired setpoint, the current state (not used here), \n// the computed PWM value, and the desired angular velocity (omega)\nsetpoint_t setpoint;\nstate_t state;\nfloat pwm;\nfloat omega;\n\n// Main application\nvoid appMain(void *param)\n{\n    // Infinite loop (runs forever)\n    while (true)\n    {\n        // Check if the drone is armed (i.e., ready to fly)\n        if (supervisorIsArmed())\n        {\n            // Fetch the latest setpoint from the commander and also fetch the current estimated state (not used here)\n            commanderGetSetpoint(&amp;setpoint, &amp;state);\n\n            // Compute an angular velocity value proportional to the commanded altitude (Z axis position)\n            // The altitude command increases in 0.5 m steps, and we want the angular velocity to increase \n            // by 200 rad/s for each step. Therefore, we multiply Z by 400.0 so that: 0.5 m \u2192 200 rad/s\n            omega = (setpoint.position.z) * 400.0f;\n\n            // Print the computed omega value to the debug console (rounded to nearest integer)\n            DEBUG_PRINT(\"Omega (rad/s): %.0f\\n\", (double)omega);\n\n            // Convert angular velocity to PWM using the motor model: PWM = a_2 * omega^2 + a_1 * omega\n            pwm = a_2 * omega * omega + a_1 * omega;\n        }\n        else\n        {\n            // If not armed, stop the motors (set PWM to zero)\n            pwm = 0.0f;\n        }\n\n        // Send the PWM signal to motors M1, scaling it to match the expected range [0, UINT16_MAX]\n        motorsSetRatio(MOTOR_M1, pwm * UINT16_MAX);\n\n        // Wait for 100 milliseconds before running the next iteration (10 Hz control loop)\n        vTaskDelay(pdMS_TO_TICKS(100));\n    }\n}\n</code></pre> <p>O c\u00f3digo acima faz uso do Command Based Flight Control para comandar a velocidade angular \\(\\omega\\) em incrementos de \\(200rad/s\\). Voc\u00ea deve test\u00e1-lo verificando se a velocidade angular comandada est\u00e1 pr\u00f3xima<sup>2</sup> da leitura do tac\u00f4metro.</p> <ol> <li> <p>Embora o Crazyflie utilize um motor el\u00e9trico de corrente cont\u00ednua sem escovas e n\u00e3o com escovas, a equa\u00e7\u00e3o matem\u00e1tica de ambos \u00e9 equivalente.\u00a0\u21a9</p> </li> <li> <p>Ela n\u00e3o vai bater na v\u00edrgula, pois fizemos um ajuste de curva. No entanto, essa diverg\u00eancia n\u00e3o ser\u00e1 um problema pois ainda vamos fechar a malha de controle em um n\u00edvel superior.\u00a0\u21a9</p> </li> </ol>"}]}