{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"home/","title":"N\u00edvel 1","text":"<p>Texto</p>"},{"location":"home/#nivel-2","title":"N\u00edvel 2","text":"lab10.c<pre><code>#include \"math.h\"       // Math functions (e.g., sqrtf, roundf, powf)\n#include \"FreeRTOS.h\"   // FreeRTOS core definitions (needed for task handling and timing)\n#include \"task.h\"       // FreeRTOS task functions (e.g., vTaskDelay)\n#include \"supervisor.h\" // Functions to check flight status (e.g., supervisorIsArmed)\n#include \"commander.h\"  // Access to commanded setpoints (e.g., commanderGetSetpoint)\n#include \"estimator.h\"  // Estimation framework for sensor fusion\n#include \"motors.h\"     // Low-level motor control interface (e.g., motorsSetRatio)\n#include \"debug.h\"      // Debug printing functions (e.g., DEBUG_PRINT)\n#include \"log.h\"        // Logging utilities to send data to the CFClient\n\n// Global parameters\nstatic const float pi = 3.1416f; // Mathematical constant\nstatic const float g = 9.81f;    // Gravitational acceleration [m/s^2]\nstatic const float dt = 0.005f;  // Loop time step [s] (5 ms -&gt; 200 Hz)\n\n// Sensors\nfloat ax, ay, az; // Accelerometer [m/s^2]\nfloat gx, gy, gz; // Gyroscope [rad/s]\nfloat d;          // Range [m]\nfloat px, py;     // Optical flow [pixels]\n\n// Motors\nfloat pwm1, pwm2, pwm3, pwm4; // PWM values [0.0-1.0]\n\n// System inputs\nfloat ft;         // Total thrust [N]\nfloat tx, ty, tz; // Torques [N.m]\n\n// System states\nfloat phi, theta, psi; // Euler angles [rad]\nfloat wx, wy, wz;      // Angular velocity [rad/s]\nfloat x, y, z;         // Position [m]\nfloat vx, vy, vz;      // Velocity [m/s]\n\n// System references\nfloat phi_r, theta_r, psi_r; // Euler angles [rad]\nfloat wx_r, wy_r, wz_r;      // Angular velocity [rad/s]\nfloat x_r, y_r, z_r;         // Position [m]\nfloat vx_r, vy_r, vz_r;      // Velocity [m/s]\n\n// Auxiliary variables for logging Euler angles (CFClient uses degrees and not radians)\nfloat log_phi, log_theta, log_psi;\n\n// Logging group that stream variables to CFClient.\nLOG_GROUP_START(stateEstimate)\nLOG_ADD_CORE(LOG_FLOAT, roll, &amp;log_phi)\nLOG_ADD_CORE(LOG_FLOAT, pitch, &amp;log_theta)\nLOG_ADD_CORE(LOG_FLOAT, yaw, &amp;log_psi)\nLOG_ADD_CORE(LOG_FLOAT, x, &amp;x)\nLOG_ADD_CORE(LOG_FLOAT, y, &amp;y)\nLOG_ADD_CORE(LOG_FLOAT, z, &amp;z)\nLOG_ADD_CORE(LOG_FLOAT, vx, &amp;vx)\nLOG_ADD_CORE(LOG_FLOAT, vy, &amp;vy)\nLOG_ADD_CORE(LOG_FLOAT, vz, &amp;vz)\nLOG_GROUP_STOP(stateEstimate)\n\n// Get reference setpoints from commander module\nvoid reference()\n{\n    // Declare variables that store the most recent setpoint and state from commander\n    static setpoint_t setpoint;\n    static state_t state;\n\n    // Retrieve the current commanded setpoints and state from commander module\n    commanderGetSetpoint(&amp;setpoint, &amp;state);\n\n    // Extract position references from the received setpoint\n    x_r = setpoint.position.x;               // X position reference [m]\n    y_r = 0.0f;                              // Y position reference [m]\n    z_r = setpoint.position.z;               // Z position reference [m]\n    psi_r = setpoint.position.y * pi / 2.0f; // Yaw angle reference [rad] (maps 0.5m -&gt; 45\u00ba)\n}\n\n// Get sensor readings from estimator module\nvoid sensors()\n{\n    // Declare variable that store the most recent measurement from estimator\n    static measurement_t measurement;\n\n    // Retrieve the current measurement from estimator module\n    while (estimatorDequeue(&amp;measurement))\n    {\n        switch (measurement.type)\n        {\n        // Get accelerometer sensor readings and convert [G's -&gt; m/s^2]\n        case MeasurementTypeAcceleration:\n            ax = -measurement.data.acceleration.acc.x * 9.81f;\n            ay = -measurement.data.acceleration.acc.y * 9.81f;\n            az = -measurement.data.acceleration.acc.z * 9.81f;\n            break;\n        // Get gyroscope sensor readings and convert [deg/s -&gt; rad/s]\n        case MeasurementTypeGyroscope:\n            gx = measurement.data.gyroscope.gyro.x * pi / 180.0f;\n            gy = measurement.data.gyroscope.gyro.y * pi / 180.0f;\n            gz = measurement.data.gyroscope.gyro.z * pi / 180.0f;\n            break;\n        // Get flow sensor readings [m]\n        case MeasurementTypeTOF:\n            d = measurement.data.tof.distance;\n            break;\n        // Get optical flow sensor readings and convert [10.px -&gt; px]\n        case MeasurementTypeFlow:\n            px = measurement.data.flow.dpixelx * 0.1f;\n            py = measurement.data.flow.dpixely * 0.1f;\n            break;\n        default:\n            break;\n        }\n    }\n}\n\n// Compute motor commands\nvoid mixer()\n{\n    // Quadcopter parameters\n    static const float l = 35.0e-3f;  // Distance from motor to quadcopter center of mass [m]\n    static const float a2 = 6.2e-8f;  // Quadratic motor model gain [s^2/rad^2]\n    static const float a1 = 2.4e-4f;  // Linear motor model gain [s/rad]\n    static const float kl = 2.0e-08f; // Lift coefficient [N.s^2]\n    static const float kd = 2.0e-10f; // Drag coefficient [N.m.s^2]\n\n    // Compute required motor angular velocities squared (omega^2)\n    float omega1 = (1.0f / 4.0f) * (ft / kl - tx / (kl * l) - ty / (kl * l) - tz / kd);\n    float omega2 = (1.0f / 4.0f) * (ft / kl - tx / (kl * l) + ty / (kl * l) + tz / kd);\n    float omega3 = (1.0f / 4.0f) * (ft / kl + tx / (kl * l) + ty / (kl * l) - tz / kd);\n    float omega4 = (1.0f / 4.0f) * (ft / kl + tx / (kl * l) - ty / (kl * l) + tz / kd);\n\n    // Clamp to non-negative and take square root\n    omega1 = (omega1 &gt;= 0.0f) ? sqrtf(omega1) : 0.0f;\n    omega2 = (omega2 &gt;= 0.0f) ? sqrtf(omega2) : 0.0f;\n    omega3 = (omega3 &gt;= 0.0f) ? sqrtf(omega3) : 0.0f;\n    omega4 = (omega4 &gt;= 0.0f) ? sqrtf(omega4) : 0.0f;\n\n    // Compute motor PWM using motor model\n    pwm1 = a2 * omega1 * omega1 + a1 * omega1;\n    pwm2 = a2 * omega2 * omega2 + a1 * omega2;\n    pwm3 = a2 * omega3 * omega3 + a1 * omega3;\n    pwm4 = a2 * omega4 * omega4 + a1 * omega4;\n}\n\n// Apply motor commands\nvoid motors()\n{\n    // Check is quadcopter is armed or disarmed\n    if (supervisorIsArmed())\n    {\n        // Check if quadcopter has been commanded to take-off or land\n        if (z_r &gt; 0.0f)\n        {\n            // Apply calculated PWM values if is commanded to take-off\n            motorsSetRatio(MOTOR_M1, pwm1 * UINT16_MAX);\n            motorsSetRatio(MOTOR_M2, pwm2 * UINT16_MAX);\n            motorsSetRatio(MOTOR_M3, pwm3 * UINT16_MAX);\n            motorsSetRatio(MOTOR_M4, pwm4 * UINT16_MAX);\n        }\n        else\n        {\n            // Apply idle PWM value if is commanded to land\n            motorsSetRatio(MOTOR_M1, 0.1f * UINT16_MAX);\n            motorsSetRatio(MOTOR_M2, 0.1f * UINT16_MAX);\n            motorsSetRatio(MOTOR_M3, 0.1f * UINT16_MAX);\n            motorsSetRatio(MOTOR_M4, 0.1f * UINT16_MAX);\n        }\n    }\n    else\n    {\n        // Turn-off all motor if disarmed\n        motorsStop();\n    }\n}\n\n// Estimate orientation from IMU sensor\nvoid attitudeEstimator()\n{\n    // Estimator parameters\n    static const float wc = 1.0f; // Cutoff frequency for complementary filter [rad/s]\n\n    // Use gyroscope for integration\n    wx = gx;\n    wy = gy;\n    wz = gz;\n\n    // Compute angles from accelerometer\n    float phi_a = atan2f(-ay, -az);\n    float theta_a = atan2f(ax, sqrt(ay * ay + az * az));\n\n    // Integrate gyroscope rates (Euler)\n    float phi_g = phi + (wx + wy * sinf(phi) * tanf(theta) + wz * cosf(phi) * tanf(theta)) * dt;\n    float theta_g = theta + (wy * cosf(phi) - wz * sinf(phi)) * dt;\n    float psi_g = psi + (wy * sinf(phi) / cosf(theta) + wz * cosf(phi) / cosf(theta)) * dt;\n\n    // Complementary filter: blend gyro (high freq) and accel (low freq)\n    phi = (1.0f - wc * dt) * phi_g + wc * dt * phi_a;\n    theta = (1.0f - wc * dt) * theta_g + wc * dt * theta_a;\n    psi = psi_g; // No absolute reference for yaw\n\n    //\n    log_phi = phi * 180.0f / pi;\n    log_theta = -theta * 180.0f / pi;\n    log_psi = psi * 180.0f / pi;\n}\n\n// Compute desired torques\nvoid attitudeController()\n{\n    // Quadcopter parameters\n    static const float Ixx = 20.0e-6f; // Moment of inertia around x-axis [kg/m^2]\n    static const float Iyy = 20.0e-6f; // Moment of inertia around y-axis [kg/m^2]\n    static const float Izz = 40.0e-6f; // Moment of inertia around z-axis [kg/m^2]\n\n    // Controller parameters (settling time of 0.3s and overshoot of 0,05%)\n    float kp = 240.28f; // State regulator gain for angle error [1/s^2]\n    float kd = 26.67f;  // State regulator gain for angular velocity [1/s]\n\n    // Compute torques required\n    tx = Ixx * (kp * (phi_r - phi) + kd * (wx_r - wx));\n    ty = Iyy * (kp * (theta_r - theta) + kd * (wy_r - wy));\n    tz = Izz * ((kp / 4.0f) * (psi_r - psi) + (kd / 2.0f) * (wz_r - wz)); // Settling time 2x slower (0.6s) for yaw\n}\n\n// Estimate vertical position/velocity from range sensor\nvoid verticalEstimator()\n{\n    // Quadcopter parameters\n    float m = 37.0e-3f;\n\n    // Estimator parameters\n    static const float lp = 14.14f;      // State observer gain for position correction [1/s]\n    static const float ld = 100.0f;      // State observer gain for velocity correction [1/s^2]\n    static const float dt_range = 0.05f; // Update rate of range sensor [s] (50ms -&gt; 20Hz)\n\n    // Prediction step (system model)\n    z += vz * dt;\n    vz += (ft / m - g) * dt;\n\n    // Calculate measured distante from range sensor\n    float z_m = d * cosf(phi) * cosf(theta);\n\n    // Correction step (sensor)\n    vz += (ld * dt_range) * (z_m - z);\n    z += (lp * dt_range) * (z_m - z);\n}\n\n// Compute desired total thrust\nvoid verticalController()\n{\n    // Quadcopter parameters\n    float m = 37.0e-3f;\n\n    // Controller parameters (settling time of 2.0s and overshoot of 0,05%)\n    static const float kp = 5.41f; // State regulator gain for position error [1/s^2]\n    static const float kd = 4.00f; // State regulator gain for velocity error [1/s]\n    static const float ki = 5.41f; // State regulator gain for integral error [1/s^3]\n\n    // Integral term for vertical position (static to retain value amoung function calls)\n    static float z_int;\n\n    // Compute total thrust required\n    ft = m * (g + ki * z_int + kp * (z_r - z) + kd * (vz_r - vz));\n    z_int += (z_r - z) * dt;\n}\n\n// Estimate horizontal position/velocity from optical flow sensor\nvoid horizontalEstimator()\n{\n    // Estimator parameters\n    static const float sigma = 2.19f; // Optical flow scaling factor\n    static const float wc = 50.0f;    // Cutoff frequency for complementary filter [rad/s]\n\n    // Prediction step (system model)\n    x += vx * dt;\n    y += vy * dt;\n    vx += theta * g * dt;\n    vy -= phi * g * dt;\n\n    // Calculate range distance from estimates\n    float d = z / (cosf(phi) * cosf(theta));\n\n    // Calculate measured velocity from optical flow\n    float vx_m = (px * sigma + wy) * d;\n    float vy_m = (py * sigma - wx) * d;\n\n    // Correction step (sensor)\n    vx += wc * dt * (vx_m - vx);\n    vy += wc * dt * (vy_m - vy);\n}\n\n// Compute desired roll/pitch angles\nvoid horizontalController()\n{\n    // Controller parameters (settling time of 3.0s and overshoot of 0,05%)\n    static const float kp = 2.40f;\n    static const float kd = 2.67f;\n\n    // Compute angle reference (nested control)\n    phi_r = -(1.0f / g) * (kp * (y_r - y) + kd * (vy_r - vy));\n    theta_r = (1.0f / g) * (kp * (x_r - x) + kd * (vx_r - vx));\n}\n\n// Main application task\nvoid appMain(void *param)\n{\n    // Infinite loop (runs at 200Hz)\n    while (true)\n    {\n        reference();                  // Get reference setpoints from commander module\n        sensors();                    // Get sensor readings from estimator module\n        attitudeEstimator();          // Estimate orientation from IMU sensor\n        verticalEstimator();          // Estimate vertical position/velocity from range sensro\n        horizontalEstimator();        // Estimate horizontal position/velocity from optical flow sensor\n        horizontalController();       // Compute desired roll/pitch angles\n        verticalController();         // Compute desired total thrust\n        attitudeController();         // Compute desired torques\n        mixer();                      // Compute motor commands\n        motors();                     // Apply motor commands\n        vTaskDelay(pdMS_TO_TICKS(5)); // Wait 5 ms\n    }\n}\n</code></pre>"},{"location":"basic_concepts/aerodynamics/","title":"Aerodin\u00e2mica","text":""},{"location":"basic_concepts/aerodynamics/#aerofolio","title":"Aerof\u00f3lio","text":"<p>O modelo matem\u00e1tico de um drone, qualquer que seja seu tipo, cont\u00e9m diversos par\u00e2metros aerodin\u00e2micos. No entanto, para obter o conhecimento necess\u00e1rio, come\u00e7aremos examinando as for\u00e7as aerodin\u00e2micas em um aerof\u00f3lio.</p>"},{"location":"basic_concepts/aerodynamics/#forcas-aerodinamicas","title":"For\u00e7as aerodin\u00e2micas","text":"<p>A figura abaixo mostra a sec\u00e7\u00e3o transversal de um aerof\u00f3lio, um corpo te\u00f3rico moldado para produzir sustenta\u00e7\u00e3o quando colocado em um fluxo de ar. </p> <p></p> <p>Apesar de um aerof\u00f3lio ser projetado para produzir uma for\u00e7a desejada de sustenta\u00e7\u00e3o \\(f_l\\) (perpendicular \u00e0 velocidade \\(v\\)): $$ f_l = \\frac{1}{2} \\rho A C_l v^2  $$</p> <p>Ele tamb\u00e9m produz uma for\u00e7a indesejada de arrasto \\(f_d\\) (paralela \u00e0 velocidade \\(v\\)): $$ f_d = \\frac{1}{2} \\rho A C_d v^2  $$</p> <p>Onde:</p> <ul> <li>\\(\\rho\\) - Densidade do ar (\\(kg/m^3\\))</li> <li>\\(A\\) - \u00c1rea de superf\u00edcie (\\(m^2\\))</li> <li>\\(C_l\\) - Coeficiente de sustenta\u00e7\u00e3o (adimensional)</li> <li>\\(C_d\\) - Coeficiente de arrasto (adimensional)</li> <li>\\(v\\) - Velocidade linear do aerof\u00f3lio (\\(m/s\\))</li> </ul>"},{"location":"basic_concepts/aerodynamics/#coeficientes-aerodinamicos","title":"Coeficientes aerodin\u00e2micos","text":"<p>Os coeficientes aerodin\u00e2micos n\u00e3o s\u00e3o constantes, eles variam conforme as seguintes condi\u00e7\u00f5es aerodin\u00e2micas:</p> <ul> <li>\u00c2ngulo de ataque (\\(\\alpha\\)), que \u00e9 o \u00e2ngulo que a linha m\u00e9dia do aerof\u00f3lio (tamb\u00e9m chamada de ``corda'') faz com o vetor velocidade</li> <li>N\u00famero de Reynolds (\\(\\frac{\\rho v D}{\\mu}\\)), que \u00e9 uma medida adimensional e define o regime de escoamento do ar (laminar ou turbulento)</li> <li>N\u00famero Mach (\\(\\frac{v}{v_s}\\)), que \u00e9 a raz\u00e3o entre a velocidade e a velocidade do som e define o regime de velocidade (subs\u00f4nica, supers\u00f4nica e hipers\u00f4nica)</li> </ul> <p>Para aerof\u00f3lios que se movem a velocidades subs\u00f4nicas (\\(&lt;1.000km/h\\)), apenas o \u00e2ngulo de ataque \\(\\alpha\\), representado na figura abaixo, acaba apresentando uma influ\u00eancia significativa.</p> <p></p> <p>H\u00e1 diversos perfils diferentes para um aerfof\u00f3lio. Um bastante conhecido e utilizado \u00e9 o perfil Clark Y, cujos coeficientes de arrasto e sustenta\u00e7\u00e3o em fun\u00e7\u00e3o do \u00e2ngulo de ataque s\u00e3o bem conhecidos e dados<sup>1</sup> pelo gr\u00e1fico abaixo.</p> <p></p> <p>Enquanto o coeficiente de arrasto s\u00f3 aumenta com o \u00e2ngulo de ataque, o coeficiente de sustenta\u00e7\u00e3o tem um ponto m\u00e1ximo (aproximadamente em \\(\\alpha=18^{\\circ}\\)). Esse ponto \u00e9 conhecido como \"estol\" ou simplesmente \"perda de sustenta\u00e7\u00e3o\", e ele ocorre quando o fluxo de ar descola da asa (deixa de seguir o contorno superior da asa gerando uma turbul\u00eancia).</p>"},{"location":"basic_concepts/aerodynamics/#drone-de-asas-fixas","title":"Drone de asas fixas","text":"<p>Para consolidar esses conceitos, vamos considerar um exemplo simples de um drone de asas fixas.</p> <p>Exerc\u00edcio 1</p> <p>Considerar um drone de asas fixas (asa voadora) em cruzeiro, isto \u00e9, voando no plano com velocidade constante e as seguintes caracter\u00edsticas<sup>2</sup>:</p> <ul> <li>Massa de \\(40g\\) e comprimento de \\(10cm\\)</li> <li>Asas perfil Clark Y com \\(10cm\\) de envergadura</li> <li>Propulsores com \\(60\\%\\) de efici\u00eancia </li> <li>Bateria de \\(3,7V\\) e \\(350mAh\\)</li> </ul> a) Desenhe o diagrama de corpo livre das for\u00e7as que atuam nesse drone b) Determine a \u00e1rea total das asas do drone assumindo que seu corpo \u00e9 triangular \\[ \\begin{align*}     A &amp;= \\frac{10 \\cdot 10}{2} \\\\     A &amp;= 50 \\text{cm}^2 \\end{align*} \\] c) Determine os coeficientes de arrasto e sustenta\u00e7\u00e3o das asas do drone \\[ \\begin{align*}     C_l &amp;= 0,35 \\\\     C_d &amp;= 0,02 \\end{align*} \\] d) Determine a velocidade do drone \\[ \\begin{align*}     \\sum f_y &amp;= 0 \\\\     f_l - f_p &amp;= 0 \\\\     \\frac{1}{2} \\rho A C_l v^2 - mg &amp;= 0 \\\\     v &amp;= \\sqrt{\\frac{2mg}{\\rho AC_l}} \\\\     v &amp;= \\sqrt{\\frac{2 \\cdot 0,04 \\cdot 9,81}{1,225 \\cdot 50 \\times 10^{-4} \\cdot 0,35}} \\\\     v &amp;= 19,13 \\text{m/s} \\quad (\\approx 69\\text{km/h}) \\end{align*} \\] e) Determine a for\u00e7a de empuxo dos propulsores do drone \\[ \\begin{align*}     \\sum f_x &amp;= 0 \\\\     f_e - f_d &amp;= 0 \\\\     f_e - \\frac{1}{2} \\rho A C_d v^2  &amp;= 0 \\\\     f_e &amp;= \\frac{1}{2} \\rho A C_d v^2 \\\\     f_e &amp;= \\frac{1}{2} 1,225 \\cdot 50 \\times 10^{-4} \\cdot 0,02 \\cdot 19,13^2 \\\\     f_e &amp;= 0,0224 \\text{N} \\end{align*} \\] f) Determine o consumo energ\u00e9tico do drone \\[ \\begin{align*}     P_m &amp;= f_e v \\\\     P_m &amp;= 0,0224 \\cdot 19,13 \\\\     P_m &amp;= 0,429 \\text{W} \\end{align*} \\] \\[ \\begin{align*}     \\eta &amp;= \\frac{P_m}{P_e} \\\\     P_e &amp;= \\frac{P_m}{\\eta} \\\\     P_e &amp;= \\frac{0,429}{0,6} \\\\     P_e &amp;= 0,715 \\text{W} \\end{align*} \\] g) Determine quanto tempo que o drone consegue permanecer no ar \\[ \\begin{align*}     E &amp;= P_e \\Delta t \\\\     e_s i_s &amp;= P_e \\Delta t \\\\     \\Delta t &amp;= \\frac{e_s i_s}{P_e} \\\\     \\Delta t &amp;= \\frac{3,7 \\cdot ( 0,35 \\cdot 3600)}{0,715} \\\\     \\Delta t &amp;= 6.519 \\text{s} \\quad (\\approx 1\\text{h}49\\text{min}) \\end{align*} \\]"},{"location":"basic_concepts/aerodynamics/#helice","title":"H\u00e9lice","text":"<p>Uma h\u00e9lice \u00e9 composta por \\(n\\) p\u00e1s, onde cada p\u00e1 pode ser interpretada como um aerof\u00f3lio.</p>"},{"location":"basic_concepts/aerodynamics/#forcas-e-torques-aerodinamicos","title":"For\u00e7as e torques aerodin\u00e2micos","text":"<p>Quando a h\u00e9lice rotaciona, surgem for\u00e7as de sustenta\u00e7\u00e3o e arrasto em cada uma de suas p\u00e1s, conforme a figura abaixo:</p> <p></p> <p>Onde:</p> <ul> <li>\\(d\\) - Dist\u00e2ncia do centro de press\u00e3o ao eixo de rota\u00e7\u00e3o (\\(m\\))</li> <li>\\(\\omega\\) - Velocidade angular da h\u00e9lice (\\(rad/s\\))</li> </ul> <p>Exerc\u00edcio 2</p> <p>Determine as for\u00e7as de sustenta\u00e7\u00e3o \\(f_{l_{1,2}}\\) e arrasto \\(f_{d_{1,2}}\\) nas p\u00e1s da h\u00e9lice em fun\u00e7\u00e3o de sua velocidade angular</p> Resposta \\[ \\begin{align*}     f_{l_{1,2}} &amp;= \\frac{1}{2} \\rho A C_l v^2 \\\\      f_{l_{1,2}} &amp;= \\frac{1}{2} \\rho A C_l (\\omega d )^2 \\\\     f_{l_{1,2}} &amp;= \\frac{1}{2} \\rho A C_l d^2 \\omega^2  \\end{align*} \\] \\[ \\begin{align*}     f_{d_{1,2}} &amp;= \\frac{1}{2} \\rho A C_d v^2 \\\\      f_{d_{1,2}} &amp;= \\frac{1}{2} \\rho A C_d (\\omega d )^2 \\\\     f_{d_{1,2}} &amp;= \\frac{1}{2} \\rho A C_d d^2 \\omega^2  \\end{align*} \\] <p>As for\u00e7as de sustenta\u00e7\u00e3o e arrasto em cada uma das p\u00e1s podem ser representadas por uma \u00fanica for\u00e7a de sustenta\u00e7\u00e3o e torque de arrasto total, conforme a figura abaixo.</p> <p></p> <p>Exerc\u00edcio 3</p> <p>Determine a for\u00e7a de sustenta\u00e7\u00e3o total \\(f_l\\) e torque de arrasto total \\(\\tau_d\\)</p> Resposta \\[ \\begin{align*}     f_l &amp;= 2 f_{l_{1,2}} \\\\     f_l &amp;= 2 \\left( \\frac{1}{2} \\rho A C_l d^2 \\omega^2  \\right) \\\\     f_l &amp;= \\rho A C_l d^2 \\omega^2  \\end{align*} \\] \\[ \\begin{align*}     \\tau_d &amp;= 2 \\left( d f_{d_{1,2}} \\right) \\\\      \\tau_d &amp;= 2 \\left( d \\left( \\frac{1}{2} \\rho A C_d d^2 \\omega^2 \\right) \\right) \\\\     \\tau_d &amp;= \\rho A C_d d^3 \\omega^2  \\end{align*} \\] <p>Como todos os par\u00e2metros s\u00e3o constantes e apenas a velocidade angular \\(\\omega\\) varia, a for\u00e7a de sustenta\u00e7\u00e3o e o torque de arrasto total podem ser simplificados por:</p> \\[ f_l = \\underbrace{\\rho A C_l d^2}_{k_l} \\omega^2  \\hspace{5cm} \\tau_d = \\underbrace{\\rho A C_d d^3}_{k_d} \\omega^2  \\] <p>Onde:</p> <ul> <li>\\(k_l\\) - Coeficiente de sustenta\u00e7\u00e3o da h\u00e9lice (\\(N.s^2/rad^2\\))</li> <li>\\(k_d\\) - Coeficiente de arrasto da h\u00e9lice (\\(N.m.s^2/rad^2\\))</li> </ul>"},{"location":"basic_concepts/aerodynamics/#constantes-aerodinamicas","title":"Constantes aerodin\u00e2micas","text":"<p>Ou seja, apenas dois par\u00e2metros definem a for\u00e7a e o torque que uma h\u00e9lice produz, que dependem do quadrado de sua velocidade angular: $$ f_l = k_l \\omega^2  \\hspace{5cm} \\tau_d = k_d \\omega^2  $$</p> <p>Exerc\u00edcio 4</p> <p>Com o aux\u00edlio de uma r\u00e9gua, estime<sup>3</sup> as constantes aerodin\u00e2micas das h\u00e9lices do Bitcraze Crazyflie e anote elas abaixo. Assuma que a h\u00e9lice pode ser aproximada a um perfil Clark Y com \u00e2ngulo de ataque \\(\\alpha = 5^\\circ\\), sendo a constante de sustenta\u00e7\u00e3o igual por\u00e9m a constante de arrasto 10x maior devido \u00e0 turbul\u00eancia gerada pela h\u00e9lice.</p> Resposta \\[ \\begin{align*}     k_l &amp;= 2 \\left( \\frac{1}{2} \\rho A C_l d^2 \\right) \\\\     k_l &amp;= 2 \\left( \\frac{1}{2} 1,225 \\cdot (2,1 \\times 10^{-2} \\cdot 0,6 \\times 10^{-2}) \\cdot 0,7 \\cdot (1,5 \\times 10^{-2})^2 \\right) \\\\     k_l &amp;= 2,43 \\times10^{-8} \\text{N.s}^2\\text{/rad}^2 \\end{align*} \\] \\[ \\begin{align*}     k_d &amp;= 2 \\left( \\frac{1}{2} \\rho A C_d d^2 \\right) d \\\\     k_d &amp;= 2 \\left( \\frac{1}{2} 1,225 \\cdot (2,1 \\times 10^{-2} \\cdot 0,6 \\times 10^{-2}) \\cdot 0,4 \\cdot (1,5 \\times 10^{-2})^2 \\right) \\cdot 1,5 \\times 10^{-2} \\\\     k_d &amp;= 2,08 \\times10^{-10} \\text{N.m.s}^2\\text{/rad}^2 \\end{align*} \\] <p>Esses dois par\u00e2metros ser\u00e3o determinados experimentalmente (\\(k_l\\) e \\(k_d\\)), e voc\u00ea ver\u00e1 que a chegar\u00e1 em valores muito pr\u00f3ximos aos estimados acima.</p>"},{"location":"basic_concepts/aerodynamics/#drone-multi-rotor","title":"Drone multi-rotor","text":"<p>Para consolidar esses conceitos, vamos considerar um exemplo simples de um drone multi-rotor.</p> <p>Exerc\u00edcio 5</p> <p>Considerar um drone multi-rotor (quadricoptero) pairando no ar, isto \u00e9, parado no espa\u00e7o com as seguintes caracter\u00edsticas<sup>2</sup>:</p> <ul> <li>Massa de \\(40g\\)</li> <li>H\u00e9lices com constante de sustenta\u00e7\u00e3o de \\(2,0\\times10^{-8} \\text{N}.\\text{s}^2/\\text{rad}^2\\) e constante de arrasto de \\(2,0\\times10^{-10} \\text{N}.\\text{m}.\\text{s}^2\\text{/rad}^2\\)</li> <li>Motores el\u00e9tricos com \\(90\\%\\) de efici\u00eancia </li> <li>Bateria de \\(3,7V\\) e \\(350mAh\\)</li> </ul> a) Desenhe o diagrama de corpo livre das for\u00e7as que atuam nesse drone b) Determine a velocidade angular das h\u00e9lices do drone \\[ \\begin{align*}     \\sum f_y &amp;= 0 \\\\     4 f_l - f_p &amp;= 0 \\\\     4 k_l \\omega^2 - mg &amp;= 0 \\\\     \\omega &amp;= \\sqrt{\\frac{mg}{4 k_l}} \\\\     \\omega &amp;= \\sqrt{\\frac{0,04 \\cdot 9,81}{4 \\cdot 2,0\\times10^{-8}}} \\\\     \\omega &amp;= 2.215 \\text{rad/s} \\quad (\\approx 21.149\\text{rpm}) \\end{align*} \\] c) Determine o torque dos motores do drone \\[ \\begin{align*}     \\sum \\tau &amp;= 0 \\\\     \\tau_m - \\tau_d &amp;= 0 \\\\     \\tau_m - k_d \\omega^2 &amp;= 0 \\\\     \\tau_m &amp;= k_d \\omega^2 \\\\     \\tau_m &amp;= 2,0 \\times 10 ^{-10} \\cdot 2215^2 \\\\     \\tau_m &amp;= 0,000981 \\text{N.m} \\\\ \\end{align*} \\] d) Determine o consumo energ\u00e9tico do drone \\[ \\begin{align*}     P_m &amp;= 4 \\tau_m \\omega \\\\     P_m &amp;= 4 \\cdot 0,000981 \\cdot 2215 \\\\     P_m &amp;= 8,69 \\text{W} \\end{align*}    \\] \\[ \\begin{align*}     \\eta &amp;= \\frac{P_m}{P_e} \\\\     P_e &amp;= \\frac{P_m}{\\eta} \\\\     P_e &amp;= \\frac{8,69}{0,9} \\\\     P_e &amp;= 9,66 \\text{W} \\end{align*} \\] e) Determine quanto tempo que o drone consegue permanecer no ar \\[ \\begin{align*}     E &amp;= P_e \\Delta t \\\\     e_s i_s &amp;= P_e \\Delta t \\\\     \\Delta t &amp;= \\frac{e_s i_s}{P_e} \\\\     \\Delta t &amp;= \\frac{3,7 (\\cdot 0,35 \\cdot 3600)}{9,66} \\\\     \\Delta t &amp;= 483\\text{s} \\quad (\\approx 8\\text{min}) \\end{align*} \\] <p>Compare este resultado, do drone multi rotor, com o anterior, do drone de asas fixa. Note como o drone de asa fixa consegue permanecer muito mais tempo no ar (&gt;10x), com a desvatagem de n\u00e3o conseguir permanecer parado e nem decolar/pousar na vertical como um drone multi-rotor.</p> <ol> <li> <p>Assumindo que o n\u00famero de Reynolds e o n\u00famero Mach permane\u00e7am dentro de uma determinada faixa de valores.\u00a0\u21a9</p> </li> <li> <p>Considere \\(g = 9,81\\text{m/s}^2\\) e \\(\\rho = 1,225\\text{kg/m}^3\\) \u21a9\u21a9</p> </li> <li> <p>Estamos preocupados apenas com a ordem de grandeza dos resultados.\u00a0\u21a9</p> </li> </ol>"}]}