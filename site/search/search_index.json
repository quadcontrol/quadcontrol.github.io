{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Bem-vindo!","text":"<p>Este site re\u00fane toda a documenta\u00e7\u00e3o da eletiva de Drones do Insper \u2014 uma esp\u00e9cie de apostila online, cuidadosamente organizada com:</p> <ul> <li>\ud83d\udcda Explica\u00e7\u00f5es te\u00f3ricas e f\u00f3rmulas fundamentais</li> <li>\ud83d\udcbb C\u00f3digos em C, Python e MATLAB</li> <li>\ud83d\uddbc\ufe0f Figuras, diagramas e v\u00eddeos demonstrativos</li> <li>\ud83d\udef8 Exemplos de aplica\u00e7\u00f5es pr\u00e1ticas</li> </ul> <p>Nosso objetivo \u00e9 ensinar conceitos de controle e programa\u00e7\u00e3o embarcada de forma pr\u00e1tica e acess\u00edvel, usando um quadricoptero real. Explore os t\u00f3picos no menu lateral \u2014 e boa jornada! \ud83d\ude80</p>"},{"location":"#sobre-a-eletiva","title":"Sobre a eletiva","text":"<p>Nesta eletiva, os alunos desenvolvem do zero todo o algoritmo de estima\u00e7\u00e3o e controle de um quadric\u00f3ptero \u2014 o Bitcraze Crazyflie 2.1 Brushless.</p> <p></p> <p>A jornada come\u00e7a com os cl\u00e1ssicos <code>led_blink.c</code> e <code>hello_world.c</code>, e termina com o drone voando sozinho. Ao longo do curso, o aluno:</p> <ul> <li>\ud83e\udde0 Programa um microcontrolador ARM<sup>1</sup> usando FreeRTOS<sup>2</sup></li> <li>\ud83d\udce1 Trabalha com sensores embarcados (IMU<sup>3</sup>, proximidade e fluxo \u00f3ptico) via I\u00b2C<sup>4</sup> e SPI<sup>5</sup></li> <li>\ud83d\udd27 Controla motores BLDC<sup>6</sup> por meio de ESCs<sup>7</sup></li> <li>\ud83d\udcbb Implementa em C<sup>8</sup> algoritmos de estima\u00e7\u00e3o e controle</li> </ul> <p>A avalia\u00e7\u00e3o \u00e9 100% pr\u00e1tica: ao final do curso, o drone deve voar at\u00e9 um dos helipontos, cada um com uma nota associada \u00e0 sua dificuldade - quanto mais longe ou de dif\u00edcil acesso o heliponto, maior sua m\u00e9dia final na disciplina.</p> <p></p> <p>Quer ver um pouco disso na pr\u00e1tica? Assista o v\u00eddeo abaixo!</p> <ol> <li> <p>ARM - Microcontroladores da fam\u00edlia ARM s\u00e3o chips compactos e eficientes, usados como \"c\u00e9rebro\" de muitos dispositivos embarcados, como drones, celulares e eletrodom\u00e9sticos.\u00a0\u21a9</p> </li> <li> <p>FreeRTOS - Um sistema operacional leve e em tempo real (Real-Time Operating System) que permite rodar v\u00e1rias tarefas no microcontrolador de forma organizada e com alta precis\u00e3o de tempo.\u00a0\u21a9</p> </li> <li> <p>IMU - Unidade de Medi\u00e7\u00e3o Inercial (Inertial Measurement Unit), composta por aceler\u00f4metros e girosc\u00f3pios, usada para medir a orienta\u00e7\u00e3o.\u00a0\u21a9</p> </li> <li> <p>I\u00b2C - Um protocolo de comunica\u00e7\u00e3o digital simples, que conecta sensores ao microcontrolador usando apenas dois fios.\u00a0\u21a9</p> </li> <li> <p>SPI - Um protocolo de comunica\u00e7\u00e3o digital mais r\u00e1pido que o I\u00b2C, usado quando h\u00e1 necessidade de maior desempenho mas necessitando de quatro fios.\u00a0\u21a9</p> </li> <li> <p>BLDC - Motores el\u00e9trico sem escovas (Brushless DC Motor), mais eficientes e dur\u00e1veis.\u00a0\u21a9</p> </li> <li> <p>ESC - Controlador Eletr\u00f4nico de Velocidade (Electronic Speed Controller), que regula a pot\u00eancia enviada aos motores e faz a comuta\u00e7\u00e3o eletr\u00f4nica na frequ\u00eancia correta.\u00a0\u21a9</p> </li> <li> <p>C - Linguagem de programa\u00e7\u00e3o de baixo n\u00edvel, muito utilizada em sistemas embarcados.\u00a0\u21a9</p> </li> </ol>"},{"location":"basic_concepts/aerodynamics/","title":"Aerodin\u00e2mica","text":"<p>Para conseguir controlar um drone, \u00e9 essencial primeiro entender a f\u00edsica por tr\u00e1s dele. Aqui, voc\u00ea vai aprender os conceitos b\u00e1sicos de aerodin\u00e2mica que explicam como o drone se mant\u00e9m no ar.</p>"},{"location":"basic_concepts/aerodynamics/#aerofolio","title":"Aerof\u00f3lio","text":"<p>O modelo matem\u00e1tico de um drone, qualquer que seja seu tipo, cont\u00e9m diversos par\u00e2metros aerodin\u00e2micos. No entanto, para obter o conhecimento necess\u00e1rio, come\u00e7aremos examinando as for\u00e7as aerodin\u00e2micas em um aerof\u00f3lio.</p>"},{"location":"basic_concepts/aerodynamics/#forcas-aerodinamicas","title":"For\u00e7as aerodin\u00e2micas","text":"<p>A figura abaixo mostra a sec\u00e7\u00e3o transversal de um aerof\u00f3lio, um corpo te\u00f3rico moldado para produzir sustenta\u00e7\u00e3o quando colocado em um fluxo de ar.</p> <p></p> <p>Apesar de um aerof\u00f3lio ser projetado para produzir uma for\u00e7a desejada de sustenta\u00e7\u00e3o \\(f_l\\) (perpendicular \u00e0 velocidade \\(v\\)), ele tamb\u00e9m produz uma for\u00e7a indesejada de arrasto \\(f_d\\) (paralela \u00e0 velocidade \\(v\\)): $$     {\\color{lightgreen}f_l} = \\frac{1}{2} \\rho A C_l v^2      \\qquad     f_d = \\frac{1}{2} \\rho A C_d v^2  $$</p> <p>Onde:</p> <ul> <li>\\(\\rho\\) - Densidade do ar (\\(kg/m^3\\))</li> <li>\\(A\\) - \u00c1rea de superf\u00edcie (\\(m^2\\))</li> <li>\\(C_l\\) - Coeficiente de sustenta\u00e7\u00e3o (adimensional)</li> <li>\\(C_d\\) - Coeficiente de arrasto (adimensional)</li> <li>\\(v\\) - Velocidade linear do aerof\u00f3lio (\\(m/s\\))</li> </ul>"},{"location":"basic_concepts/aerodynamics/#coeficientes-aerodinamicos","title":"Coeficientes aerodin\u00e2micos","text":"<p>Os coeficientes de sustenta\u00e7\u00e3o e arrasto n\u00e3o s\u00e3o constantes, eles variam conforme as seguintes condi\u00e7\u00f5es aerodin\u00e2micas:</p> <ul> <li>\u00c2ngulo de ataque (\\(\\alpha\\)), que \u00e9 o \u00e2ngulo que a linha m\u00e9dia do aerof\u00f3lio (tamb\u00e9m chamada de ``corda'') faz com o vetor velocidade</li> <li>N\u00famero de Reynolds (\\(\\frac{\\rho v D}{\\mu}\\)), que \u00e9 uma medida adimensional e define o regime de escoamento do ar (laminar ou turbulento)</li> <li>N\u00famero Mach (\\(\\frac{v}{v_s}\\)), que \u00e9 a raz\u00e3o entre a velocidade e a velocidade do som e define o regime de velocidade (subs\u00f4nica, supers\u00f4nica e hipers\u00f4nica)</li> </ul> <p>Para aerof\u00f3lios que se movem a velocidades subs\u00f4nicas (\\(&lt;1.000km/h\\)), apenas o \u00e2ngulo de ataque \\(\\alpha\\), representado na figura abaixo, acaba apresentando uma influ\u00eancia significativa.</p> <p></p> <p>H\u00e1 diversos perfils diferentes para um aerfof\u00f3lio. Um bastante conhecido e utilizado \u00e9 o perfil Clark Y, cujos coeficientes de arrasto e sustenta\u00e7\u00e3o em fun\u00e7\u00e3o do \u00e2ngulo de ataque s\u00e3o bem conhecidos e dados<sup>1</sup> pelo gr\u00e1fico abaixo.</p> <p></p> <p>Enquanto o coeficiente de arrasto s\u00f3 aumenta com o \u00e2ngulo de ataque, o coeficiente de sustenta\u00e7\u00e3o tem um ponto m\u00e1ximo (\\(\\alpha=18^{\\circ}\\)). Esse ponto \u00e9 conhecido como \"estol\" ou simplesmente \"perda de sustenta\u00e7\u00e3o\", e ele ocorre quando o fluxo de ar descola da asa (deixa de seguir o contorno superior da asa gerando uma turbul\u00eancia). Note que o coeficiente de sustenta\u00e7\u00e3o \u00e9 nulo com uma leve inclina\u00e7\u00e3o negativa (\\(\\alpha=-5^{\\circ}\\)), e negativo abaixo disso.</p> <p>Exerc\u00edcio 1</p> <p>Para consolidar esses conceitos, considere um drone de asas fixas (asa voadora) em cruzeiro, isto \u00e9, voando no plano com velocidade constante e as seguintes caracter\u00edsticas<sup>2</sup>:</p> <ul> <li>Massa de \\(40g\\) e comprimento de \\(10cm\\)</li> <li>Asas perfil Clark Y com \\(10cm\\) de envergadura</li> <li>Propulsores com \\(60\\%\\) de efici\u00eancia </li> <li>Bateria de \\(3,7V\\) e \\(350mAh\\)</li> </ul> a) Desenhe o diagrama de corpo livre das for\u00e7as que atuam nesse drone b) Determine a \u00e1rea total das asas do drone assumindo que seu corpo \u00e9 triangular \\[ \\begin{align*}     A &amp;= \\frac{10 \\cdot 10}{2} \\\\     A &amp;= 50 \\text{cm}^2 \\end{align*} \\] c) Determine os coeficientes de arrasto e sustenta\u00e7\u00e3o das asas do drone \\[ \\begin{align*}     C_l &amp;= 0,35 \\\\     C_d &amp;= 0,02 \\end{align*} \\] d) Determine a velocidade do drone \\[ \\begin{align*}     \\sum f_y &amp;= 0 \\\\     f_l - f_p &amp;= 0 \\\\     \\frac{1}{2} \\rho A C_l v^2 - mg &amp;= 0 \\\\     v &amp;= \\sqrt{\\frac{2mg}{\\rho AC_l}} \\\\     v &amp;= \\sqrt{\\frac{2 \\cdot 0,04 \\cdot 9,81}{1,225 \\cdot 50 \\times 10^{-4} \\cdot 0,35}} \\\\     v &amp;= 19,13 \\text{m/s} \\quad (\\approx 69\\text{km/h}) \\end{align*} \\] e) Determine a for\u00e7a de empuxo dos propulsores do drone \\[ \\begin{align*}     \\sum f_x &amp;= 0 \\\\     f_e - f_d &amp;= 0 \\\\     f_e - \\frac{1}{2} \\rho A C_d v^2  &amp;= 0 \\\\     f_e &amp;= \\frac{1}{2} \\rho A C_d v^2 \\\\     f_e &amp;= \\frac{1}{2} 1,225 \\cdot 50 \\times 10^{-4} \\cdot 0,02 \\cdot 19,13^2 \\\\     f_e &amp;= 0,0224 \\text{N} \\end{align*} \\] f) Determine o consumo energ\u00e9tico do drone \\[ \\begin{align*}     P_m &amp;= f_e v \\\\     P_m &amp;= 0,0224 \\cdot 19,13 \\\\     P_m &amp;= 0,429 \\text{W} \\end{align*} \\] \\[ \\begin{align*}     \\eta &amp;= \\frac{P_m}{P_e} \\\\     P_e &amp;= \\frac{P_m}{\\eta} \\\\     P_e &amp;= \\frac{0,429}{0,6} \\\\     P_e &amp;= 0,715 \\text{W} \\end{align*} \\] g) Determine quanto tempo que o drone consegue permanecer no ar \\[ \\begin{align*}     E &amp;= P_e \\Delta t \\\\     e_s i_s &amp;= P_e \\Delta t \\\\     \\Delta t &amp;= \\frac{e_s i_s}{P_e} \\\\     \\Delta t &amp;= \\frac{3,7 \\cdot ( 0,35 \\cdot 3600)}{0,715} \\\\     \\Delta t &amp;= 6.519 \\text{s} \\quad (\\approx 1\\text{h}49\\text{min}) \\end{align*} \\]"},{"location":"basic_concepts/aerodynamics/#helice","title":"H\u00e9lice","text":"<p>Uma h\u00e9lice \u00e9 composta por \\(n\\) p\u00e1s, onde cada p\u00e1 pode ser interpretada como um aerof\u00f3lio.</p>"},{"location":"basic_concepts/aerodynamics/#forcas-e-torques-aerodinamicos","title":"For\u00e7as e torques aerodin\u00e2micos","text":"<p>Quando a h\u00e9lice rotaciona, surgem for\u00e7as de sustenta\u00e7\u00e3o e arrasto em cada uma de suas p\u00e1s, conforme a figura abaixo.</p> <p></p> <p>Onde:</p> <ul> <li>\\(d\\) - Dist\u00e2ncia do centro de press\u00e3o ao eixo de rota\u00e7\u00e3o (\\(m\\))</li> <li>\\(\\omega\\) - Velocidade angular da h\u00e9lice (\\(rad/s\\))</li> </ul> <p>Exerc\u00edcio 2</p> <p>Determine as for\u00e7as de sustenta\u00e7\u00e3o \\(f_l\\) e arrasto \\(f_d\\) nas p\u00e1s da h\u00e9lice em fun\u00e7\u00e3o de sua velocidade angular</p> Resposta \\[ \\begin{align*}     f_l &amp;= \\frac{1}{2} \\rho A C_l v^2 \\\\      f_l &amp;= \\frac{1}{2} \\rho A C_l (\\omega d )^2 \\\\     f_l &amp;= \\frac{1}{2} \\rho A C_l d^2 \\omega^2  \\end{align*} \\] \\[ \\begin{align*}     f_d &amp;= \\frac{1}{2} \\rho A C_d v^2 \\\\      f_d &amp;= \\frac{1}{2} \\rho A C_d (\\omega d )^2 \\\\     f_d &amp;= \\frac{1}{2} \\rho A C_d d^2 \\omega^2  \\end{align*} \\] <p>As for\u00e7as de sustenta\u00e7\u00e3o e arrasto em cada uma das p\u00e1s podem ser representadas por uma \u00fanica for\u00e7a de sustenta\u00e7\u00e3o e torque de arrasto da h\u00e9lice, conforme a figura abaixo.</p> <p></p> <p>Exerc\u00edcio 3</p> <p>Determine a for\u00e7a de sustenta\u00e7\u00e3o \\(f\\) e torque de arrasto \\(\\tau\\) da h\u00e9lice</p> Resposta \\[ \\begin{align*}     f &amp;= 2 f_l \\\\     f &amp;= 2 \\left( \\frac{1}{2} \\rho A C_l d^2 \\omega^2  \\right) \\\\     f &amp;= \\rho A C_l d^2 \\omega^2  \\end{align*} \\] \\[ \\begin{align*}     \\tau &amp;= 2 \\left( d f_d \\right) \\\\      \\tau &amp;= 2 \\left( d \\left( \\frac{1}{2} \\rho A C_d d^2 \\omega^2 \\right) \\right) \\\\     \\tau &amp;= \\rho A C_d d^3 \\omega^2  \\end{align*} \\] <p>Como todos os par\u00e2metros s\u00e3o constantes e apenas a velocidade angular \\(\\omega\\) varia, a for\u00e7a de sustenta\u00e7\u00e3o e torque de arrasto de uma h\u00e9lice podem ser simplificados por:</p> \\[ f = \\underbrace{\\rho A C_l d^2}_{k_l} \\omega^2  \\qquad \\tau = \\underbrace{\\rho A C_d d^3}_{k_d} \\omega^2  \\] <p>Onde:</p> <ul> <li>\\(k_l\\) - Coeficiente de sustenta\u00e7\u00e3o da h\u00e9lice (\\(N.s^2/rad^2\\))</li> <li>\\(k_d\\) - Coeficiente de arrasto da h\u00e9lice (\\(N.m.s^2/rad^2\\))</li> </ul>"},{"location":"basic_concepts/aerodynamics/#constantes-aerodinamicas","title":"Constantes aerodin\u00e2micas","text":"<p>Ou seja, apenas dois par\u00e2metros definem a for\u00e7a e o torque que uma h\u00e9lice produz, que dependem do quadrado de sua velocidade angular:</p> <p></p> \\[ f = k_l \\omega^2  \\qquad \\tau = k_d \\omega^2  \\] <p>Exerc\u00edcio 4</p> <p>Com o aux\u00edlio de uma r\u00e9gua, estime<sup>3</sup> as constantes aerodin\u00e2micas das h\u00e9lices do Bitcraze Crazyflie e anote elas abaixo. Assuma que a h\u00e9lice pode ser aproximada a um perfil Clark Y com \u00e2ngulo de ataque \\(\\alpha = 5^\\circ\\), sendo a constante de sustenta\u00e7\u00e3o igual, por\u00e9m a constante de arrasto 10x maior<sup>4</sup>. </p> Resposta \\[ \\left\\{     \\begin{align*}         \\rho &amp;= 1,225 kg/m^3 \\\\         A &amp;= 2,5 \\cdot 0,5 = 1,25 cm^2 \\\\         d &amp;= 1,5 cm \\\\         C_l &amp;= 0,7 \\\\         C_d &amp;= 0,04 \\cdot 10 = 0,4      \\end{align*} \\right. \\] \\[ \\begin{align*}     k_l &amp;= \\rho A C_l d^2\\\\     k_l &amp;= 1,225 \\cdot (1,25 \\cdot 10^{-4}) \\cdot 0,7 \\cdot (1,5 \\times 10^{-2})^2 \\\\     k_l &amp;= 2,41 \\times10^{-8} \\text{N.s}^2\\text{/rad}^2 \\end{align*} \\] \\[ \\begin{align*}     k_d &amp;= \\rho A C_d d^3 \\\\     k_d &amp;= 1,225 \\cdot (1,25 \\cdot 10^{-4}) \\cdot 0,4 \\cdot (1,5 \\times 10^{-2})^3 \\\\     k_d &amp;= 2,07 \\times10^{-10} \\text{N.m.s}^2\\text{/rad}^2 \\end{align*} \\] <p>Esses dois par\u00e2metros ser\u00e3o determinados experimentalmente (\\(k_l\\) e \\(k_d\\)), e voc\u00ea ver\u00e1 que a chegar\u00e1 em valores muito pr\u00f3ximos aos estimados acima.</p> <p>Exerc\u00edcio 5</p> <p>Para consolidar esses conceitos, considere um drone multi-rotor (quadricoptero) pairando no ar, isto \u00e9, parado no espa\u00e7o com as seguintes caracter\u00edsticas<sup>2</sup>:</p> <ul> <li>Massa de \\(40g\\)</li> <li>H\u00e9lices com constante de sustenta\u00e7\u00e3o de \\(2,0\\times10^{-8} \\text{N}.\\text{s}^2/\\text{rad}^2\\) e constante de arrasto de \\(2,0\\times10^{-10} \\text{N}.\\text{m}.\\text{s}^2\\text{/rad}^2\\)</li> <li>Motores el\u00e9tricos com \\(90\\%\\) de efici\u00eancia </li> <li>Bateria de \\(3,7V\\) e \\(350mAh\\)</li> </ul> a) Desenhe o diagrama de corpo livre das for\u00e7as que atuam nesse drone b) Determine a velocidade angular das h\u00e9lices do drone \\[ \\begin{align*}     \\sum f_y &amp;= 0 \\\\     4 f - f_w &amp;= 0 \\\\     4 k_l \\omega^2 - mg &amp;= 0 \\\\     \\omega &amp;= \\sqrt{\\frac{mg}{4 k_l}} \\\\     \\omega &amp;= \\sqrt{\\frac{0,04 \\cdot 9,81}{4 \\cdot (2,0\\times10^{-8})}} \\\\     \\omega &amp;= 2.215 \\text{rad/s} \\quad (\\approx 21.149\\text{rpm}) \\end{align*} \\] c) Determine o torque dos motores do drone \\[ \\begin{align*}     \\sum \\tau &amp;= 0 \\\\     \\tau_m - \\tau_d &amp;= 0 \\\\     \\tau_m - k_d \\omega^2 &amp;= 0 \\\\     \\tau_m &amp;= k_d \\omega^2 \\\\     \\tau_m &amp;= 2,0 \\times 10 ^{-10} \\cdot 2215^2 \\\\     \\tau_m &amp;= 0,000981 \\text{N.m} \\\\ \\end{align*} \\] d) Determine o consumo energ\u00e9tico do drone \\[ \\begin{align*}     P_m &amp;= 4 \\tau_m \\omega \\\\     P_m &amp;= 4 \\cdot 0,000981 \\cdot 2215 \\\\     P_m &amp;= 8,69 \\text{W} \\end{align*}    \\] \\[ \\begin{align*}     \\eta &amp;= \\frac{P_m}{P_e} \\\\     P_e &amp;= \\frac{P_m}{\\eta} \\\\     P_e &amp;= \\frac{8,69}{0,9} \\\\     P_e &amp;= 9,66 \\text{W} \\end{align*} \\] e) Determine quanto tempo que o drone consegue permanecer no ar \\[ \\begin{align*}     E &amp;= P_e \\Delta t \\\\     e_s i_s &amp;= P_e \\Delta t \\\\     \\Delta t &amp;= \\frac{e_s i_s}{P_e} \\\\     \\Delta t &amp;= \\frac{3,7 (\\cdot 0,35 \\cdot 3600)}{9,66} \\\\     \\Delta t &amp;= 483\\text{s} \\quad (\\approx 8\\text{min}) \\end{align*} \\] <p>Compare este resultado, do drone multi rotor, com o anterior, do drone de asas fixa. Note como o drone de asa fixa consegue permanecer muito mais tempo no ar (&gt;10x), com a desvatagem de n\u00e3o conseguir permanecer parado e nem decolar/pousar na vertical como um drone multi-rotor.</p> <ol> <li> <p>Assumindo que o n\u00famero de Reynolds e o n\u00famero Mach permane\u00e7am dentro de uma determinada faixa de valores.\u00a0\u21a9</p> </li> <li> <p>Considere \\(g = 9,81\\text{m/s}^2\\) e \\(\\rho = 1,225\\text{kg/m}^3\\) \u21a9\u21a9</p> </li> <li> <p>Estamos preocupados apenas com a ordem de grandeza dos resultados.\u00a0\u21a9</p> </li> <li> <p>Devido \u00e0 turbul\u00eancia gerada pela h\u00e9lice.\u00a0\u21a9</p> </li> </ol>"},{"location":"basic_concepts/inertia/","title":"In\u00e9rcia","text":"<p>Todo corpo resiste a mudan\u00e7as em seu estado de movimento \u2014 essa resist\u00eancia \u00e9 o que chamamos de in\u00e9rcia.</p> <p>No caso de um drone, que est\u00e1 livre para se mover e girar no espa\u00e7o, a in\u00e9rcia se manifesta de duas formas principais, e ambas s\u00e3o fundamentais para entender como ele responde aos comandos de controle:</p> <ul> <li>Massa \u2014 representa a resist\u00eancia a movimentos lineares (como subir/descer, avan\u00e7ar/recuar ou deslocar-se lateralmente). \u00c9 a chamada in\u00e9rcia translacional.</li> <li>Momento de in\u00e9rcia \u2014 representa a resist\u00eancia a movimentos angulares (como rolar, inclinar ou guinar). \u00c9 a chamada in\u00e9rcia rotacional.</li> </ul> <p>Controlar bem um drone exige compreender essas duas formas de in\u00e9rcia \u2014 e como elas influenciam as acelera\u00e7\u00f5es que conseguimos impor a ele.</p>"},{"location":"basic_concepts/inertia/#massa","title":"Massa","text":"<p>A massa representa o quanto o drone resiste a mudan\u00e7as na velocidade ao longo de um eixo de transla\u00e7\u00e3o. Ela depende da quantidade de mat\u00e9ria e \u00e9 a mesma em qualquer dire\u00e7\u00e3o. Ou seja, n\u00e3o importa se o movimento \u00e9 para cima, para frente ou para o lado: temos apenas uma \u00fanica massa.</p> <p></p> <p>Exerc\u00edcio 1</p> <p>Podemos calcular a massa do drone somando a massa de seus componentes:</p> <ul> <li>O drone que j\u00e1 considera bateria, PCB, motores, h\u00e9lices, etc.</li> <li>O m\u00f3dulo de expans\u00e3o que \u00e9 acoplado embaixo</li> </ul> <p>Determine a massa total do drone somando a massa de seus componentes. Elas podem ser obtidas nas especifica\u00e7\u00f5es t\u00e9cnicas no site da Bitcraze (cujos links foram disponibilizados acima).</p> Resposta \\[ \\begin{align*}     m &amp;= m_{cf} + m_{fd} \\\\     m &amp;= 37 + 1,6 \\\\     m &amp;= 38,6 g \\end{align*} \\]"},{"location":"basic_concepts/inertia/#momento-de-inercia","title":"Momento de In\u00e9rcia","text":"<p>O momento de in\u00e9rcia representa o quanto o drone resiste a mudan\u00e7as na velocidade angular em torno de um eixo de rota\u00e7\u00e3o. Ao contr\u00e1rio da massa, ele depende n\u00e3o apenas da quantidade de mat\u00e9ria, mas tamb\u00e9m de como ela est\u00e1 distribu\u00edda em rela\u00e7\u00e3o ao eixo de rota\u00e7\u00e3o. Como o drone pode girar em torno de tr\u00eas eixos (rolagem, inclina\u00e7\u00e3o e guinagem), ele possui tr\u00eas momentos de in\u00e9rcia: um para cada eixo.</p> <p></p> <p>Exerc\u00edcio 2</p> <p>Podemos calcular os momentos de in\u00e9rcia do drone considerando um modelo mais simples<sup>1</sup>:</p> <ul> <li>A bateria como um paralelep\u00edpedo</li> <li>Os motores com  h\u00e9lices e suportes como massas puntiformes</li> </ul> <p>Determine a momento de in\u00e9rcia total do drone em torno de cada um de seus eixos. As dimens\u00f5es necess\u00e1rias podem ser obtidas com o aux\u00edlio de um paqu\u00edmetro, j\u00e1 as massas podem ser obtidas nas especifica\u00e7\u00f5es t\u00e9cnicas no site da Bitcraze (cujos links foram disponibilizados acima).</p> Resposta <p>A bateria possui \\(9,10 \\, g\\) de massa e dimens\u00f5es \\(3,3 \\times 2,0 \\times 0,8 \\, cm\\): </p> \\[ \\left\\{ \\begin{align*}     m_b &amp;= 9,10 \\, g\\\\     a &amp;= 3,3 \\, cm\\\\     b &amp;= 2,0 \\, cm\\\\     c &amp;= 0,8 \\, cm\\\\ \\end{align*} \\right. \\] <p>Assim, usando uma tabela de momentos de in\u00e9rcia de um paralelep\u00edpedo temos que:</p> <p></p> \\[ \\begin{align*}     I_{b_{xx}} &amp;= \\frac{m_b}{12} (b^2 + c^2) &amp; \\quad I_{b_{yy}} &amp;= \\frac{m_b}{12} (a^2 + c^2) &amp; \\quad I_{b_{zz}} &amp;= \\frac{m_b}{12} (a^2 + b^2) \\\\     I_{b_{xx}} &amp;= \\frac{9,1}{12} (2,0^2 + 0,8^2) &amp; \\quad I_{b_{yy}} &amp;= \\frac{9,1}{12} (3,3^2 + 0,8^2) &amp; \\quad I_{b_{zz}} &amp;= \\frac{9,1}{12} (3,3^2 + 2,0^2) \\\\     I_{b_{xx}} &amp;= 3,52 \\, g.cm^2 &amp; \\quad I_{b_{yy}} &amp;= 8,74 \\, g.cm^2 &amp; \\quad I_{b_{zz}} &amp;= 12,29 \\, g.cm^2 \\\\ \\end{align*} \\] <p>Os motores (\\(2,30 \\, g\\)), com h\u00e9lices (\\(1,34 \\, g\\)) e suportes (\\(0,33 \\, g\\)), possuem \\(3,97 \\, g\\) de massa total e est\u00e3o a \\(10 \\, cm\\) de dist\u00e2ncia na diagonal: </p> \\[ \\left\\{ \\begin{align*}     m_m &amp;= 3,97 \\, g\\\\     l_x &amp;= 5 \\frac{\\sqrt{2}}{2} \\, cm \\\\     l_y &amp;= 5 \\frac{\\sqrt{2}}{2} \\, cm \\\\     l_z &amp;= 5 \\, cm\\\\ \\end{align*} \\right. \\] <p>Assim, considerando eles como massas puntiformes temos que:</p> <p></p> \\[ \\begin{align*}     I_{m_{xx}} &amp;= m_m l_x^2 &amp; \\quad I_{m_{yy}} &amp;= m_m l_y^2 &amp; \\quad I_{m_{zz}} &amp;= m_m l_z^2 \\\\     I_{m_{xx}} &amp;= 3,97 \\cdot {\\left( 5,0 \\frac{\\sqrt{2}}{2} \\right)}^2 &amp; \\quad I_{m_{yy}} &amp;= 3,97 \\cdot {\\left( 5,0 \\frac{\\sqrt{2}}{2} \\right)}^2 &amp; \\quad I_{m_{zz}} &amp;= 3,97 \\cdot 5,0^2 \\\\     I_{m_{xx}} &amp;= 49,62 \\, g.cm^2 &amp; \\quad I_{m_{yy}} &amp;= 49,62 \\, g.cm^2 &amp; \\quad I_{m_{zz}} &amp;= 99,25 \\, g.cm^2 \\\\ \\end{align*} \\] <p>Dessa forma, os momentos de in\u00e9rcia totais s\u00e3o dados por:</p> \\[ \\begin{align*}     I_{xx} &amp;= I_{b_{xx}} + 4 I_{m_{xx}} &amp; \\quad I_{yy} &amp;= I_{b_{yy}} + 4 I_{m_{yy}} &amp; \\quad I_{zz} &amp;= I_{b_{zz}} + 4 I_{m_{zz}} \\\\     I_{xx} &amp;= 3,52 + 4 \\cdot 49,62 &amp; \\quad I_{yy} &amp;= 8,74 + 4 \\cdot 49,62 &amp; \\quad I_{zz} &amp;= 12,29 + 4 \\cdot 99,25 \\\\     I_{xx} &amp;= 202,02 \\, g.cm^2 &amp; \\quad I_{yy} &amp;= 207,24 \\, g.cm^2 &amp; \\quad I_{zz} &amp;= 408,29 \\, g.cm^2 \\\\ \\end{align*} \\] <p>Ou, de forma aproximada, e no S.I. (Sistema Internacional de Unidades):</p> \\[ \\begin{align*}     I_{xx} &amp;= 2 \\cdot 10^{-5} \\, kg.m^2 &amp; \\quad I_{yy} &amp;= 2 \\cdot 10^{-5} \\, kg.m^2 &amp; \\quad I_{zz} &amp;= 4 \\cdot 10^{-5} \\, kg.m^2 \\\\ \\end{align*} \\] <p>\u200b</p> <ol> <li> <p>Estamos desprezando a estrutura de PCB do drone, j\u00e1 que sua massa \u00e9 pequena comparada \u00e0 da bateria e dos motores, al\u00e9m de estar concentrada pr\u00f3xima ao centro de massa.\u00a0\u21a9</p> </li> </ol>"},{"location":"basic_concepts/mixer/","title":"Mixer","text":"<p>O voo de um drone depende diretamente das for\u00e7as e torques gerados pelos motores. Aqui, voc\u00ea vai entender como esses efeitos se combinam para movimentar o quadric\u00f3ptero no espa\u00e7o.</p>"},{"location":"basic_concepts/mixer/#movimentos-basicos-de-um-quadricoptero","title":"Movimentos b\u00e1sicos de um quadric\u00f3ptero","text":"<p>Um quadric\u00f3ptero possui 4 h\u00e9lices que, uma vez em movimento com velocidades angulares \\(\\omega_1\\), \\(\\omega_2\\), \\(\\omega_3\\) e \\(\\omega_4\\), produzem 4 for\u00e7as de sustenta\u00e7\u00e3o \\(f_1\\), \\(f_2\\), \\(f_3\\) e \\(f_4\\) e 4 torques de arrasto \\(\\tau_1\\), \\(\\tau_2\\), \\(\\tau_3\\) e \\(\\tau_4\\), conforme a figura abaixo.</p> <p></p> <p>Para um quadric\u00f3ptero se movimentar verticalmente, basta variar as velocidades angulares das 4 h\u00e9lices simultaneamente, conforme a figura abaixo.</p> <p>Enquanto que, para um quadric\u00f3ptero rotacionar em torno de seus eixos, basta variar as velocidades angulares de 2 h\u00e9lices simultaneamente, conforme a figura abaixo.</p> <p>Exerc\u00edcio 1</p> <p>Sobre os movimentos de um quadric\u00f3ptero, determine as respostas a seguir. </p> a) Quantas formas diferentes \u00e9 poss\u00edvel transladar um quadric\u00f3ptero <p>3 (ao longo dos eixos \\(x\\), \\(y\\) e \\(z\\))</p> b) Quantas formas diferentes \u00e9 poss\u00edvel rotacionar um quadric\u00f3ptero <p>3 (em torno dos eixos \\(x\\), \\(y\\) e \\(z\\)) </p> c) Quantos graus de liberdade possui um quadric\u00f3ptero <p>6 (3 de transla\u00e7\u00e3o + 3 de rota\u00e7\u00e3o) </p> d) Como o quadric\u00f3ptero realiza movimentos de transla\u00e7\u00e3o no plano (eixos \\(x\\) e \\(y\\)) <p>Atrav\u00e9s de uma composi\u00e7\u00e3o de movimentos de transla\u00e7\u00e3o (ao longo do eixo \\(z\\)) e rota\u00e7\u00e3o (em torno dos eixos \\(x\\) e \\(y\\)) </p>"},{"location":"basic_concepts/mixer/#transformacao-de-entradas","title":"Transforma\u00e7\u00e3o de entradas","text":"<p>As 4 for\u00e7as \\(f_i\\) e 4 torques \\(\\tau_i\\) das h\u00e9lices podem ser representadas por 1 \u00fanica for\u00e7a de propuls\u00e3o total \\(f_t\\) e 3 torques \\(\\tau_x\\), \\(\\tau_y\\) e \\(\\tau_z\\), um em torno de cada eixo do quadric\u00f3ptero, conforme a figura abaixo.</p> <p></p> <p>Na sec\u00e7\u00e3o de aerodin\u00e2mica verificamos que as for\u00e7as e torques das h\u00e9lices s\u00e3o proporcionais ao quadrado de suas velocidades angulares:</p> \\[ \\left\\{ \\begin{array}{l}     f_i = k_l \\omega_i^2 \\\\     \\tau_i = k_d \\omega_i^2 \\\\ \\end{array} \\right. \\] <p>Isso significa que as 4 equa\u00e7\u00f5es determinadas anteriormente podem ser escritas no formato matricial:</p> \\[ \\begin{bmatrix}     f_t \\\\     \\tau_x \\\\     \\tau_y \\\\     \\tau_z \\end{bmatrix} = M  \\begin{bmatrix}     \\omega_1^2 \\\\     \\omega_2^2 \\\\     \\omega_3^2 \\\\     \\omega_4^2 \\end{bmatrix} \\] <p>Onde \\(M\\) \u00e9 uma matriz \\(4\\times4\\) que transforma as velocidades angulares das h\u00e9lices na for\u00e7a total e nos torques de um quadric\u00f3ptero.</p> <p>Exerc\u00edcio 2</p> <p>Determine a matriz \\(M\\) em fun\u00e7\u00e3o das constantes de sustenta\u00e7\u00e3o e arrasto da h\u00e9lice \\(k_l\\) e \\(k_d\\) e do comprimento \\(l\\). </p> Resposta \\[ M =  \\begin{bmatrix}      k_l &amp; k_l &amp; k_l &amp; k_l \\\\      -k_l l &amp; -k_l l &amp; k_l l &amp; k_l l \\\\      -k_l l &amp; k_l l &amp; k_l l &amp; -k_l l  \\\\      -k_d &amp; k_d &amp; -k_d &amp; k_d  \\end{bmatrix} \\] <p>Para obter as velocidades angulares das h\u00e9lices em fun\u00e7\u00e3o da for\u00e7a total e dos torques, basta multiplicar a equa\u00e7\u00e3o anterior pela matriz inversa \\(M^{-1}\\):</p> \\[ \\begin{bmatrix}     \\omega_1^2 \\\\     \\omega_2^2 \\\\     \\omega_3^2 \\\\     \\omega_4^2 \\end{bmatrix} = M^{-1}  \\begin{bmatrix}     f_t \\\\     \\tau_x \\\\     \\tau_y \\\\     \\tau_z \\end{bmatrix} \\] <p>Exerc\u00edcio 3</p> <p>Determine a matriz inversa \\(M^{-1}\\) (dica: utilize o Symbolic Math Toolbox do MATLAB).</p> Resposta \\[ M^{-1} =  \\begin{bmatrix}      \\frac{1}{4 k_l} &amp; - \\frac{1}{4 k_l l} &amp; - \\frac{1}{4 k_l l} &amp; - \\frac{1}{4 k_d}  \\\\      \\frac{1}{4 k_l} &amp; - \\frac{1}{4 k_l l} &amp; \\frac{1}{4 k_l l} &amp; \\frac{1}{4 k_d} \\\\      \\frac{1}{4 k_l} &amp; \\frac{1}{4 k_l l} &amp; \\frac{1}{4 k_l l} &amp; - \\frac{1}{4 k_d} \\\\      \\frac{1}{4 k_l} &amp; \\frac{1}{4 k_l l} &amp; - \\frac{1}{4 k_l l} &amp; \\frac{1}{4 k_d}  \\end{bmatrix} \\]"},{"location":"control/architecture/","title":"Arquitetura","text":"<p>Para controlar um drone, precisamos de uma arquitetura bem definida. Essa arquitetura estabelece como as informa\u00e7\u00f5es dos sensores s\u00e3o processadas por estimadores, comparadas com as refer\u00eancias pelos controladores e, por fim, enviadas como comandos aos atuadores.</p> <p>O diagrama abaixo resume essa sequ\u00eancia em blocos:</p> <p></p> <p>No diagrama:</p> <ul> <li>Os blocos representam as fun\u00e7\u00f5es que ser\u00e3o chamadas no loop principal.</li> <li>As setas representam as vari\u00e1veis que fluem de um bloco a outro.</li> </ul> <p>A passagem dessas informa\u00e7\u00f5es entre as fun\u00e7\u00f5es ser\u00e1 feita por meio de vari\u00e1veis globais(1), que atuar\u00e3o como o \u201cfio\u201d que conecta os m\u00f3dulos do sistema.</p> <ol> <li>Embora vari\u00e1veis globais n\u00e3o sejam a melhor pr\u00e1tica em programa\u00e7\u00e3o, aqui adotamos essa solu\u00e7\u00e3o para manter o c\u00f3digo em C mais direto, evitando o excesso de ponteiros e sem\u00e1foros. Como o foco do curso est\u00e1 na teoria de controle \u2014 e n\u00e3o em engenharia de software \u2014 essa escolha facilita a compreens\u00e3o sem comprometer o aprendizado.</li> </ol>"},{"location":"control/architecture/#variaveis-globais","title":"Vari\u00e1veis globais","text":"<p>Logo no in\u00edcio do c\u00f3digo, declararemos as vari\u00e1veis que representam os atuadores, sensores, entradas, estados e refer\u00eancias \u2014 espelhando o diagrama.</p> <pre><code>// Actuators\nfloat pwm1, pwm2, pwm3, pwm4; // Motors PWM\n\n// Sensors\nfloat ax, ay, az;             // Accelerometer [m/s^2]\nfloat gx, gy, gz;             // Gyroscope [rad/s]\nfloat d;                      // Range [m]\nfloat px, py;                 // Optical flow [pixels]\n\n// System inputs\nfloat ft;                     // Thrust force [N]\nfloat tx, ty, tz;             // Roll, pitch and yaw torques [N.m]\n\n// System states\nfloat phi, theta, psi;        // Euler angles [rad]\nfloat wx, wy, wz;             // Angular velocities [rad/s]\nfloat x, y, z;                // Positions [m]\nfloat vx, vy, vz;             // Velocities [m/s]\n\n// System references\nfloat phi_r, theta_r, psi_r; // Euler angles reference [rad]\nfloat x_r, y_r, z_r;         // Positions reference [m]\n</code></pre>"},{"location":"control/architecture/#loop-principal","title":"Loop principal","text":"<p>Toda a l\u00f3gica de controle ser\u00e1 implementada dentro de um loop que roda a 200 Hz (ou seja, a cada 5 ms). Dentro desse loop, chamamos as fun\u00e7\u00f5es na sequ\u00eancia do diagrama: refer\u00eancias \u2192 sensores \u2192 estimadores \u2192 controladores \u2192 atuadores.</p> <pre><code>// Main application task\nvoid appMain(void *param)\n{\n    // Infinite loop (runs at 200Hz)\n    while (true)\n    {\n        reference();                  // Read reference setpoints (from Crazyflie Client)\n        sensors();                    // Read raw sensor measurements\n        attitudeEstimator();          // Estimate orientation (roll/pitch/yaw) from IMU sensor\n        verticalEstimator();          // Estimate vertical position/velocity from range sensor\n        horizontalEstimator();        // Estimate horizontal positions/velocities from optical flow sensor\n        horizontalController();       // Compute desired roll/pitch angles\n        verticalController();         // Compute desired thrust force\n        attitudeController();         // Compute desired roll/pitch/yaw torques\n        mixer();                      // Convert desired force/torques into motor PWM\n        motors();                     // Send commands to motors\n        vTaskDelay(pdMS_TO_TICKS(5)); // Loop delay (5 ms)\n    }\n}\n</code></pre>"},{"location":"control/architecture/#implementacao","title":"Implementa\u00e7\u00e3o","text":"<p>A implementa\u00e7\u00e3o ser\u00e1 feita passo a passo, uma fun\u00e7\u00e3o por vez. Dessa forma, voc\u00ea poder\u00e1 entender o papel de cada bloco isoladamente antes de ver o sistema completo em a\u00e7\u00e3o.</p> <p></p> <p>Nos pr\u00f3ximos cap\u00edtulos, come\u00e7aremos pelo mixer e, em seguida, avan\u00e7aremos para os blocos de estimadores e controladores. Cada subsistema ser\u00e1 estudado em pares \u2014 estimador e controlador de atitude, vertical (altura) e horizontal (posi\u00e7\u00e3o no plano). Ao final, voc\u00ea ter\u00e1 constru\u00eddo, passo a passo, a arquitetura de controle completa de um drone.</p>"},{"location":"control/attitude_controller/","title":"Controlador de atitude","text":"<p>Nesta sec\u00e7\u00e3o voc\u00ea ir\u00e1 implementar o controlador de atitude, que comanda os torques \\(\\tau_x\\), \\(\\tau_y\\) e \\(\\tau_z\\) a partir da diferen\u00e7a entre os \u00e2ngulos de Euler de refer\u00eancia \\(\\phi_r\\), \\(\\theta_r\\) e \\(\\psi_r\\) e estimados \\(\\phi\\), \\(\\theta\\) e \\(\\psi\\).</p> <p></p> <p>Para isto, ser\u00e1 implementada uma nova fun\u00e7\u00e3o:</p> <ul> <li><code>attitudeController()</code></li> </ul> <p>Al\u00e9m de uma altera\u00e7\u00e3o em uma fun\u00e7\u00e3o j\u00e1 previamente implementada:</p> <ul> <li><code>reference()</code></li> </ul>"},{"location":"control/attitude_estimator/","title":"Estimador de atitude","text":"<p>Nesta sec\u00e7\u00e3o voc\u00ea ir\u00e1 implementar o estimador de atitude, que estima os \u00e2ngulos de Euler \\(\\phi\\), \\(\\theta\\) e \\(\\psi\\) e velocidades angulares \\(\\omega_x\\), \\(\\omega_y\\) e \\(\\omega_z\\) a partir das leituras do aceler\u00f4metro \\(a_x\\), \\(a_y\\) e \\(a_z\\) e girosc\u00f3pio \\(g_x\\), \\(g_y\\) e \\(g_z\\).</p> <p></p> <p>Para isto, ser\u00e3o implementadas duas novas fun\u00e7\u00f5es:</p> <ul> <li><code>sensors()</code></li> <li><code>attitudeEstimator()</code></li> </ul>"},{"location":"control/horizontal_controller/","title":"Controlador horizontal","text":""},{"location":"control/horizontal_estimator/","title":"Estimador horizontal","text":""},{"location":"control/mixer/","title":"Mixer","text":"<p>Nesta sec\u00e7\u00e3o voc\u00ea ir\u00e1 implementar o mixer, que converte as for\u00e7as e torques totais produzidos pelas h\u00e9lices \\(f_t\\), \\(\\tau_x\\), \\(\\tau_y\\) e \\(\\tau_z\\) nos sinais PWM correspondentes dos motores.</p> <p></p> <p>Para isto, ser\u00e3o implementadas tr\u00eas fun\u00e7\u00f5es:</p> <ul> <li><code>reference()</code></li> <li><code>mixer()</code></li> <li><code>actuators()</code></li> </ul>"},{"location":"control/mixer/#implementacao","title":"Implementa\u00e7\u00e3o","text":"<p>Para come\u00e7ar, crie um arquivo chamado <code>mixer.c</code> dentro da pasta <code>src/control</code>.</p>"},{"location":"control/mixer/#bibliotecas-necessarias","title":"Bibliotecas necess\u00e1rias","text":"<p>Logo no in\u00edcio desse arquivo, importe todas(1) as bibliotecas que ser\u00e3o utilizadas:</p> <ol> <li>Algumas dessas bibliotecas n\u00e3o s\u00e3o estritamente necess\u00e1rias para o mixer, mas j\u00e1 as inclu\u00edmos agora para evitar preocupa\u00e7\u00f5es futuras ao integrar os pr\u00f3ximos m\u00f3dulos.</li> </ol> <pre><code>#include \"math.h\"       // Math functions (e.g., sqrtf, roundf, powf)\n#include \"FreeRTOS.h\"   // FreeRTOS core definitions (needed for task handling and timing)\n#include \"task.h\"       // FreeRTOS task functions (e.g., vTaskDelay)\n#include \"supervisor.h\" // Functions to check flight status (e.g., supervisorIsArmed)\n#include \"commander.h\"  // Access to commanded setpoints (e.g., commanderGetSetpoint)\n#include \"estimator.h\"  // Estimation framework for sensor fusion\n#include \"motors.h\"     // Low-level motor control interface (e.g., motorsSetRatio)\n#include \"debug.h\"      // Debug printing functions (e.g., DEBUG_PRINT)\n#include \"log.h\"        // Logging utilities to send data to the CFClient\n</code></pre>"},{"location":"control/mixer/#parametros-e-constantes","title":"Par\u00e2metros e constantes","text":"<p>Na sequ\u00eancia, declare(1) algumas constantes f\u00edsicas e par\u00e2metros do quadricoptero que ser\u00e3o bastante utilizados:</p> <ol> <li>Usamos <code>const</code> para garantir que o valor n\u00e3o muda em tempo de execu\u00e7\u00e3o. J\u00e1 o <code>static</code> limita a visibilidade da vari\u00e1vel ao arquivo atual, evitando conflitos de nomes em outros arquivos. Assim, <code>static const</code> cria constantes imut\u00e1veis e restritas ao arquivo.</li> </ol> <pre><code>// Physical constants\nstatic const float pi = 3.1416f; // Mathematical constant\nstatic const float g = 9.81f;    // Gravitational acceleration [m/s^2]\nstatic const float dt = 0.005f;  // Loop time step [s] (5 ms -&gt; 200 Hz)\n\n// Quadcopter parameters\nstatic const float l = 35.0e-3f;   // Distance from motor to quadcopter center of mass [m]\nstatic const float m = 38.6e-3f;   // Mass [kg]\nstatic const float Ixx = 20.0e-6f; // Moment of inertia around x-axis [kg.m^2]\nstatic const float Iyy = 20.0e-6f; // Moment of inertia around y-axis [kg.m^2]\nstatic const float Izz = 40.0e-6f; // Moment of inertia around z-axis [kg.m^2]\n</code></pre>"},{"location":"control/mixer/#variaveis-globais","title":"Vari\u00e1veis globais","text":"<p>Em seguida, declare as vari\u00e1veis globais que ser\u00e3o utilizadas pelas fun\u00e7\u00f5es.</p> <pre><code>// Actuators\nfloat pwm1, pwm2, pwm3, pwm4; // Motors PWM\n\n// System inputs\nfloat ft;                     // Thrust force [N]\nfloat tx, ty, tz;             // Roll, pitch and yaw torques [N.m]\n</code></pre>"},{"location":"control/mixer/#referencia","title":"Refer\u00eancia","text":"<p>Inicialmente, as for\u00e7as e torques ser\u00e3o comandados pelo Command Based Flight Control do Crazyflie Client.</p> <p></p> <ul> <li>Os bot\u00f5es <code>\u2191</code> e <code>\u2193</code> alteram a vari\u00e1vel <code>setpoint.position.x</code> em incrementos de \\(0,5\\)</li> <li>Os bot\u00f5es <code>\u2190</code> e <code>\u2192</code> alteram a vari\u00e1vel <code>setpoint.position.y</code> em incrementos de \\(0,5\\)</li> <li>Os bot\u00f5es <code>Up</code> e <code>Down</code> alteram a vari\u00e1vel <code>setpoint.position.z</code> em incrementos de \\(0,5\\)</li> </ul> <p>Vamos utilizar essas vari\u00e1veis para comandar a for\u00e7a total \\(f_t\\) em incrementos de \\(0,01\\,N\\) e os torques de rolagem \\(\\tau_x\\) e inclina\u00e7\u00e3o \\(\\tau_y\\) em incrementos de \\(0,001\\,N.m\\). Portanto, precisamos ajustar as escalas da seguinte forma(1):</p> <ol> <li>O torque \\(\\tau_x\\) possui uma invers\u00e3o de sinal pois o eixo \\(y\\), que \u00e9 comandado pelos bot\u00f5es <code>\u2190</code> e <code>\u2192</code>, est\u00e1 no sentido contr\u00e1rio do torque.</li> </ol> <p></p> <p>Abaixo temos um exemplo de fun\u00e7\u00e3o <code>reference()</code> que faz isso(1):</p> <ol> <li>Multiplicamos por \\(2\\), arredondamos e depois dividmos por \\(100\\) (ou \\(1000\\)) para garantir um arredondamento com \\(2\\) (ou \\(3\\)) casas decimais.</li> </ol> <pre><code>// Get reference setpoints from commander module\nvoid reference()\n{\n    // Declare variables that store the most recent setpoint and state from commander\n    static setpoint_t setpoint;\n    static state_t state;\n\n    // Retrieve the current commanded setpoints and state from commander module\n    commanderGetSetpoint(&amp;setpoint, &amp;state);\n\n    // Extract position references from the received setpoint\n    ft =  roundf((setpoint.position.z) * 2.0f) / 100.0f;    // Thrust force command [N] (maps 0.5m -&gt; 0.01N)\n    tx = -roundf((setpoint.position.y) * 2.0f) / 1000.0f;   // Roll torque command [N.m] (maps 0.5m -&gt; 0.001N.m)\n    ty =  roundf((setpoint.position.x) * 2.0f) / 1000.0f;   // Pitch torque command [N.m] (maps 0.5m -&gt; 0.001N.m)\n    tz = 0.0f;                                              // Yaw torque command [N.m]\n}\n</code></pre>"},{"location":"control/mixer/#mixer_1","title":"Mixer","text":"<p>J\u00e1 deduzimos a matriz \\(M^{-1}\\) que converte as for\u00e7a e torques totais produzidos pelas h\u00e9lices \\(f_t\\), \\(\\tau_x\\), \\(\\tau_y\\) e \\(\\tau_z\\)  no quadrado das velocidades angulares dos motores \\(\\omega_1\\), \\(\\omega_2\\), \\(\\omega_3\\) e \\(\\omega_4\\) :</p> \\[ \\begin{bmatrix}     \\omega_1^2 \\\\     \\omega_2^2 \\\\     \\omega_3^2 \\\\     \\omega_4^2 \\end{bmatrix} =  \\underbrace{ \\begin{bmatrix}      \\frac{1}{4 k_l} &amp; - \\frac{1}{4 k_l l} &amp; - \\frac{1}{4 k_l l} &amp; - \\frac{1}{4 k_d}  \\\\      \\frac{1}{4 k_l} &amp; - \\frac{1}{4 k_l l} &amp; \\frac{1}{4 k_l l} &amp; \\frac{1}{4 k_d} \\\\      \\frac{1}{4 k_l} &amp; \\frac{1}{4 k_l l} &amp; \\frac{1}{4 k_l l} &amp; - \\frac{1}{4 k_d} \\\\      \\frac{1}{4 k_l} &amp; \\frac{1}{4 k_l l} &amp; - \\frac{1}{4 k_l l} &amp; \\frac{1}{4 k_d}  \\end{bmatrix} }_{M^{-1}} \\begin{bmatrix}     f_t \\\\     \\tau_x \\\\     \\tau_y \\\\     \\tau_z \\end{bmatrix} \\] <p>Al\u00e9m disso, tamb\u00e9m j\u00e1 determinanos os coeficientes dos motores \\(a_2\\) e \\(a_1\\) que convertem a velocidade angular \\(\\omega\\) do motor no sinal PWM correspondente:</p> \\[     PWM = a_2 \\omega^2 + a_1 \\omega \\] <p>Se unirmos essas duas fun\u00e7\u00f5es, temos a l\u00f3gica do mixer:</p> <p></p> <p>Voc\u00ea deve implementar essa l\u00f3gica na fun\u00e7\u00e3o <code>mixer()</code>(1): </p> <ol> <li>Declarare os par\u00e2metros do quadc\u00f3ptero previamente identificados como vari\u00e1veis locais.</li> </ol> <pre><code>// Compute motor commands\nvoid mixer()\n{\n    // Quadcopter parameters\n    static const float a2 = 0.0f; // Quadratic motor model gain [s^2/rad^2]\n    static const float a1 = 0.0f; // Linear motor model gain [s/rad]\n    static const float kl = 0.0f; // Lift constant [N.s^2]\n    static const float kd = 0.0f; // Drag constant [N.m.s^2]\n\n    // Compute required motor angular velocities squared (omega^2)\n    float omega1 = 0.0f;\n    float omega2 = 0.0f;\n    float omega3 = 0.0f;\n    float omega4 = 0.0f;\n\n    // Clamp to non-negative and take square root (omega)\n    omega1 = 0.0f;\n    omega2 = 0.0f;\n    omega3 = 0.0f;\n    omega4 = 0.0f;\n\n    // Compute motor PWM using motor model\n    pwm1 = 0.0f;\n    pwm2 = 0.0f;\n    pwm3 = 0.0f;\n    pwm4 = 0.0f;\n}\n</code></pre> <p>Aten\u00e7\u00e3o</p> <p>Cuidado ao tirar a raiz quadrada de n\u00fameros negativos! Voc\u00ea deve checar o sinal de \\(\\omega^2\\), e s\u00f3 tirar a raiz quadrada se ele for positivo.</p>"},{"location":"control/mixer/#atuadores","title":"Atuadores","text":"<p>A fun\u00e7\u00e3o <code>actuators()</code> apenas envia os valores dos sinais PWM calculados aos motores: </p> <p></p> <p>No entanto, ela faz isso apenas quando o drone \u00e9 armado pelo Crazyflie Client com o bot\u00e3o <code>Arm</code>, conforme exemplo abaixo:</p> <pre><code>// Apply motor commands\nvoid actuators()\n{\n    // Check is quadcopter is armed or disarmed\n    if (supervisorIsArmed())\n    {\n        // Apply calculated PWM values if is commanded to take-off\n        motorsSetRatio(MOTOR_M1, pwm1 * UINT16_MAX);\n        motorsSetRatio(MOTOR_M2, pwm2 * UINT16_MAX);\n        motorsSetRatio(MOTOR_M3, pwm3 * UINT16_MAX);\n        motorsSetRatio(MOTOR_M4, pwm4 * UINT16_MAX);\n    }\n    else\n    {\n        // Turn-off all motor if disarmed\n        motorsStop();\n    }\n}\n</code></pre>"},{"location":"control/mixer/#loop-principal","title":"Loop principal","text":"<p>Por fim, temos o loop principal que executa as tr\u00eas fun\u00e7\u00f5es definidas na sequ\u00eancia em uma frequ\u00eancia de 200 Hz.</p> <pre><code>// Main application task\nvoid appMain(void *param)\n{\n    // Infinite loop (runs at 200Hz)\n    while (true)\n    {\n        reference();                  // Read reference setpoints (from Crazyflie Client)\n        mixer();                      // Convert desired force/torques into motor PWM\n        motors();                     // Send commands to motors\n        vTaskDelay(pdMS_TO_TICKS(5)); // Loop delay (5 ms)\n    }\n}\n</code></pre>"},{"location":"control/mixer/#validacao","title":"Valida\u00e7\u00e3o","text":"<p>Para validar sua implementa\u00e7\u00e3o voc\u00ea deve realizar alguns teste simples, que consistem apenas em verificar se os motores corretos est\u00e3o aumentando ou diminuindo suas velocidades angulares.</p> <p></p> <p>Aten\u00e7\u00e3o</p> <p>Muitos alunos pulam um teste ou outro e s\u00f3 v\u00e3o descobrir o problema l\u00e1 na frente, ao passarem horas tentando entender por que o drone deles n\u00e3o voa. N\u00e3o seja essa pessoa.</p>"},{"location":"control/mixer/#forca-de-empuxo-f_t","title":"For\u00e7a de empuxo \\(f_t\\)","text":"<p>Arme o drone a altere o valor da for\u00e7a de empuxo \\(f_t\\) com os bot\u00f5es <code>Up</code> e <code>Down</code>. Verifique se todos os quatro motores aumentam e diminuem suas velocidades angulares conforme voc\u00ea faz isso.</p>"},{"location":"control/mixer/#torque-de-rolagem-tau_x","title":"Torque de rolagem \\(\\tau_x\\)","text":"<p>Arme o drone a altere o valor do torque de rolagem \\(\\tau_x\\) com os bot\u00f5es <code>\u2190</code> e <code>\u2192</code>. Verifique se apenas os motores 3 e 4 ligam com valores positivos e os motores 1 e 2 com valores negativos.</p>"},{"location":"control/mixer/#torque-de-inclinacao-tau_y","title":"Torque de inclina\u00e7\u00e3o \\(\\tau_y\\)","text":"<p>Arme o drone a altere o valor do torque de inclina\u00e7\u00e3o \\(\\tau_y\\) com os bot\u00f5es <code>\u2191</code> e <code>\u2193</code>. Verifique se apenas os motores 2 e 3 ligam com valores positivos e os motores 1 e 4 com valores negativos.</p>"},{"location":"control/mixer/#torque-de-guinagem-tau_z","title":"Torque de guinagem \\(\\tau_z\\)","text":"<p>Modifique a fun\u00e7\u00e3o de refer\u00eancia, para que os bot\u00f5es <code>\u2190</code> e <code>\u2192</code> alterem o valor do torque de guinagem \\(\\tau_z\\) em incrementos de \\(0,0001\\,N.m\\)(1):</p> <ol> <li>Note que \u00e9 uma casa decimal a mais.</li> </ol> <p></p> <p>Arme o drone a altere o valor do torque de guinagem \\(\\tau_z\\) com os bot\u00f5es <code>\u2190</code> e <code>\u2192</code>. Verifique se apenas os motores 2 e 4 ligam com valores positivos e os motores 1 e 3 com valores negativos.</p>"},{"location":"control/vertical_controller/","title":"Controlador vertical","text":""},{"location":"control/vertical_estimator/","title":"Estimador vertical","text":""},{"location":"first_steps/firmware/","title":"Firmware","text":"<p>Agora que seu ambiente est\u00e1 pronto, \u00e9 hora de colocar a m\u00e3o no c\u00f3digo do drone.</p> <p>Aqui, voc\u00ea vai aprender a baixar, configurar e compilar o firmware que roda dentro do Crazyflie \u2014 deixando tudo pronto para testar seu pr\u00f3prio c\u00f3digo no drone real.</p>"},{"location":"first_steps/firmware/#visual-studio-code","title":"Visual Studio Code","text":"<p>Vamos utilizar o Visual Studio Code como IDE (Ambiente de Desenvolvimento Integrado).</p> <ol> <li>Baixe o Visual Studio Code em seu site oficial e instale-o.</li> </ol>"},{"location":"first_steps/firmware/#clonando","title":"Clonando","text":"<p>Antes de come\u00e7ar a programar, precisamos trazer o c\u00f3digo do firmware para sua m\u00e1quina. Vamos fazer isso em duas etapas: primeiro, voc\u00ea cria uma c\u00f3pia (um fork) do reposit\u00f3rio, e depois clona essa c\u00f3pia para o seu computador.</p>"},{"location":"first_steps/firmware/#fork","title":"Fork","text":"<ol> <li>Crie um fork do reposit\u00f3rio que cont\u00e9m o firmware para a sua conta do GitHub.</li> </ol>"},{"location":"first_steps/firmware/#clone","title":"Clone","text":"<ol> <li> <p>Abra o Visual Studio Code</p> </li> <li> <p>Clique em <code>Clone Git Repository...</code></p> </li> <li> <p>Coloque o endere\u00e7o do reposit\u00f3rio forkado para sua conta do GitHub: <pre><code>https://github.com/username/quadcontrol-firmware.git\n</code></pre></p> <p>Aten\u00e7\u00e3o</p> <p>Voc\u00ea deve substituir <code>username</code> pelo seu nome de usu\u00e1rio do GitHub</p> </li> <li> <p>Pressione <code>Enter</code> e selecione o local onde voc\u00ea quer salvar esse reposit\u00f3rio.</p> </li> <li> <p>Quando ele terminar de clonar e perguntar se voc\u00ea gostaria de abrir o reposit\u00f3rio clonado, clique em <code>Open</code>.</p> </li> <li> <p>Abra uma janela do terminal clicando em <code>Terminal</code> &gt; <code>New Terminal</code> (ou usando o atalho <code>Crtl</code>+<code>Shift</code>+<code>'</code>).</p> <p>Aten\u00e7\u00e3o</p> <p>Caso esteja utilizando Windows, ele abre por padr\u00e3o um terminal do PowerShell, mas voc\u00ea deve alternar para um terminal do WSL (Ubuntu): </p> </li> <li> <p>Inicialize todos os subm\u00f3dulos<sup>1</sup> pelo terminal: <pre><code>git submodule update --init --recursive\n</code></pre></p> </li> </ol>"},{"location":"first_steps/firmware/#organizacao","title":"Organiza\u00e7\u00e3o","text":"<p>O firmware \u00e9 composto por 2 pastas e 2 arquivos:</p> <p></p> <p>Vamos entender cada um deles:</p> <ul> <li><code>crazyflie-firmware</code> - Pasta que cont\u00e9m o firmware do Crazyflie, o qual utilizaremos como subm\u00f3dulo</li> <li><code>src</code> - Pasta que cont\u00e9m os programas que vamos desenvolver ao longo do curso</li> <li><code>Kbuild</code> - Arquivo que define o programa que ser\u00e1 compilado</li> <li><code>radio.config</code> - Arquivo que define o canal de r\u00e1dio utilizado para se comunicar com o Crazyflie</li> </ul> <p>A pasta <code>src</code> possui uma subpasta <code>examples</code> com 2 exemplos de programas: <code>led_blink.c</code> e <code>hello_world.c</code>. Abra esses arquivos para ver alguns exemplos de programa bem simples:</p> Led blinkHello world led_blink.c<pre><code>#include \"FreeRTOS.h\"      // FreeRTOS core definitions (needed for task handling and timing)\n#include \"task.h\"          // FreeRTOS task functions (e.g., vTaskDelay)\n#include \"led.h\"           // LED functions (e.g., ledSet)\n\n// Main application loop\nvoid appMain(void *param)\n{\n    // Infinite loop (runs continuously while the quadcopter is powered on)\n    while (true)\n    {\n        // Turn on left green led\n        ledSet(LED_GREEN_L, true);\n        // Wait for 100 milliseconds (2 Hz loop)\n        vTaskDelay(pdMS_TO_TICKS(500));\n        // Turn off left green led\n        ledSet(LED_GREEN_L, false);\n        // Wait for 100 milliseconds (2 Hz loop)\n        vTaskDelay(pdMS_TO_TICKS(500));\n    }\n}\n</code></pre> hello_world.c<pre><code>#include \"FreeRTOS.h\"      // FreeRTOS core definitions (needed for task handling and timing)\n#include \"task.h\"          // FreeRTOS task functions (e.g., vTaskDelay)\n#include \"debug.h\"         // Debug printing functions (e.g., DEBUG_PRINT)\n\n// Main application loop\nvoid appMain(void *param)\n{\n    // Infinite loop (runs continuously while the quadcopter is powered on)\n    while (true)\n    {\n        // Print message to console\n        DEBUG_PRINT(\"Hello world!\\n\");\n        // Wait for 100 milliseconds (2 Hz loop)\n        vTaskDelay(pdMS_TO_TICKS(500));\n    }\n}\n</code></pre> <p>Definimos qual o programa que vamos compilar atrav\u00e9s do arquivo <code>Kbuild</code>:</p> Kbuild<pre><code>obj-y += src/examples/led_blink.o\n</code></pre> <p>Conforme formos desenvolvendo novos programas, n\u00e3o podemos esquecer de atualizar o arquivo <code>Kbuild</code> com o nome do programa que queremos compilar. </p> <p>Aten\u00e7\u00e3o</p> <p>Note que a extens\u00e3o do arquivo aqui \u00e9 <code>.o</code> e n\u00e3o <code>.c</code>. O importante \u00e9 o nome do programa estar igual.</p>"},{"location":"first_steps/firmware/#configurando","title":"Configurando","text":"<p>Agora que voc\u00ea j\u00e1 tem o c\u00f3digo na sua m\u00e1quina, vamos ajustar algumas configura\u00e7\u00f5es importantes: o canal de r\u00e1dio que ser\u00e1 usado para comunica\u00e7\u00e3o e a plataforma de hardware do drone. Esses ajustes garantem que tudo esteja alinhado com o seu Crazyflie antes de compilar o c\u00f3digo.</p>"},{"location":"first_steps/firmware/#radio","title":"Radio","text":"<ol> <li> <p>Abra o arquivo <code>radio.config</code></p> </li> <li> <p>Altere o canal do r\u00e1dio conforme a numera\u00e7\u00e3o do seu Crazyflie.  radio.config<pre><code>RADIO_CHANNEL=1\n</code></pre></p> </li> </ol>"},{"location":"first_steps/firmware/#submodulo","title":"Subm\u00f3dulo","text":"<ol> <li> <p>Navegue at\u00e9 a p\u00e1gina <code>crazyflie-firmware/src/modules/src</code> e abra o arquivo <code>stabilizer.c</code>.</p> </li> <li> <p>Comente as linhas 223-226, 326 e 356, conforme abaixo<sup>2</sup>: stabilizer.c<pre><code>static void setMotorRatios(const motors_thrust_pwm_t* motorPwm)\n{\n  // motorsSetRatio(MOTOR_M1, motorPwm-&gt;motors.m1);\n  // motorsSetRatio(MOTOR_M2, motorPwm-&gt;motors.m2);\n  // motorsSetRatio(MOTOR_M3, motorPwm-&gt;motors.m3);\n  // motorsSetRatio(MOTOR_M4, motorPwm-&gt;motors.m4);\n}\n</code></pre> stabilizer.c<pre><code>      //stateEstimator(&amp;state, stabilizerStep);\n</code></pre> stabilizer.c<pre><code>      } else {\n        // motorsStop();\n      }\n</code></pre></p> </li> </ol>"},{"location":"first_steps/firmware/#plataforma","title":"Plataforma","text":"<ol> <li>Configure o firmware para a plataforma do Crazyflie 2.1 Brushless rodando o seguinte c\u00f3digo no terminal: <pre><code>make cf21bl_defconfig\n</code></pre></li> </ol>"},{"location":"first_steps/firmware/#compilando","title":"Compilando","text":"<p>Com o c\u00f3digo ajustado, \u00e9 hora de transformar ele em algo que o drone entenda. Vamos compilar o firmware e envi\u00e1-lo para o Crazyflie. Esse processo ser\u00e1 repetido sempre que voc\u00ea quiser testar uma nova vers\u00e3o do seu programa.</p>"},{"location":"first_steps/firmware/#build","title":"Build","text":"<ol> <li>Compile o firmware: <pre><code>make\n</code></pre></li> </ol>"},{"location":"first_steps/firmware/#flash","title":"Flash","text":"<ol> <li> <p>Programe o firmware no Crazyflie: <pre><code>make cload\n</code></pre></p> <p>Aten\u00e7\u00e3o</p> <ul> <li>O Crazyflie 2.1 Brushless precisa estar ligado</li> <li>O Crazyradio PA precisa estar conectado na porta USB</li> </ul> </li> </ol>"},{"location":"first_steps/firmware/#testando","title":"Testando","text":"<p>Tudo pronto! Agora vamos conectar no drone com o Crazyflie Client e verificar se ele est\u00e1 rodando o seu c\u00f3digo corretamente. Se tudo estiver certo, voc\u00ea ver\u00e1 as mensagens aparecendo no console \u2014 e o seu drone estar\u00e1 oficialmente sob seu controle.</p> <ol> <li>Abra o Crazyflie Client <pre><code>cfclient\n</code></pre></li> <li> <p>Clique no bot\u00e3o <code>Scan</code> </p> </li> <li> <p>Selecione o Crazyflie correspondente</p> </li> <li> <p>Clique no bot\u00e3o <code>Connect</code></p> </li> <li> <p>Verifique se o quadricoptero est\u00e1 respondendo (tens\u00e3o da bateria, estado dos sensores, etc.)</p> </li> <li> <p>Clique em <code>View</code> &gt; <code>Toolboxes</code> &gt; <code>Console</code></p> </li> <li> <p>Verifique se aparecem as mensagens do seu c\u00f3digo (\"Hello world!\")</p> </li> </ol> <p>Caso n\u00e3o apare\u00e7a, muito provavelmente \u00e9 por que voc\u00ea est\u00e1 rodando o programa <code>led_blink.c</code> e n\u00e3o <code>hello_world.c</code>. Modifique seu arquivo <code>Kbuild</code> para o programa correto e, em seguida, compile e envie o programa para o quadricoptero.</p> <ol> <li> <p>Subm\u00f3dulos do Git s\u00e3o como \"reposit\u00f3rios dentro de reposit\u00f3rios\". Esse comando garante que voc\u00ea tenha o c\u00f3digo do firmware oficial (<code>crazyflie-firmware</code>) que est\u00e1 referenciado como subm\u00f3dulo.\u00a0\u21a9</p> </li> <li> <p>Fazemos isso para contornar o algoritmo propriet\u00e1rio do controlador do Crazyflie (ele vai continuar rodando em segundo plano, mas vamos ignorar seus comandos para podermos usar os nossos).\u00a0\u21a9</p> </li> </ol>"},{"location":"first_steps/hardware/","title":"Hardware","text":"<p>Neste curso, voc\u00ea vai programar um drone real e ver ele voar com os algoritmos que voc\u00ea mesmo desenvolveu. Mas, pra isso, voc\u00ea precisa de um conjunto espec\u00edfico de equipamentos \u2014 compactos, mas poderosos.</p> <p>Se voc\u00ea est\u00e1 matriculado na eletiva, tudo isso ser\u00e1 fornecido a voc\u00ea. Mas \u00e9 importante entender o que \u00e9 cada componente, por que eles s\u00e3o essenciais e como se conectam.</p>"},{"location":"first_steps/hardware/#crazyflie-21-brushless","title":"Crazyflie 2.1 Brushless","text":"<p>O Crazyflie 2.1 Brushless \u00e9 o cora\u00e7\u00e3o do sistema: um minidrone open-source com a estrutura baseada numa placa de circuito impresso (PCB). Compacto, robusto e com:</p> <ul> <li>Processador ARM (Cortex-M4 168 MHz)</li> <li>Motores BLDC (08028-10000KV)</li> <li>Controladores dos motores BLDC (5A ESCs)</li> <li>IMU embutida (BMI088)</li> </ul> <p>A vers\u00e3o brushless foi lan\u00e7ada recentemente (2025) e traz mais pot\u00eancia e durabilidade para os motores.</p>"},{"location":"first_steps/hardware/#crazyradio-20","title":"Crazyradio 2.0","text":"<p>O Crazyradio 2.0 \u00e9 um dongle que permite comunica\u00e7\u00e3o sem fio entre o seu computador e o drone. Com ele, voc\u00ea pode:</p> <ul> <li>Fazer upload de firmware</li> <li>Enviar comandos em tempo real</li> <li>Receber dados da telemetria</li> </ul> <p>Ele se conecta via USB e funciona com as ferramentas oficiais da Bitcraze.</p>"},{"location":"first_steps/hardware/#flow-deck-v2","title":"Flow deck v2","text":"<p>O Flow deck v2 \u00e9 um pequeno m\u00f3dulo que se encaixa embaixo do drone e adiciona dois sensores fundamentais para o voo aut\u00f4nomo:</p> <ul> <li>Proximidade (VL53L1x)</li> <li>Fluxo \u00f3ptico (PMW3901)</li> </ul> <p>Com eles, o drone consegue medir a altura em rela\u00e7\u00e3o ao ch\u00e3o e o deslocamente lateral com base no movimento do solo \u2014 o que \u00e9 essencial para estimar sua posi\u00e7\u00e3o no espa\u00e7o.</p>"},{"location":"first_steps/hardware/#resumo-do-kit","title":"Resumo do kit","text":"<p>Esses componentes tamb\u00e9m s\u00e3o oferecidos na forma de um kit pela Bitcraze, o STEM bundle - Crazyflie 2.1 Brushless. Voc\u00ea receber\u00e1 exatamente esse kit:</p> <ul> <li>Crazyflie 2.1 Brushless  </li> <li>Crazyradio 2.0  </li> <li>Flow Deck v2  </li> </ul> <p>Al\u00e9m de cabos e acess\u00f3rios, com tudo pronto para transformar c\u00f3digo em voo real. \ud83d\ude80</p>"},{"location":"first_steps/software/","title":"Software","text":"<p>Antes de come\u00e7ar a programar o drone, vamos instalar os programas e componentes que o ambiente de desenvolvimento precisa para funcionar direitinho.</p> <p>Siga cada passo com aten\u00e7\u00e3o, conforme seu sistema operacional, para garantir que tudo fique pronto e funcionando sem problemas.</p>"},{"location":"first_steps/software/#git","title":"Git","text":"WindowsMac <ol> <li> <p>Baixe o Git em seu site oficial e instale-o.</p> </li> <li> <p>Verifique a instala\u00e7\u00e3o do Git pelo PowerShell: <pre><code>git --version\n</code></pre></p> </li> </ol> <p>O Mac j\u00e1 vem de f\u00e1brica com o Git instalado.</p>"},{"location":"first_steps/software/#python","title":"Python","text":"WindowsMac <p>Aten\u00e7\u00e3o</p> <p>N\u00e3o pule essa etapa mesmo que voc\u00ea j\u00e1 tenha uma distribui\u00e7\u00e3o do Python instalada em seu computador, pois precisar\u00e1 instalar uma distribui\u00e7\u00e3o espec\u00edfica (3.11.9) para tudo funcionar. Mas fique tranquilo, qualquer distribui\u00e7\u00e3o j\u00e1 instalada continuar\u00e1 funcionando normalmente.</p> <ol> <li> <p>Baixe o Python 3.11.9 em seu site oficial e instale-o.</p> </li> <li> <p>Certifique-se de marcar a caixa <code>[\u2713] Add python.exe to PATH</code> durante a instala\u00e7\u00e3o.</p> </li> <li> <p>Verifique a instala\u00e7\u00e3o do Python e do PIP (Gerenciador de Pacotes Python) pelo PowerShell: <pre><code>python --version\npip --version\n</code></pre></p> </li> </ol> <p>O Mac j\u00e1 vem de f\u00e1brica com o Python instalado.</p>"},{"location":"first_steps/software/#crazyflie-client","title":"Crazyflie Client","text":"WindowsMac <ol> <li> <p>Instale o Crazyflie Client usando o PIP pelo PowerShell: <pre><code>pip install cfclient\n</code></pre></p> </li> <li> <p>Verifique a instala\u00e7\u00e3o do Crazyflie Client abrindo ele pelo PowerShell: <pre><code>cfclient\n</code></pre></p> </li> </ol> <p>Dica</p> <p>Caso prefira criar um \u00edcone na \u00e1rea de trabalho para o Crazyflie Client, siga o passo a passo abaixo:</p> <ol> <li> <p>Clique com o bot\u00e3o direito na \u00e1rea de trabalho e depois em <code>Novo</code> &gt; <code>Atalho</code></p> </li> <li> <p>No campo de destino, coloque \"cfclient\" e clique em <code>Avan\u00e7ar</code></p> </li> <li> <p>No campo de nome, coloque \"Crazyflie Client\" e clique em <code>Concluir</code></p> </li> </ol> <ol> <li> <p>Instale o Crazyflie Client pelo Terminal: <pre><code>python3 -m pip install cfclient\n</code></pre></p> </li> <li> <p>Verifique a instala\u00e7\u00e3o do Crazyflie Client abrindo ele pelo Terminal: <pre><code>cfclient\n</code></pre></p> </li> </ol> <p>Aten\u00e7\u00e3o</p> <p>Caso o comando acima n\u00e3o abra o Crazyflie Client, pode ser que seu endere\u00e7o n\u00e3o esteja no PATH. Para verificar onde ele foi instalado e colocar ele no PATH, basta rodar o comando abaixo no Terminal<sup>1</sup>: <pre><code>cfclient_path=$(dirname $(which cfclient)) &amp;&amp; echo \"export PATH=\\\"$cfclient_path:\\$PATH\\\"\" &gt;&gt; ~/.zshrc\n</code></pre></p> <p>Dica</p> <p>Caso prefira criar um \u00edcone na mesa para o Crazyflie Client, siga o passo a passo abaixo:</p> <ol> <li> <p>Abra o Automator</p> </li> <li> <p>Clique em <code>Novo Documento</code> &gt; <code>Aplicativo</code></p> </li> <li> <p>Na biblioteca de a\u00e7\u00f5es, d\u00ea duplo clique em <code>Executar Script de Shell</code></p> </li> <li> <p>No campo de script, cole: <pre><code>python3 -m cfclient.gui\n</code></pre></p> </li> <li> <p>Clique em <code>Arquivo</code> &gt; <code>Salvar</code></p> </li> <li> <p>No campo de nome, coloque \"Crazyflie Client\" e clique em <code>Concluir</code></p> </li> </ol>"},{"location":"first_steps/software/#arm-toolchain","title":"ARM Toolchain","text":"WindowsMac <ol> <li> <p>Instale o WSL (Subsistema do Windows para Linux) pelo PowerShell executando ele como administrador: <pre><code>wsl --install\n</code></pre></p> </li> <li> <p>Ap\u00f3s a instala\u00e7\u00e3o, reinicie o computador.</p> </li> <li> <p>Depois que o computador tiver reiniciado, ele abrir\u00e1 automaticamente o terminal WSL (Ubuntu). Caso ele n\u00e3o abra, voc\u00ea pode abri-lo pelo PowerShell: <pre><code>wsl\n</code></pre></p> </li> <li> <p>Na primeira vez, ser\u00e1 solicitado que voc\u00ea crie um nome de usu\u00e1rio para o Linux e defina uma senha (n\u00e3o necessariamente a mesma do Windows). </p> <p>Aten\u00e7\u00e3o</p> <p>Os comandos a seguir devem ser executados no terminal WSL (Ubuntu) e n\u00e3o no PowerShell</p> </li> <li> <p>Atualize a lista de pacotes: <pre><code>sudo apt update\n</code></pre></p> </li> <li> <p>Instale o Make: <pre><code>sudo apt install make \n</code></pre></p> </li> <li> <p>Verifique a instala\u00e7\u00e3o do Make: <pre><code>make --version\n</code></pre></p> </li> <li> <p>Instale o toolchain ARM embarcado: <pre><code>sudo apt install gcc-arm-none-eabi\n</code></pre></p> </li> <li> <p>Verifique a instala\u00e7\u00e3o do toolchain ARM embarcado: <pre><code>arm-none-eabi-gcc --version\n</code></pre></p> </li> <li> <p>Instale o toolchain GCC: <pre><code>sudo apt install gcc\n</code></pre></p> </li> <li> <p>Verifique a instala\u00e7\u00e3o do toolchain GCC: <pre><code>gcc --version\n</code></pre></p> </li> </ol> <ol> <li> <p>Instale o Homebrew: <pre><code>/bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\"\n</code></pre></p> </li> <li> <p>Verifique a instala\u00e7\u00e3o do Homebrew: <pre><code>brew --version\n</code></pre></p> </li> <li> <p>Instale o toolchain ARM embarcado: <pre><code>brew install gcc-arm-embedded\n</code></pre></p> </li> <li> <p>Adicione-o ao PATH<sup>1</sup>: <pre><code>echo 'export PATH=\"/opt/homebrew/bin:$PATH\"' &gt;&gt; ~/.zshrc\n</code></pre></p> </li> <li> <p>Verifique a instala\u00e7\u00e3o do toolchain ARM embarcado: <pre><code>arm-none-eabi-gcc --version\n</code></pre></p> </li> <li> <p>Instale os utilit\u00e1rios do GNU Core: <pre><code>brew install coreutils\n</code></pre></p> </li> <li> <p>Adicione-o ao PATH<sup>1</sup>: <pre><code>echo 'export PATH=\"/opt/homebrew/opt/coreutils/libexec/gnubin:$PATH\"' &gt;&gt; ~/.zshrc\n</code></pre></p> </li> <li> <p>Verifique a instala\u00e7\u00e3o do GNU Core: <pre><code>gdate --version\n</code></pre></p> </li> </ol> <ol> <li> <p>Reinicie o Terminal depois para a altera\u00e7\u00e3o fazer efeito.\u00a0\u21a9\u21a9\u21a9</p> </li> </ol>"},{"location":"identification/drag_constant/","title":"Identifica\u00e7\u00e3o da constante de arrasto","text":"<p>Nesta sec\u00e7\u00e3o, voc\u00ea ir\u00e1 determinar experimentalmente a constante de arrasto das h\u00e9lices \\(k_d\\).</p>"},{"location":"identification/drag_constant/#fundamentos-teoricos","title":"Fundamentos te\u00f3ricos","text":"<p>As h\u00e9lices de um quadricoptero atuam como superf\u00edcies aerodin\u00e2micas, acelerando o fluxo de ar atrav\u00e9s delas. Isso consome energia das baterias e produz for\u00e7as de sustenta\u00e7\u00e3o e torques de arrasto no quadricoptero. J\u00e1 deduzimos que o torque de arrasto de uma h\u00e9lice \\(\\tau\\) \u00e9 proporcional \u00e0 velocidade angular da h\u00e9lice \\(\\omega\\) ao quadrado.</p> <p></p> \\[     \\tau = k_d \\omega^2 \\] <p>Onde:</p> <ul> <li>\\(k_d\\) - Constante de arrasto (\\(N.m.s^2\\))   </li> </ul>"},{"location":"identification/drag_constant/#procedimento-experimental","title":"Procedimento experimental","text":"<p>Voc\u00ea vai medir o torque de arrasto \\(\\tau\\) das h\u00e9lices com um suporte(1) que restringe todos os graus de liberdade do drone deixando apenas o \u00e2ngulo de guinagem \\(\\psi\\) livre.</p> <ol> <li>Para prender o quadcoptero no suporte, voc\u00ea precisa encaix\u00e1-lo pela lateral e depois prender dois parafusos. </li> </ol> <p></p> <p>Sabendo o momento de in\u00e9rcia do drone \\(I_{zz}\\) e o \u00e2ngulo de guinagem ao longo do tempo \\(\\psi\\), \u00e9 poss\u00edvel determinar o torque de arrasto total das h\u00e9lices \\(\\tau_z\\) atrav\u00e9s de uma an\u00e1lise din\u00e2mica. Para realizar a leitura do \u00e2ngulo de guinagem ao longo do tempo, voc\u00ea deve filmar o procedimento no modo c\u00e2mera lenta de seu celular com um cron\u00f4metro no campo de vis\u00e3o.</p> <p></p> <p>Voc\u00ea deve carregar no drone um programa que faz com que as h\u00e9lices \\(1\\) e \\(3\\) rotacionem com velocidade angular de \\(1.000\\,\\text{rad/s}\\) e as h\u00e9lices \\(2\\) e \\(4\\) com \\(2.000\\,\\text{rad/s}\\). Como as h\u00e9lices \\(1\\) e \\(3\\) giram no sentido hor\u00e1rio e as h\u00e9lices \\(2\\) e \\(4\\) no anti-hor\u00e1rio, haver\u00e1 um torque resultante que far\u00e1 com que o drone rotacione no sentido anti-hor\u00e1rio. Para cada quarto de volta (\\(90^{\\circ}\\)), voc\u00ea dever\u00e1 anotar o tempo decorrido. Voc\u00ea dever\u00e1 realizar o experimento tr\u00eas vezes e tirar uma m\u00e9dia. Para facilitar o experimento, voc\u00ea pode ligar/desligar as h\u00e9lices com os bot\u00f5es <code>Take off</code> e <code>Land</code> do Command Based Flight Control atrav\u00e9s do CFClient.</p> <p></p> <p>Crie um arquivo chamado <code>drag_constant.c</code> dentro da pasta <code>src/identification</code> com o seguinte c\u00f3digo(1):</p> <ol> <li>N\u00e3o esque\u00e7a de atualizar os valores dos coeficientes dos motores \\(a_2\\) e \\(a_1\\) (linhas 8-9) estimados anteriormente.</li> </ol> drag_constant.c<pre><code>#include \"FreeRTOS.h\"      // FreeRTOS core definitions (needed for task handling and timing)\n#include \"task.h\"          // FreeRTOS task functions (e.g., vTaskDelay)\n#include \"supervisor.h\"    // Functions to check flight status (e.g., supervisorIsArmed)\n#include \"commander.h\"     // Access to commanded setpoints (e.g., commanderGetSetpoint)\n#include \"motors.h\"        // Low-level motor control interface (e.g., motorsSetRatio)\n\n// Motor coefficients of the quadratic model: PWM = a_2 * omega^2 + a_1 * omega\nconst float a_2 = 0.0f;\nconst float a_1 = 0.0f;\n\n// Global variables to store the desired setpoint, the current state (not used here),\n// and the computed PWM values for different motor speeds\nsetpoint_t setpoint;\nstate_t state;\nfloat pwm_1, pwm_2;\nfloat omega_1, omega_2; \n\n// Main application\nvoid appMain(void *param)\n{\n    // Infinite loop (runs forever)\n    while (true)\n    {\n        // Check if the drone is armed (i.e., ready to fly)\n        if (supervisorIsArmed())\n        {\n            // Fetch the latest setpoint from the commander\n            commanderGetSetpoint(&amp;setpoint, &amp;state);\n\n            if ((setpoint.position.z) &gt; 0)\n            {\n                // Set two different angular velocities for the motors\n                // Motors M1 and M3 will spin at 2000 rad/s\n                // Motors M2 and M4 will spin at 1000 rad/s\n                // This configuration induces pure yaw rotation (spinning in place)\n                omega_1 = 2000.0f;\n                omega_2 = 1000.0f;\n\n                // Convert angular velocities to PWM using the motor model\n                pwm_1 = a_2 * omega_1 * omega_1 + a_1 * omega_1;\n                pwm_2 = a_2 * omega_2 * omega_2 + a_1 * omega_2;\n            }\n            else\n            {\n                // If Z setpoint is not positive, apply minimal power to all motors (for idle spin)\n                pwm_1 = 0.1f;\n                pwm_2 = 0.1f;\n            }\n        }\n        else\n        {\n            // If not armed, stop all motors\n            pwm_1 = 0.0f;\n            pwm_2 = 0.0f;\n        }\n        // Apply PWM to motors:\n        // M1 and M3 get pwm_1 (corresponding to 2000 rad/s)\n        // M2 and M4 get pwm_2 (corresponding to 1000 rad/s)\n        // This asymmetric configuration results in yaw motion\n        motorsSetRatio(MOTOR_M1, pwm_1 * UINT16_MAX);\n        motorsSetRatio(MOTOR_M2, pwm_2 * UINT16_MAX);\n        motorsSetRatio(MOTOR_M3, pwm_1 * UINT16_MAX);\n        motorsSetRatio(MOTOR_M4, pwm_2 * UINT16_MAX);\n        // Wait for 100 milliseconds before the next iteration (10 Hz control loop)\n        vTaskDelay(pdMS_TO_TICKS(100));\n    }\n}\n</code></pre> <p>As etapas para coletar os dados s\u00e3o as seguintes:</p> <ol> <li>Garanta que a bateria do drone est\u00e1 carregada </li> <li>Prenda o drone no dispositivo e posicione um cron\u00f4metro ao seu lado</li> <li>Arme o drone apertando o bot\u00e3o <code>Arm</code> no CFClient</li> <li>Comece a filmar com seu celular no modo c\u00e2mera lenta</li> <li>Ligue os motores com o Command Based Flight Control do CFClient</li> <li>Espere o drone dar duas voltas e pare de filmar</li> </ol> <p>Ap\u00f3s o experimento, voc\u00ea dever\u00e1 coletar dados para preencher a tabela abaixo.</p> \\(\\psi \\, (^{\\circ})\\) \\(t_1 \\, (s)\\) \\(t_2 \\, (s)\\) \\(t_3 \\, (s)\\) \\(0\\) \\(90\\) \\(180\\) \\(270\\) \\(360\\) \\(450\\) \\(540\\) \\(630\\) \\(720\\)"},{"location":"identification/drag_constant/#analise-de-dados","title":"An\u00e1lise de dados","text":"<p>Utilizando os dados coletados, voc\u00ea dever\u00e1 ajustar uma curva que correlacione o \u00e2ngulo de guinagem \\(\\psi\\) com o tempo \\(t\\) da h\u00e9lice (note que voc\u00ea precisa converter o \u00e2ngulo de guinagem de \\(^{\\circ}\\) para \\(rad\\)).</p> <p></p> <p>Aplicando um torque constante, o deslocamento angular em fun\u00e7\u00e3o do tempo \u00e9 dado por:</p> <p>$$     \\psi = \\frac{\\tau_z}{2 I_{zz}} t^2 $$ J\u00e1 deduzimos que esse torque \u00e9 dado pela soma dos torques de arrasto de cada h\u00e9lice \\(\\tau_i\\), que por sua vez s\u00e3o proporcionais \u00e0s velocidades angulares das h\u00e9lices \\(\\omega_i\\) ao quadrado:</p> \\[     \\tau_z = -k_d \\omega_1^2 + k_d \\omega_2^2 - k_d \\omega_3^2 + k_d \\omega_4^2 \\] <p>Como \\(\\omega_1 = \\omega_3 = 1.000 \\, rad/s\\), \\(\\omega_2 = \\omega_4 = 2.000 \\, rad/s\\) e \\(I_{zz} = 4 \\cdot 10^{-5} \\, kg.m^2\\). substituindo na equa\u00e7\u00e3o anterior:</p> \\[ \\begin{align*}     \\psi &amp;= \\frac{\\tau_z}{2I_{zz}} t^2 \\\\     \\psi &amp;= \\frac{\\left(-k_d \\omega_1^2 + k_d \\omega_2^2 - k_d \\omega_3^2 + k_d \\omega_4^2\\right)}{2I_{zz}} t^2 \\\\     \\psi &amp;= \\frac{\\left(-\\omega_1^2 + \\omega_2^2 - \\omega_3^2 + \\omega_4^2\\right)k_d}{2I_{zz}} t^2 \\\\     \\psi &amp;= \\frac{- \\cancel{2}\\omega_1^2 + \\cancel{2} \\omega_2^2}{\\cancel{2}I_{zz}} k_d t^2 \\\\     \\psi &amp;= \\frac{- 1000^2 + 2000^2}{4 \\cdot 10^{-5}} k_d t^2 \\\\     \\psi &amp;= \\left( 75 \\times 10^{9} \\right) k_d t^2 \\\\ \\end{align*} \\] <p>Ou seja, o tipo de fun\u00e7\u00e3o mais adequado para realizar esse ajuste de curva \u00e9 uma fun\u00e7\u00e3o polinomial de 2\u00ba grau cujos coeficientes de ordem zero e um s\u00e3o nulos.</p> <p>Determine o valor de \\(k_d\\) fazendo esse ajuste de curva (dica: utilize o Curve Fitting Toolbox do MATLAB). Anote o valor obtido em algum lugar pois ele ser\u00e1 utilizado em breve.</p>"},{"location":"identification/drag_constant/#validacao-dos-resultados","title":"Valida\u00e7\u00e3o dos resultados","text":"<p>Compare o resultado obtido com o estimado anteriormente. \u00c9 esperado que a constante de sustenta\u00e7\u00e3o \\(k_d\\) seja da ordem de grandeza de \\(10^{-10}N.s^2\\). </p>"},{"location":"identification/lift_constant/","title":"Identifica\u00e7\u00e3o da constante de sustenta\u00e7\u00e3o","text":"<p>Nesta sec\u00e7\u00e3o, voc\u00ea ir\u00e1 determinar experimentalmente a constante de sustenta\u00e7\u00e3o das h\u00e9lices \\(k_l\\).</p>"},{"location":"identification/lift_constant/#fundamentos-teoricos","title":"Fundamentos te\u00f3ricos","text":"<p>As h\u00e9lices de um quadricoptero atuam como superf\u00edcies aerodin\u00e2micas, acelerando o fluxo de ar atrav\u00e9s delas. Isso consome energia das baterias e produz for\u00e7as de sustenta\u00e7\u00e3o e torques de arrasto no quadricoptero. J\u00e1 deduzimos que a for\u00e7a de sustenta\u00e7\u00e3o de uma h\u00e9lice \\(f\\) \u00e9 proporcional \u00e0 velocidade angular da h\u00e9lice \\(\\omega\\) ao quadrado.</p> <p></p> \\[     \\tau = k_l \\omega^2 \\] <p>Onde:</p> <ul> <li>\\(k_l\\) - Constante de sustenta\u00e7\u00e3o (\\(N.s^2\\))   </li> </ul>"},{"location":"identification/lift_constant/#procedimento-experimental","title":"Procedimento experimental","text":"<p>Voc\u00ea vai medir a for\u00e7a de de sustenta\u00e7\u00e3o \\(f\\) das h\u00e9lices com um suporte(1) que fixa o drone em uma balan\u00e7a atrav\u00e9s de um im\u00e3. </p> <ol> <li>Para prender o quadcoptero no suporte, voc\u00ea precisa encaix\u00e1-lo pela lateral e depois prender dois parafusos. </li> </ol> <p></p> <p>Sabendo a leitura da balan\u00e7a, \u00e9 poss\u00edvel determinar a for\u00e7a de sustenta\u00e7\u00e3o das h\u00e9lices. Voc\u00ea pode zerar a balan\u00e7a com o quadcoptero apertando o bot\u00e3o <code>TARE</code>, assim, qualquer for\u00e7a de sustenta\u00e7\u00e3o que as h\u00e9lices produzirem vai gerar uma leitura negativa na balan\u00e7a.</p> <p></p> <p>Voc\u00ea deve carregar no drone um programa que ligue os quatro motores com um determinado valor de velocidade angular. Ser\u00e3o levantados dados de peso na balan\u00e7a para 10 valores distintos, e, para cada valor de, voc\u00ea dever\u00e1 realizar o experimento tr\u00eas vezes e tirar uma m\u00e9dia. Para facilitar o experimento, voc\u00ea pode controlar o valor da velocidade angular com os bot\u00f5es <code>Up</code> e <code>Down</code> do Command Based Flight Control atrav\u00e9s do CFClient.</p> <p></p> <p>Crie um arquivo chamado <code>lift_constant.c</code> dentro da pasta <code>src/identification</code> com o seguinte c\u00f3digo(1):</p> <ol> <li>N\u00e3o esque\u00e7a de atualizar os valores dos coeficientes dos motores \\(a_2\\) e \\(a_1\\) (linhas 8-9) estimados anteriormente.</li> </ol> lift_constant.c<pre><code>#include \"FreeRTOS.h\"      // FreeRTOS core definitions (needed for task handling and timing)\n#include \"task.h\"          // FreeRTOS task functions (e.g., vTaskDelay)\n#include \"supervisor.h\"    // Functions to check flight status (e.g., supervisorIsArmed)\n#include \"commander.h\"     // Access to commanded setpoints (e.g., commanderGetSetpoint)\n#include \"motors.h\"        // Low-level motor control interface (e.g., motorsSetRatio)\n#include \"debug.h\"         // Debug printing functions (e.g., DEBUG_PRINT)\n\n// Motor coefficients of the quadratic model: PWM = a_2 * omega^2 + a_1 * omega\nconst float a_2 = 0.0f;\nconst float a_1 = 0.0f;\n\n// Global variables to store the desired setpoint, the current state (not used here), \n// the computed PWM value, and the desired angular velocity (omega)\nsetpoint_t setpoint;\nstate_t state;\nfloat pwm;\nfloat omega;\n\n// Main application\nvoid appMain(void *param)\n{\n    // Infinite loop (runs forever)\n    while (true)\n    {\n        // Check if the drone is armed (i.e., ready to fly)\n        if (supervisorIsArmed())\n        {\n            // Fetch the latest setpoint from the commander and also fetch the current estimated state (not used here)\n            commanderGetSetpoint(&amp;setpoint, &amp;state);\n\n            // Compute an angular velocity value proportional to the commanded altitude (Z axis position)\n            // The altitude command increases in 0.5 m steps, and we want the angular velocity to increase \n            // by 200 rad/s for each step. Therefore, we multiply Z by 400.0 so that: 0.5 m \u2192 200 rad/s\n            omega = (setpoint.position.z) * 400.0f;\n\n            // Print the computed omega value to the debug console (rounded to nearest integer)\n            DEBUG_PRINT(\"Omega (rad/s): %.0f\\n\", (double)omega);\n\n            // Convert angular velocity to PWM using the motor model: PWM = a_2 * omega^2 + a_1 * omega\n            pwm = a_2 * omega * omega + a_1 * omega;\n        }\n        else\n        {\n            // If not armed, stop the motors (set PWM to zero)\n            pwm = 0.0f;\n        }\n\n        // Send the PWM signal to all four motors (M1\u2013M4), scaling it to match the expected range [0, UINT16_MAX]\n        motorsSetRatio(MOTOR_M1, pwm * UINT16_MAX);\n        motorsSetRatio(MOTOR_M2, pwm * UINT16_MAX);\n        motorsSetRatio(MOTOR_M3, pwm * UINT16_MAX);\n        motorsSetRatio(MOTOR_M4, pwm * UINT16_MAX);\n\n        // Wait for 100 milliseconds before running the next iteration (10 Hz control loop)\n        vTaskDelay(pdMS_TO_TICKS(100));\n    }\n}\n</code></pre> <p>As etapas para coletar os dados s\u00e3o as seguintes:</p> <ol> <li>Garanta que a bateria do drone est\u00e1 carregada </li> <li>Prenda o drone no dispositivo e zere a balan\u00e7a presionando o bot\u00e3o <code>T</code></li> <li>Arme o drone apertando o bot\u00e3o <code>Arm</code> no CFClient</li> <li>Ligue o motor com um valor espec\u00edfico de velocidade angular \\(\\omega\\) com o Command Based Flight Control do CFClient</li> <li>Anote o n\u00famero que aparece na tela</li> <li>Repita as etapas 4-5 para outros valores de sinal PWM</li> </ol> <p>Ap\u00f3s o experimento, voc\u00ea dever\u00e1 coletar dados para preencher a tabela abaixo.</p> \\(\\omega \\, (rad/s)\\) \\(W_1 \\, (g)\\) \\(W_2 \\, (g)\\) \\(W_3 \\, (g)\\) \\(600\\) \\(800\\) \\(1200\\) \\(1400\\) \\(1600\\) \\(1800\\) \\(2000\\) \\(2200\\) \\(2400\\)"},{"location":"identification/lift_constant/#analise-de-dados","title":"An\u00e1lise de dados","text":"<p>Utilizando os dados coletados, voc\u00ea dever\u00e1 ajustar uma curva que correlacione a velocidade angular \\(\\omega\\) com a for\u00e7a de sustenta\u00e7\u00e3o \\(f\\) da h\u00e9lice (note que voc\u00ea precisa converter a a leitura da balan\u00e7a de \\(g\\) para \\(N\\) e dividir por 4, dado que estamos interessados na for\u00e7a de uma \u00fanica h\u00e9lice).</p> <p></p> <p>Voc\u00ea j\u00e1 sabe que a for\u00e7a de sustenta\u00e7\u00e3o de uma h\u00e9lice \\(f\\) \u00e9 proporcional \u00e0 velocidade angular da h\u00e9lice \\(\\omega\\) ao quadrado:</p> \\[     f = k_l \\omega^2 \\] <p>Ou seja, o tipo de fun\u00e7\u00e3o mais adequado para realizar esse ajuste de curva \u00e9 uma fun\u00e7\u00e3o polinomial de 2\u00ba grau cujos coeficientes de ordem zero e um s\u00e3o nulos. </p> <p>Determine o valor de \\(k_l\\) fazendo esse ajuste de curva (dica: utilize o Curve Fitting Toolbox do MATLAB). Anote o valor obtido em algum lugar pois ele ser\u00e1 utilizado em breve.</p>"},{"location":"identification/lift_constant/#validacao-dos-resultados","title":"Valida\u00e7\u00e3o dos resultados","text":"<p>Compare o resultado obtido com o estimado anteriormente. \u00c9 esperado que a constante de sustenta\u00e7\u00e3o \\(k_l\\) seja da ordem de grandeza de \\(10^{-8}N.s^2\\). </p>"},{"location":"identification/motor_coeficients/","title":"Identifica\u00e7\u00e3o dos coeficientes do motor","text":"<p>Nesta sec\u00e7\u00e3o, voc\u00ea ir\u00e1 determinar experimentalmente os coeficientes do motor el\u00e9trico.</p>"},{"location":"identification/motor_coeficients/#fundamentos-teoricos","title":"Fundamentos te\u00f3ricos","text":"<p>O PWM (\"pulse width modulation\") \u00e9 uma t\u00e9cnica para controlar a pot\u00eancia de um sinal utilizando uma comuta\u00e7\u00e3o digital. Ao mudar rapidamente o sinal entre o m\u00e1ximo e zero (\"on-off\"), e variando a fra\u00e7\u00e3o de tempo que o sinal est\u00e1 no m\u00e1ximo, pode-se controlar a pot\u00eancia transmitida (isto \u00e9, modulando a largura do pulso).</p> <p> </p> <p>Este \u00e9 o mecanismo utilizado pelo Crazyflie para acionar seus motores. J\u00e1 sabemos que no c\u00f3digo \u00e9 poss\u00edvel definir um valor real entre <code>0.0</code> e <code>1.0</code> que corresponde ao sinal PWM do motor. </p> <p>Voc\u00ea ir\u00e1 implementar uma fun\u00e7\u00e3o que, dada uma velocidade angular desejada \\(\\omega\\), determine o sinal PWM correspondente. </p>"},{"location":"identification/motor_coeficients/#procedimento-experimental","title":"Procedimento experimental","text":"<p>Para medir a velocidade angular da h\u00e9lice, voc\u00ea pode utilizar um instrumento de medi\u00e7\u00e3o do n\u00famero de rota\u00e7\u00f5es chamado tac\u00f4metro. Para utiliz\u00e1-lo, voc\u00ea deve fixar um pequeno peda\u00e7o de fita refletora em uma das h\u00e9lices. Certifique-se de usar apenas um pequeno peda\u00e7o de fita e aplicar suavemente na h\u00e9lice, caso contr\u00e1rio voc\u00ea interferir\u00e1 no fluxo de ar e obter\u00e1 dados ruins. </p> <p></p> <p>O tac\u00f4metro pode detectar quando a tira passa pelo seu feixe de luz, assim, a velocidade de rota\u00e7\u00e3o \u00e9 calculada contando quantas vezes a tira passa em um determinado per\u00edodo de tempo. O tac\u00f4metro DT-2234C+ registra a velocidade angular enquanto voc\u00ea pressiona o bot\u00e3o <code>TEST</code> e, uma vez que este bot\u00e3o \u00e9 liberado, ele armazena os valores m\u00ednimo, m\u00e1ximo e m\u00e9dio, que voc\u00ea pode conferir apertando o bot\u00e3o <code>MEM</code>.</p> <p></p> <p>Voc\u00ea deve carregar no drone um programa que ligue apenas o motor cuja h\u00e9lice est\u00e1 com o peda\u00e7o de fita refletora com um determinado valor de sinal PWM. Ser\u00e3o levantados dados de velocidade angular da h\u00e9lice para 10 valores distintos de sinal PWM (<code>0.1</code> at\u00e9 <code>1.0</code>), e, para cada valor de sinal PWM, voc\u00ea dever\u00e1 realizar o experimento 3 vezes e tirar uma m\u00e9dia. Para facilitar o experimento, voc\u00ea pode controlar o valor do PWM com os bot\u00f5es <code>Up</code> e <code>Down</code> do Command Based Flight Control atrav\u00e9s do CFClient.</p> <p></p> <p>Crie um arquivo chamado <code>motor_coeficients.c</code> dentro da pasta <code>src/identification</code> com o seguinte c\u00f3digo:</p> motor_coeficients.c<pre><code>#include \"FreeRTOS.h\"      // FreeRTOS core definitions (needed for task handling and timing)\n#include \"task.h\"          // FreeRTOS task functions (e.g., vTaskDelay)\n#include \"supervisor.h\"    // Functions to check flight status (e.g., supervisorIsArmed)\n#include \"commander.h\"     // Access to commanded setpoints (e.g., commanderGetSetpoint)\n#include \"motors.h\"        // Low-level motor control interface (e.g., motorsSetRatio)\n\n// Global variables to store the desired setpoint, the current state (not used here) and the computed PWM value.\nsetpoint_t setpoint;\nstate_t state;\nfloat pwm;\n\n// Main application\nvoid appMain(void *param)\n{\n    // Infinite loop (runs forever)\n    while (true)\n    {\n        // Check if the drone is armed (i.e., ready to fly)\n        if (supervisorIsArmed())\n        {\n            // Fetch the latest setpoint from the commander and also fetch the current estimated state (not used here)\n            commanderGetSetpoint(&amp;setpoint, &amp;state);\n\n            // Compute a PWM value proportional to the commanded altitude (Z axis position)\n            // The altitude command increases in 0.5 m steps, and we want the PWM to increase by 0.1 for each step.\n            // Therefore, we divide Z by 5.0 so that: 0.5 m \u2192 0.1 PWM\n            pwm = (setpoint.position.z) / 5.0f;\n        }\n        else\n        {\n            // If not armed, stop the motor (set PWM to zero)\n            pwm = 0.0f;\n        }\n        // Send the PWM signal to motor M1, scaling it to match the expected range [0, UINT16_MAX]\n        motorsSetRatio(MOTOR_M1, pwm * UINT16_MAX);\n        // Wait for 100 milliseconds before running the next iteration (10 Hz control loop)\n        vTaskDelay(pdMS_TO_TICKS(100));\n    }\n}\n</code></pre> <p>As etapas para coletar um dado s\u00e3o as seguintes:</p> <ol> <li>Garanta que a bateria do drone est\u00e1 carregada </li> <li>Prenda o drone na mesa com uma fita crepe</li> <li>Arme o drone apertando o bot\u00e3o <code>Arm</code> no CFClient</li> <li>Ligue o motor com um valor espec\u00edfico de sinal PWM com o Command Based Flight Control do CFClient</li> <li>Aponte o tac\u00f4metro para a h\u00e9lice segurando a aproximadamente \\(30cm\\) de dist\u00e2ncia e, em seguida, pressione o bot\u00e3o <code>TEST</code> </li> <li>Mantenha o bot\u00e3o <code>TEST</code> pressionado o tempo todo, certificando-se de que o feixe aponta para onde a faixa refletora passa  </li> <li>Mantenha essa posi\u00e7\u00e3o por alguns segundos e solte o bot\u00e3o <code>TEST</code> </li> <li>Pressione o bot\u00e3o <code>MEM</code> uma vez e espere aparecer a segunda leitura, que corresponde \u00e0 velocidade m\u00e1xima (em \\(rpm\\)) observada durante o experimento  </li> <li>Anote o n\u00famero que aparece na tela</li> <li>Repita as etapas 4-9 para outros valores de sinal PWM</li> </ol> <p>Ap\u00f3s o experimento, voc\u00ea dever\u00e1 coletar dados para preencher a tabela abaixo.</p> PWM N1 (rpm) N2 (rpm) N3 (rpm) <code>0.1</code> <code>0.2</code> <code>0.3</code> <code>0.4</code> <code>0.5</code> <code>0.6</code> <code>0.7</code> <code>0.8</code> <code>0.9</code> <code>1.0</code>"},{"location":"identification/motor_coeficients/#analise-de-dados","title":"An\u00e1lise de dados","text":"<p>Utilizando os dados coletados, voc\u00ea dever\u00e1 ajustar uma curva que correlacione a velocidade angular das h\u00e9lice \\(\\omega\\) com o sinal PWM correspondente do motor (note que voc\u00ea precisa converter a velocidade angular de \\(rpm\\) para \\(rad/s\\)).</p> <p></p> <p>H\u00e1 diversos tipos de fun\u00e7\u00f5es de ajuste para esta curva (linear, exponencial, polinomial, etc.):</p> \\[     \\text{PWM} = f(\\omega) \\] <p>Para definir qual \u00e9 melhor para este caso, \u00e9 necess\u00e1rio se aprofundar na din\u00e2mica do sistema. O esquema eletromec\u00e2nico de um motor el\u00e9trico com uma h\u00e9lice pode ser visto no diagrama abaixo<sup>1</sup>.</p> <p></p> <p>Onde:</p> <ul> <li>\\(e_a\\) - Tens\u00e3o de armadura (\\(V\\))</li> <li>\\(i_a\\) - Corrente de armadura (\\(A\\))</li> <li>\\(R_a\\) - Resist\u00eancia de armadura (\\(\\Omega\\))</li> <li>\\(L_a\\) - Indut\u00e2ncia de armadura (\\(H\\))</li> <li>\\(e_b\\) - Tens\u00e3o contra-eletromotriz (\\(V\\))</li> <li>\\(\\omega\\) - Velocidade angular do motor/h\u00e9lice (\\(rad/s\\))</li> <li>\\(\\tau_m\\) - Torque do motor (\\(N.m\\))</li> <li>\\(k_d\\) - Constante de arrasto da h\u00e9lice (\\(N.m.s^2/rad^2\\))</li> <li>\\(b\\) - Coeficiente de atrito viscoso do motor (\\(N.m.s/rad\\))</li> <li>\\(I\\) - Momento de in\u00e9rcia do motor/h\u00e9lice (\\(kg.m^2\\))</li> </ul> <p>Exerc\u00edcio 1</p> <p>Aplique a lei de Kirchoff das tens\u00f5es no circuito de armadura.</p> Resposta \\[ \\begin{align*}     \\sum_{i=1}^n e_i &amp;= 0 \\\\     e_a - R_a i_a - L_a \\frac{d}{dt} i_a - e_b &amp;= 0 \\end{align*} \\] <p>Exerc\u00edcio 2</p> <p>Aplique a 2\u00ba lei de Newton em torno do eixo do motor.</p> Resposta \\[ \\begin{align*}     \\sum_{i=1}^n \\tau_i &amp;= I \\frac{d}{dt} \\omega \\\\     \\tau_m - k_d \\omega^2 - b \\omega &amp;= I \\frac{d}{dt} \\omega \\end{align*} \\] <p>Em um motor de corrente cont\u00ednua, o torque do motor \\(\\tau_m\\) \u00e9 diretamente proporcional \u00e0 corrente de armadura \\(i_a\\), e a tens\u00e3o contra-eletromotriz \\(e_b\\) \u00e9 diretamente proporcional \u00e0 velocidade angular \\(\\omega\\):</p> \\[ \\tau_m = K_m i_a  \\qquad e_b = K_m \\omega    \\] <p>Onde:</p> <ul> <li>\\(K_m\\) - Constante de torque do motor (\\(N.m/A\\) ou \\(V.s/rad\\)).</li> </ul> <p>Exerc\u00edcio 3</p> <p>Substitua o torque do motor \\(\\tau_m\\) e a tens\u00e3o contra-eletromotriz \\(e_b\\) nas duas equa\u00e7\u00f5es diferenciais obtidas anteriormente.</p> Resposta \\[ \\left\\{     \\begin{array}{l}         L_a \\dfrac{d}{dt} i_a + R_a i_a + K_m \\omega = e_a \\\\ \\\\         I \\dfrac{d}{dt} \\omega + k_d \\omega^2 + b \\omega - K_m i_a = 0     \\end{array} \\right. \\] <p>Quando o motor entra em regime, a corrente de armadura \\(i_a\\) e a velocidade angular \\(\\omega\\) tornam-se constantes (essa \u00e9 a defini\u00e7\u00e3o de ``regime''):</p> \\[     \\dfrac{d}{dt} i_a = 0 \\qquad \\dfrac{d}{dt} \\omega = 0 \\] <p>Exerc\u00edcio 4</p> <p>Iguale as derivadas da corrente de armadura \\(i_a\\) e da velocidade angular \\(\\omega\\) a zero e isole a corrente de armadura \\(i_a\\) nas duas equa\u00e7\u00f5es.</p> Resposta \\[ \\begin{align*}         L_a \\cancelto{0}{\\dfrac{d}{dt} i_a} + R_a i_a + K_m \\omega &amp;= e_a \\\\         R_a i_a &amp;= e_a - K_m \\omega \\\\         i_a &amp;= \\dfrac{1}{R_a} e_a - \\dfrac{K_m}{R_a} \\omega \\end{align*} \\] \\[ \\begin{align*}     I \\cancelto{0}{\\dfrac{d}{dt} \\omega} + k_d \\omega^2 + b \\omega - K_m i_a &amp;= 0 \\\\     K_m i_a &amp;= k_d \\omega^2 + b \\omega \\\\     i_a &amp;= \\dfrac{k_d}{K_m} \\omega^2 + \\dfrac{b}{K_m} \\omega \\end{align*} \\] <p>Exerc\u00edcio 5</p> <p>Iguale a corrente de armadura \\(i_a\\) obtida em cada uma das equa\u00e7\u00f5es e isole a tens\u00e3o de armadura \\(e_a\\) na equa\u00e7\u00e3o.</p> Resposta \\[ \\begin{align*}     \\dfrac{1}{R_a} e_a - \\dfrac{K_m}{R_a} \\omega &amp;= \\dfrac{k_d}{K_m} \\omega^2 + \\dfrac{b}{K_m} \\omega\\\\     \\dfrac{1}{R_a} e_a &amp;= \\dfrac{k_d}{K_m} \\omega^2 + \\dfrac{b}{K_m} \\omega + \\dfrac{K_m}{R_a} \\omega \\\\     e_a &amp;= \\dfrac{R_a k_d}{K_m} \\omega^2 + \\dfrac{R_a b + K_m^2}{K_m} \\omega \\end{align*} \\] <p>O sinal PWM \u00e9 a raz\u00e3o entre a tens\u00e3o de armadura \\(e_a\\) e a tens\u00e3o da bateria \\(e_s\\):</p> \\[     \\text{PWM} = \\frac{e_a}{e_s} \\] <p>Exerc\u00edcio 6</p> <p>Substitua a tens\u00e3o de armadura \\(e_a\\) na equa\u00e7\u00e3o anterior e isole o sinal PWM na equa\u00e7\u00e3o.</p> Resposta \\[ \\begin{align*}     e_a &amp;= \\dfrac{R_a k_d}{K_m} \\omega^2 + \\dfrac{R_a b + K_m^2}{K_m} \\omega \\\\     e_s \\text{PWM} &amp;= \\dfrac{R_a k_d}{K_m} \\omega^2 + \\dfrac{R_a b + K_m^2}{K_m} \\omega \\\\     \\text{PWM} &amp;= \\dfrac{R_a k_d}{K_me_s} \\omega^2 + \\dfrac{R_a b + K_m^2}{K_me_s} \\omega \\end{align*} \\] <p>Voc\u00ea deve ter chegado a:</p> \\[     \\text{PWM} =\\dfrac{R_a k_d}{K_me_s} \\omega^2 + \\dfrac{R_a b + K_m^2}{K_me_s} \\omega \\] <p>Como \\(R_a\\), \\(k_d\\), \\(b\\), \\(K_m\\) e \\(e_s\\) s\u00e3o par\u00e2metros constantes, podemos agrup\u00e1-los em duas constantes:</p> \\[     \\text{PWM} = \\underbrace{\\dfrac{R_a k_d}{K_me_s}}_{a_2} \\omega^2 + \\underbrace{\\dfrac{R_a b + K_m^2}{K_me_s}}_{a_1} \\omega \\] <p>Ou seja, o tipo de fun\u00e7\u00e3o mais adequado para realizar esse ajuste de curva \u00e9 uma fun\u00e7\u00e3o polinomial de 2\u00ba grau cujo coeficiente de ordem zero \u00e9 nulo:</p> \\[     \\text{PWM} = a_2 \\omega^2 + a_1 \\omega + \\cancelto{0}{a_0}   \\] <p>Dessa forma, ao inv\u00e9s de determinar os valores de cada par\u00e2metro (\\(R_a\\), \\(k_d\\), \\(b\\), \\(K_m\\) e \\(e_s\\)), voc\u00ea ir\u00e1 determinar experimentalmente apenas os valores dos coeficientes \\(a_2\\) e \\(a_1\\) (dica: utilize o Curve Fitting Toolbox do MATLAB).</p>"},{"location":"identification/motor_coeficients/#validacao-dos-resultados","title":"Valida\u00e7\u00e3o dos resultados","text":"<p>Uma vez determinados os coeficientes \\(a_2\\) e \\(a_1\\), declare os seus valores no c\u00f3digo (linhas 10 e 11) e modifique seu programa para que, dada uma velocidade angular \\(\\omega\\) comandada (linhas 30 e 35), ele determine o sinal PWM correspondente (linha 41) e envie isso ao motor M1 (linha 50). Note que estamos imprimindo no console o valor de velocidade angular comandada (linha 38) e, para isso, devemos incluir uma biblioteca adicional (linha 6).</p> motor_coeficients.c<pre><code>#include \"FreeRTOS.h\"      // FreeRTOS core definitions (needed for task handling and timing)\n#include \"task.h\"          // FreeRTOS task functions (e.g., vTaskDelay)\n#include \"supervisor.h\"    // Functions to check flight status (e.g., supervisorIsArmed)\n#include \"commander.h\"     // Access to commanded setpoints (e.g., commanderGetSetpoint)\n#include \"motors.h\"        // Low-level motor control interface (e.g., motorsSetRatio)\n#include \"debug.h\"         // Debug printing functions (e.g., DEBUG_PRINT)\n\n// Motor coefficients of the quadratic model: PWM = a_2 * omega^2 + a_1 * omega\nconst float a_2 = 0.0f;\nconst float a_1 = 0.0f;\n\n// Global variables to store the desired setpoint, the current state (not used here), \n// the computed PWM value, and the desired angular velocity (omega)\nsetpoint_t setpoint;\nstate_t state;\nfloat pwm;\nfloat omega;\n\n// Main application\nvoid appMain(void *param)\n{\n    // Infinite loop (runs forever)\n    while (true)\n    {\n        // Check if the drone is armed (i.e., ready to fly)\n        if (supervisorIsArmed())\n        {\n            // Fetch the latest setpoint from the commander and also fetch the current estimated state (not used here)\n            commanderGetSetpoint(&amp;setpoint, &amp;state);\n\n            // Compute an angular velocity value proportional to the commanded altitude (Z axis position)\n            // The altitude command increases in 0.5 m steps, and we want the angular velocity to increase \n            // by 200 rad/s for each step. Therefore, we multiply Z by 400.0 so that: 0.5 m \u2192 200 rad/s\n            omega = (setpoint.position.z) * 400.0f;\n\n            // Print the computed omega value to the debug console (rounded to nearest integer)\n            DEBUG_PRINT(\"Omega (rad/s): %.0f\\n\", (double)omega);\n\n            // Convert angular velocity to PWM using the motor model: PWM = a_2 * omega^2 + a_1 * omega\n            pwm = a_2 * omega * omega + a_1 * omega;\n        }\n        else\n        {\n            // If not armed, stop the motors (set PWM to zero)\n            pwm = 0.0f;\n        }\n\n        // Send the PWM signal to motors M1, scaling it to match the expected range [0, UINT16_MAX]\n        motorsSetRatio(MOTOR_M1, pwm * UINT16_MAX);\n\n        // Wait for 100 milliseconds before running the next iteration (10 Hz control loop)\n        vTaskDelay(pdMS_TO_TICKS(100));\n    }\n}\n</code></pre> <p>O c\u00f3digo acima faz uso do Command Based Flight Control para comandar a velocidade angular \\(\\omega\\) em incrementos de \\(200rad/s\\). Voc\u00ea deve test\u00e1-lo verificando se a velocidade angular comandada est\u00e1 pr\u00f3xima<sup>2</sup> da leitura do tac\u00f4metro.</p> <ol> <li> <p>Embora o Crazyflie utilize um motor el\u00e9trico de corrente cont\u00ednua sem escovas e n\u00e3o com escovas, a equa\u00e7\u00e3o matem\u00e1tica de ambos \u00e9 equivalente.\u00a0\u21a9</p> </li> <li> <p>Ela n\u00e3o vai bater na v\u00edrgula, pois fizemos um ajuste de curva. No entanto, essa diverg\u00eancia n\u00e3o ser\u00e1 um problema pois ainda vamos fechar a malha de controle em um n\u00edvel superior.\u00a0\u21a9</p> </li> </ol>"},{"location":"modeling/2d_model/","title":"Modelo 2D","text":""},{"location":"modeling/2d_model/#introducao","title":"Introdu\u00e7\u00e3o","text":""},{"location":"modeling/2d_model/#notacao-escalar","title":"Nota\u00e7\u00e3o escalar","text":""},{"location":"modeling/2d_model/#sistema-de-coordenadas-fixo","title":"Sistema de coordenadas fixo","text":""},{"location":"modeling/2d_model/#sistema-de-coordenadas-movel","title":"Sistema de coordenadas m\u00f3vel","text":""},{"location":"modeling/2d_model/#notacao-vetorial","title":"Nota\u00e7\u00e3o vetorial","text":""},{"location":"modeling/2d_model/#sistema-de-coordenadas-fixo_1","title":"Sistema de coordenadas fixo","text":""},{"location":"modeling/2d_model/#sistema-de-coordenadas-movel_1","title":"Sistema de coordenadas m\u00f3vel","text":""},{"location":"modeling/3d_model/","title":"Modelo 3D","text":""},{"location":"modeling/3d_model/#introducao","title":"Introdu\u00e7\u00e3o","text":""},{"location":"modeling/3d_model/#cinetica","title":"Cin\u00e9tica","text":""},{"location":"modeling/3d_model/#translacao","title":"Transla\u00e7\u00e3o","text":""},{"location":"modeling/3d_model/#rotacao","title":"Rota\u00e7\u00e3o","text":""},{"location":"modeling/3d_model/#cinematica","title":"Cinem\u00e1tica","text":""},{"location":"modeling/3d_model/#translacao_1","title":"Transla\u00e7\u00e3o","text":""},{"location":"modeling/3d_model/#rotacao_1","title":"Rota\u00e7\u00e3o","text":""},{"location":"modeling/3d_model/#linearizacao","title":"Lineariza\u00e7\u00e3o","text":""},{"location":"modeling/coordinate_system/","title":"Sistema de coordenadas","text":"<p>No controle de drones, o uso de sistemas de coordenadas \u00e9 fundamental para descrever posi\u00e7\u00f5es e orienta\u00e7\u00f5es relativas. Alguns exemplos comuns s\u00e3o: a posi\u00e7\u00e3o do drone em rela\u00e7\u00e3o ao solo, a orienta\u00e7\u00e3o da c\u00e2mera em rela\u00e7\u00e3o ao drone e a velocidade do drone em rela\u00e7\u00e3o ao vento.</p> <p>A escolha do sistema de coordenadas adequado torna muitos c\u00e1lculos mais simples. Por exemplo, for\u00e7as e torques aerodin\u00e2micos s\u00e3o mais naturalmente descritos em um sistema de coordenadas m\u00f3vel (fixo no drone), enquanto a acelera\u00e7\u00e3o da gravidade \u00e9 melhor representada em um sistema de coordenadas inercial (fixo na Terra).</p>"},{"location":"modeling/coordinate_system/#matriz-de-rotacao","title":"Matriz de rota\u00e7\u00e3o","text":"<p>Quando trabalhamos com diferentes sistemas de coordenadas, precisamos de uma forma matem\u00e1tica para descrever a orienta\u00e7\u00e3o relativa entre eles. Essa fun\u00e7\u00e3o \u00e9 cumprida pelas matrizes de rota\u00e7\u00e3o, que permitem representar rota\u00e7\u00f5es tanto no plano (2D) quanto no espa\u00e7o tridimensional (3D).</p>"},{"location":"modeling/coordinate_system/#2d","title":"2D","text":"<p>Ao descrever a posi\u00e7\u00e3o de um drone, precisamos definir uma refer\u00eancia. Um m\u00e9todo geral \u00e9 utilizar um sistema de coordenadas inercial \\({\\color{magenta}yz}\\) (1).</p> <ol> <li>Fixo na Terra, que n\u00e3o acelera nem rotaciona.</li> </ol> <p></p> <p>J\u00e1 para descrever a atitude (orienta\u00e7\u00e3o) do drone, apenas esse sistema n\u00e3o \u00e9 suficiente. \u00c9 necess\u00e1rio introduzir tamb\u00e9m um sistema de coordenadas m\u00f3vel \\({\\color{cyan}y'z'}\\) (1).</p> <ol> <li>Fixo no drone, que acelera e rotaciona com ele.</li> </ol> <p></p> <p>A atitude do drone \u00e9 dada, portanto, pela orienta\u00e7\u00e3o relativa do sistema m\u00f3vel \\({\\color{cyan}y'z'}\\) em rela\u00e7\u00e3o ao sistema inercial \\({\\color{magenta}yz}\\). Essa orienta\u00e7\u00e3o pode ser representada matematicamente por uma matriz \\(2 \\times 2\\) chamada de matrix de rota\u00e7\u00e3o \\(R\\):</p> \\[ {\\color{cyan} \\begin{bmatrix}     y' \\\\     z' \\end{bmatrix} } = \\underbrace{ \\begin{bmatrix}     r_{11} &amp; r_{12} \\\\     r_{21} &amp; r_{22} \\end{bmatrix} }_{R} {\\color{magenta} \\begin{bmatrix}     y \\\\     z \\end{bmatrix} } \\] <p>Apesar de possuir quatro elementos, essa matriz pode ser descrita em fun\u00e7\u00e3o de um \u00fanico par\u00e2metro: o \u00e2ngulo de rota\u00e7\u00e3o \\(\\phi\\):</p> \\[ R(\\phi)= \\begin{bmatrix}     r_{11}(\\phi) &amp; r_{12}(\\phi)\\\\     r_{21}(\\phi) &amp; r_{22}(\\phi) \\end{bmatrix} \\] <p>Exerc\u00edcio 1</p> <p>Considere que o sistema de coordenadas m\u00f3vel \\({\\color{cyan}y'z'}\\) est\u00e1 rotacionado de um \u00e2ngulo \\(\\phi\\) em rela\u00e7\u00e3o ao sistema de coordenadas inercial \\({\\color{magenta}yz}\\).</p> <p></p> a) Escreva a matriz de rota\u00e7\u00e3o em fun\u00e7\u00e3o do \u00e2ngulo \\(\\phi\\). \\[ R(\\phi) =  \\begin{bmatrix}      \\cos{\\phi} &amp; \\sin{\\phi} \\\\      -\\sin{\\phi} &amp; \\cos{\\phi}  \\end{bmatrix} \\] b) Calcule \\(R(\\phi)\\) para \\(\\phi = \\frac{\\pi}{2} \\, \\text{rad}\\) e interprete o resultado. \\[ R\\left(\\frac{\\pi}{2}\\right)  =  \\begin{bmatrix}      \\cos{\\frac{\\pi}{2}} &amp; \\sin{\\frac{\\pi}{2}} \\\\      -\\sin{\\frac{\\pi}{2}} &amp; \\cos{\\frac{\\pi}{2}}  \\end{bmatrix}  = \\begin{bmatrix}      0 &amp; 1 \\\\      -1 &amp; 0 \\end{bmatrix} \\] <p>O resultado faz sentido: ao rotacionar \\(90^{\\circ}\\), o eixo \\({\\color{cyan}y'}\\) passa a coincidir com \\({\\color{magenta}z}\\), enquanto o eixo \\({\\color{cyan}z'}\\) fica no sentido oposto de \\({\\color{magenta}y}\\).</p> c) Determine o \u00e2ngulo \\(\\phi\\) correspondente \u00e0 matriz  \\(R (\\phi)= \\begin{bmatrix} \\frac{\\sqrt{2}}{2} &amp; \\frac{\\sqrt{2}}{2} \\\\ -\\frac{\\sqrt{2}}{2} &amp; \\frac{\\sqrt{2}}{2} \\end{bmatrix}\\). \\[ \\begin{align*}     \\cos \\phi &amp;= \\frac{\\sqrt{2}}{2} \\\\     \\phi &amp;= \\cos^{-1}\\!\\left(\\frac{\\sqrt{2}}{2}\\right) \\\\     \\phi &amp;= \\frac{\\pi}{4} \\;\\text{rad} \\;\\; (45^\\circ) \\end{align*} \\]"},{"location":"modeling/coordinate_system/#3d","title":"3D","text":"<p>Assim como no plano, no espa\u00e7o a atitude do drone tamb\u00e9m \u00e9 dada pela atitude relativa do sistema de coordenadas m\u00f3vel \\({\\color{cyan}x'y'z'}\\) em rela\u00e7\u00e3o ao sistema de coordenadas inercial \\({\\color{magenta}xyz}\\).</p> <p></p> <p>No entanto, como agora estamos lidando com tr\u00eas dimens\u00f5es, a matriz de rota\u00e7\u00e3o \\(R\\) passa a possuir dimens\u00e3o \\(3 \\times 3\\):</p> \\[ {\\color{cyan} \\begin{bmatrix}     x'\\\\y'\\\\z' \\end{bmatrix} } = \\underbrace{ \\begin{bmatrix}     r_{11} &amp; r_{12} &amp; r_{13}\\\\     r_{21} &amp; r_{22} &amp; r_{23}\\\\     r_{31} &amp; r_{32} &amp; r_{33} \\end{bmatrix} }_{R} {\\color{magenta} \\begin{bmatrix}     x \\\\     y \\\\     z \\end{bmatrix} } \\] <p>De acordo com Leonhard Euler, qualquer atitude no espa\u00e7o pode ser descrita atrav\u00e9s de tr\u00eas rota\u00e7\u00f5es sucessivas em torno de eixos pr\u00e9-definidos e mutuamente ortogonais(1). Dessa forma, os nove elementos da matriz de rota\u00e7\u00e3o podem ser expressos em fun\u00e7\u00e3o de tr\u00eas par\u00e2metros: os \u00e2ngulos de Euler \\(\\phi\\), \\(\\theta\\) e \\(\\psi\\):</p> <ol> <li>Formam um \u00e2ngulo de \\(90^{\\circ}\\) entre si.</li> </ol> \\[\\begin{equation*}         R({\\phi},{\\theta},{\\psi})         =         \\begin{bmatrix}         r_{11}({\\phi},{\\theta},{\\psi}) &amp; r_{12}({\\phi},{\\theta},{\\psi}) &amp; r_{13}({\\phi},{\\theta},{\\psi}) \\\\         r_{21}({\\phi},{\\theta},{\\psi}) &amp; r_{22}({\\phi},{\\theta},{\\psi}) &amp; r_{23}({\\phi},{\\theta},{\\psi}) \\\\         r_{31}({\\phi},{\\theta},{\\psi}) &amp; r_{32}({\\phi},{\\theta},{\\psi}) &amp; r_{33}({\\phi},{\\theta},{\\psi})         \\end{bmatrix} \\end{equation*}\\] <p>Exerc\u00edcio 2</p> <p>Considere que o sistema de coordenadas m\u00f3vel \\({\\color{cyan}x'y'z'}\\) est\u00e1 rotacionado de um \u00e2ngulo \\(\\phi\\) em rela\u00e7\u00e3o ao sistema de coordenadas inercial \\({\\color{magenta}xyz}\\) e em torno do eixo \\({\\color{magenta}x}\\).</p> <p></p> a) Escreva a matriz de rota\u00e7\u00e3o em fun\u00e7\u00e3o do \u00e2ngulo \\(\\phi\\). \\[ R_x(\\phi) =  \\begin{bmatrix}      1 &amp; 0 &amp; 0 \\\\     0 &amp; \\cos\\phi &amp; \\sin\\phi \\\\      0 &amp; -\\sin\\phi &amp; \\cos\\phi  \\end{bmatrix} \\] b) Calcule \\(R_x(\\phi)\\) para \\(\\phi=\\pi \\, \\text{rad}\\) e interprete o resultado. \\[ \\begin{align*}     R_x\\left(\\pi\\right)      =      \\begin{bmatrix}          1 &amp; 0 &amp; 0 \\\\         0 &amp; \\cos \\pi &amp; \\sin \\pi \\\\          0 &amp; -\\sin \\pi &amp; \\cos \\pi     \\end{bmatrix}      =      \\begin{bmatrix}          1 &amp; 0 &amp; 0 \\\\         0 &amp; -1 &amp; 0 \\\\          0 &amp; 0 &amp; -1     \\end{bmatrix} \\end{align*} \\] <p>O resultado faz sentido: uma rota\u00e7\u00e3o de \\(180^\\circ\\) em torno de \\({\\color{magenta}x}\\) inverte os eixos \\({\\color{magenta}y}\\) e \\({\\color{magenta}z}\\), de modo que \\({\\color{cyan}y'}\\) e \\({\\color{cyan}z'}\\) ficam em sentidos opostos a \\({\\color{magenta}y}\\) e \\({\\color{magenta}z}\\), enquanto \\({\\color{cyan}x'}\\) permance alinhado com \\({\\color{magenta}x}\\).</p> <p>Exerc\u00edcio 3</p> <p>Considere que o sistema de coordenadas m\u00f3vel \\({\\color{cyan}x'y'z'}\\) est\u00e1 rotacionado de um \u00e2ngulo \\(\\theta\\) em rela\u00e7\u00e3o ao sistema de coordenadas inercial \\({\\color{magenta}xyz}\\) e em torno do eixo \\({\\color{magenta}y}\\).</p> <p></p> a) Escreva a matriz de rota\u00e7\u00e3o em fun\u00e7\u00e3o do \u00e2ngulo \\(\\theta\\). \\[ R_y(\\theta) =  \\begin{bmatrix}      \\cos\\theta &amp; 0 &amp; -\\sin\\theta \\\\      0 &amp; 1 &amp; 0 \\\\      \\sin\\theta &amp; 0 &amp; \\cos\\theta \\end{bmatrix} \\] b) Calcule \\(R_y(\\theta)\\) para \\(\\theta=\\tfrac{\\pi}{2} \\, \\text{rad}\\) e interprete o resultado. \\[ \\begin{align*}     R_y\\left(\\frac{\\pi}{2}\\right)      =      \\begin{bmatrix}          \\cos\\frac{\\pi}{2} &amp; 0 &amp; -\\sin\\frac{\\pi}{2} \\\\          0 &amp; 1 &amp; 0 \\\\          \\sin\\frac{\\pi}{2} &amp; 0 &amp; \\cos\\frac{\\pi}{2}     \\end{bmatrix}      =      \\begin{bmatrix}          0 &amp; 0 &amp; -1 \\\\          0 &amp; 1 &amp; 0 \\\\          1 &amp; 0 &amp; 0     \\end{bmatrix} \\end{align*} \\] <p>O resultado faz sentido: ao rotacionar \\(90^\\circ\\) em torno de \\({\\color{magenta}y}\\), o eixo \\({\\color{cyan}x'}\\) passa a apontar para o sentido oposto de \\({\\color{magenta}z}\\) e o eixo \\({\\color{cyan}z'}\\) passa a coincidir com \\({\\color{magenta}x}\\), enquanto o eixo \\({\\color{cyan}y'}\\) permance alinhado com \\({\\color{magenta}y}\\).</p> <p>Exerc\u00edcio 4</p> <p>Considere que o sistema de coordenadas m\u00f3vel \\({\\color{cyan}x'y'z'}\\) est\u00e1 rotacionado de um \u00e2ngulo \\(\\psi\\) em rela\u00e7\u00e3o ao sistema de coordenadas inercial \\({\\color{magenta}xyz}\\) e em torno do eixo \\({\\color{magenta}z}\\).</p> <p></p> a) Escreva a matriz de rota\u00e7\u00e3o em fun\u00e7\u00e3o do \u00e2ngulo \\(\\psi\\). \\[ R_z(\\psi) =  \\begin{bmatrix}      \\cos\\psi &amp; \\sin\\psi &amp; 0 \\\\      -\\sin\\psi &amp; \\cos\\psi &amp; 0 \\\\      0 &amp; 0 &amp; 1 \\end{bmatrix} \\] b) Calcule \\(R_z(\\psi)\\) para \\(\\psi=2\\pi \\, \\text{rad}\\) e interprete o resultado. \\[ \\begin{align*}     R_z\\left(2\\pi\\right)      =      \\begin{bmatrix}           \\cos 2\\pi &amp; \\sin 2\\pi &amp; 0 \\\\          -\\sin 2\\pi &amp; \\cos 2\\pi &amp; 0 \\\\          0 &amp; 0 &amp; 1     \\end{bmatrix}      =      \\begin{bmatrix}          1 &amp; 0 &amp; 0 \\\\         0 &amp; 1 &amp; 0 \\\\          0 &amp; 0 &amp; 1     \\end{bmatrix} \\end{align*} \\] <p>O resultado faz sentido: uma rota\u00e7\u00e3o completa de \\(360^\\circ\\) em torno de \\({\\color{magenta}z}\\) devolve \\({\\color{cyan}x'y'z'}\\) exatamente a \\({\\color{magenta}xyz}\\), ou seja, todos os eixos voltam a coincidir.</p>"},{"location":"modeling/coordinate_system/#propriedades","title":"Propriedades","text":""},{"location":"modeling/coordinate_system/#propriedades_1","title":"Propriedades","text":"<p>Matrizes de rota\u00e7\u00e3o possuem algumas propriedades fundamentais:</p> <ul> <li>Cada linha e cada coluna tem norma unit\u00e1ria (comprimento igual a 1).</li> <li>Linhas e colunas s\u00e3o ortogonais entre si (o produto escalar entre elas \u00e9 zero).</li> <li>S\u00e3o matrizes ortonormais (sua inversa \u00e9 igual \u00e0 transposta), isto \u00e9, \\(R^{-1} = R^T\\).</li> <li>Possuem determinante unit\u00e1rio, isto \u00e9, \\(\\det (R) = 1\\).</li> </ul> <p>Exerc\u00edcio 5</p> <p>Considere a matriz de rota\u00e7\u00e3o \\(R\\) que relaciona o sistema de coordenadas m\u00f3vel \\({\\color{cyan}x'y'z'}\\) com o sistema de coordenadas inercial \\({\\color{magenta}xyz}\\):</p> \\[ R =  \\begin{bmatrix}      \\frac{\\sqrt{2}}{2} &amp; \\frac{\\sqrt{2}}{2} &amp; 0 \\\\      -\\frac{\\sqrt{2}}{2} &amp; \\frac{\\sqrt{2}}{2} &amp; 0 \\\\      0 &amp; 0 &amp; 1  \\end{bmatrix}    \\] <p>Calcule a matriz de rota\u00e7\u00e3o inversa \\(R^{-1}\\), isto \u00e9, que relaciona o sistema inercial \\({\\color{magenta}xyz}\\) com o sistema m\u00f3vel \\({\\color{cyan}x'y'z'}\\).</p> Resposta \\[ R^{-1} = R^{T} = \\begin{bmatrix}      \\frac{\\sqrt{2}}{2} &amp; -\\frac{\\sqrt{2}}{2} &amp; 0 \\\\      \\frac{\\sqrt{2}}{2} &amp; \\frac{\\sqrt{2}}{2} &amp; 0 \\\\      0 &amp; 0 &amp; 1  \\end{bmatrix} \\]"},{"location":"modeling/coordinate_system/#angulos-de-euler","title":"\u00c2ngulos de Euler","text":"<p>Os \u00e2ngulos de Euler s\u00e3o um conjunto de tr\u00eas rota\u00e7\u00f5es sucessivas em torno de eixos distintos, que permitem levar o sistema de coordenadas inercial \\({\\color{magenta}xyz}\\) at\u00e9 o sistema de coordenadas m\u00f3vel \\({\\color{cyan}x'y'z'}\\).  </p> <p></p> <p>De acordo com a conven\u00e7\u00e3o adotada aqui, usamos:</p> <ul> <li>\\(\\psi\\): rota\u00e7\u00e3o em torno do eixo \\({\\color{magenta}z'}\\) (yaw - guinagem)  </li> <li>\\(\\theta\\): rota\u00e7\u00e3o em torno do eixo \\({\\color{magenta}y'}\\) (pitch - inclina\u00e7\u00e3o)  </li> <li>\\(\\phi\\): rota\u00e7\u00e3o em torno do eixo \\({\\color{magenta}x'}\\) (roll - rolagem)  </li> </ul> <p>A matriz de rota\u00e7\u00e3o total \u00e9 obtida pela composi\u00e7\u00e3o das tr\u00eas matrizes individuais.  </p> \\[ R(\\phi,\\theta,\\psi) =  \\underbrace{ \\begin{bmatrix}      1 &amp; 0 &amp; 0 \\\\     0 &amp; \\cos\\phi &amp; \\sin\\phi \\\\      0 &amp; -\\sin\\phi &amp; \\cos\\phi \\end{bmatrix} }_{R_x(\\phi)} \\underbrace{ \\begin{bmatrix}      \\cos\\theta &amp; 0 &amp; -\\sin\\theta \\\\      0 &amp; 1 &amp; 0 \\\\      \\sin\\theta &amp; 0 &amp; \\cos\\theta  \\end{bmatrix} }_{R_y(\\theta)} \\underbrace{ \\begin{bmatrix}      \\cos\\psi &amp; \\sin\\psi &amp; 0 \\\\      -\\sin\\psi &amp; \\cos\\psi &amp; 0 \\\\      0 &amp; 0 &amp; 1  \\end{bmatrix}    }_{R_z(\\psi)} \\] <p>Note</p> <p>Observe que a primeira rota\u00e7\u00e3o aplicada, \\(R_z(\\psi)\\), aparece mais \u00e0 direita, enquanto a \u00faltima rota\u00e7\u00e3o, \\(R_x(\\phi)\\), aparece mais \u00e0 esquerda. Isso ocorre porque a multiplica\u00e7\u00e3o de matrizes segue a ordem inversa da aplica\u00e7\u00e3o das transforma\u00e7\u00f5es.</p> <p>Exerc\u00edcio 6</p> <p>Determine a matriz de rota\u00e7\u00e3o total \\(R(\\phi,\\theta,\\psi)\\) que relaciona o sistema de coordenadas m\u00f3vel \\({\\color{cyan}x'y'z'}\\) com o sistema de coordenadas inercial \\({\\color{magenta}xyz}\\) em fun\u00e7\u00e3o dos \u00e2ngulos de Euler \\(\\phi\\), \\(\\theta\\) e \\(\\psi\\).</p> <p>Dica: utilize o Symbolic Math Toolbox do MATLAB.</p> Resposta \\[ R (\\phi,\\theta,\\psi) =  \\begin{bmatrix} \\cos\\theta\\cos\\psi &amp; \\cos\\theta\\sin\\psi &amp; -\\sin\\theta \\\\  - \\cos\\phi\\sin\\psi + \\sin\\phi\\sin\\theta\\cos\\psi  &amp; \\cos\\phi\\cos\\psi + \\sin\\phi\\sin\\theta\\sin\\psi &amp; \\sin\\phi\\cos\\theta \\\\  \\sin\\phi\\sin\\psi + \\cos\\phi\\sin\\theta\\cos\\psi &amp; - \\sin\\phi\\cos\\psi + \\cos\\phi\\sin\\theta\\sin\\psi  &amp; \\cos\\phi\\cos\\theta  \\end{bmatrix} \\]"},{"location":"modeling/coordinate_system/#singularidades","title":"Singularidades","text":"<p>Singularidades s\u00e3o pontos nos quais uma vari\u00e1vel matem\u00e1tica torna-se indefinida. No caso dos \u00e2ngulos de Euler, \u00e9 uma orienta\u00e7\u00e3o na qual h\u00e1 mais de uma \u00fanica sequ\u00eancia de rota\u00e7\u00f5es poss\u00edveis. </p> <p>Quando a segunda rota\u00e7\u00e3o \u00e9 igual a \\(\\theta = \\frac{\\pi}{2}\\) rad, a dire\u00e7\u00e3o dos eixos da primeira (\\({\\color{cyan}z'}\\)) e terceira (\\({\\color{cyan}x'}\\)) rota\u00e7\u00e3o coincidem, tornando-se imposs\u00edvel discernir os valores de \\(\\psi\\) e \\(\\phi\\).</p> <p>N\u00e3o h\u00e1 acordo sobre a nota\u00e7\u00e3o (sequ\u00eancia de rota\u00e7\u00f5es) utilizada pelos \u00e2ngulos de Euler. Existe um total de 12 combina\u00e7\u00f5es, pois a rota\u00e7\u00e3o seguinte deve sempre ocorrer em um eixo distinto da anterior, conforme a tabela abaixo:</p> Nota\u00e7\u00e3o Eixo da 1\u00aa rota\u00e7\u00e3o Eixo da 2\u00aa rota\u00e7\u00e3o Eixo da 3\u00aa rota\u00e7\u00e3o \\( x\\!-\\!y\\!-\\!x \\) \\( x' \\) \\( y' \\) \\( x' \\) \\( x\\!-\\!y\\!-\\!z \\) \\( z' \\) \\( x\\!-\\!z\\!-\\!x \\) \\( z' \\) \\( x' \\) \\( x\\!-\\!z\\!-\\!y \\) \\( y' \\) \\( y\\!-\\!x\\!-\\!y \\) \\( y' \\) \\( x' \\) \\( y' \\) \\( y\\!-\\!x\\!-\\!z \\) \\( z' \\) \\( y\\!-\\!z\\!-\\!y \\) \\( z' \\) \\( y' \\) \\( y\\!-\\!z\\!-\\!x \\) \\( x' \\) \\( z\\!-\\!x\\!-\\!z \\) \\( z' \\) \\( x' \\) \\( z' \\) \\( z\\!-\\!x\\!-\\!y \\) \\( y' \\) \\( z\\!-\\!y\\!-\\!z \\) \\( y' \\) \\( z' \\) \\( z\\!-\\!y\\!-\\!x \\) \\( x' \\) <p>Note que todas as combina\u00e7\u00f5es possuem singularidades; a \u00fanica diferen\u00e7a \u00e9 o \u00e2ngulo no qual elas ocorrem:</p> <ul> <li>Quando o eixo da primeira e terceira rota\u00e7\u00e3o s\u00e3o iguais (\u00c2ngulos de Euler), as singularidades ocorrem quando a segunda rota\u00e7\u00e3o \u00e9 igual a \\(0 \\, \\text{rad}\\).</li> <li>Quando o eixo da primeira e terceira rota\u00e7\u00e3o s\u00e3o distintos (\u00c2ngulos de Tait\u2013Bryan), as singularidades ocorrem quando a segunda rota\u00e7\u00e3o \u00e9 igual a \\(\\frac{\\pi}{2} \\, \\text{rad}\\). </li> </ul> <p>Como a posi\u00e7\u00e3o de equil\u00edbrio do drone ocorre quando a segunda rota\u00e7\u00e3o \u00e9 igual a \\(0 \\, \\text{rad}\\), utiliza-se a nota\u00e7\u00e3o em que o eixo da primeira e terceira rota\u00e7\u00e3o s\u00e3o distintos (\\(z-y-x\\)), tamb\u00e9m conhecido por yaw, pitch e roll(1).  Assim, a singularidade fica distante de ocorrer (apesar de ainda ser uma possibilidade).</p> <ol> <li>Guinagem (\\(\\psi\\) no eixo \\(z\\)), inclina\u00e7\u00e3o (\\(\\theta\\) no eixo \\(y\\)) e rolagem (\\(\\phi\\) no eixo \\(x\\))</li> </ol> <p>Uma alternativa aos \u00e2ngulos de Euler, que n\u00e3o possuem singularidades, s\u00e3o os quat\u00e9rnios.</p>"},{"location":"sensors_and_actuators/motors/","title":"Motores","text":"<p>Nesta sec\u00e7\u00e3o, vamos fazer o drone girar um de seus motores pela primeira vez. Esse \u00e9 o seu primeiro contato com controle real de hardware, um passo fundamental rumo ao voo aut\u00f4nomo.</p> <p>Vamos criar um programa simples que liga o motor 1 com 10% de pot\u00eancia, sempre que o drone estiver armado (ou seja, autorizado a voar).</p>"},{"location":"sensors_and_actuators/motors/#visao-geral","title":"Vis\u00e3o geral","text":"<p>Antes de come\u00e7ar, \u00e9 importante entender alguns conceitos:</p> <ul> <li>Armar o drone significa autorizar o funcionamento dos motores. Isso \u00e9 feito manualmente pelo operador atrav\u00e9s do Crazyflie Client e verificado no c\u00f3digo com a fun\u00e7\u00e3o <code>supervisorIsArmed()</code>.</li> <li>O controle dos motores \u00e9 feito atrav\u00e9s da fun\u00e7\u00e3o <code>motorsSetRatio(id, ratio)</code>, onde <code>id</code> corresponde ao motor que vai ser acionado e <code>ratio</code> \u00e0 sua pot\u00eancia.<ul> <li>O Crazyflie possui quatro motores, identificados como <code>MOTOR_M1</code>, <code>MOTOR_M2</code>, <code>MOTOR_M3</code> e <code>MOTOR_M4</code>.</li> <li>A pot\u00eancia vai de <code>0</code> (desligado) at\u00e9 <code>UINT16_MAX</code> (pot\u00eancia m\u00e1xima).</li> </ul> </li> <li>Em FreeRTOS, um delay \u00e9 realizado atrav\u00e9s da fun\u00e7\u00e3o <code>vTaskDelay(pdMS_TO_TICKS(xTimeInMs))</code>, que recebe um tempo em milissegundos e o converte para ticks do sistema.</li> </ul>"},{"location":"sensors_and_actuators/motors/#codigo","title":"C\u00f3digo","text":"<p>Crie um arquivo chamado <code>motors.c</code> dentro da pasta <code>src/examples</code> com o seguinte c\u00f3digo:</p> motors.c<pre><code>#include \"FreeRTOS.h\"      // FreeRTOS core definitions (needed for task handling and timing)\n#include \"task.h\"          // FreeRTOS task functions (e.g., vTaskDelay)\n#include \"supervisor.h\"    // Functions to check flight status (e.g., supervisorIsArmed)\n#include \"motors.h\"        // Low-level motor control interface (e.g., motorsSetRatio)\n#include \"debug.h\"         // Debug printing functions (e.g., DEBUG_PRINT)\n\n// Main application loop\nvoid appMain(void *param)\n{\n    // Infinite loop (runs continuously while the drone is powered on)\n    while (true)\n    {\n        // Check if the drone is armed (i.e., ready to receive motor commands)\n        if (supervisorIsArmed())\n        {\n            // If armed, turn on motor 1 with 10% power\n            motorsSetRatio(MOTOR_M1, 0.1f * UINT16_MAX);\n        }\n        else\n        {\n            // If not armed, stop motor 1\n            motorsSetRatio(MOTOR_M1, 0);\n        }\n        // Wait for 100 milliseconds before checking again (10 Hz loop)\n        vTaskDelay(pdMS_TO_TICKS(100));\n    }\n}\n</code></pre> <p>Voc\u00ea pode simplesmente copiar e colar o c\u00f3digo acima. Mas \u00e9 importante que voc\u00ea leia e entenda o que cada linha est\u00e1 fazendo (o c\u00f3digo est\u00e1 bem comentado).</p>"},{"location":"sensors_and_actuators/motors/#compilando","title":"Compilando","text":"<p>Para que o firmware compile seu novo programa, modifique o arquivo <code>Kbuild</code>:</p> Kbuild<pre><code>obj-y += src/examples/motors.o\n</code></pre> <p>Em seguida, compile e programe o quadricoptero.</p>"},{"location":"sensors_and_actuators/motors/#testando","title":"Testando","text":"<p>Para testar o funcionamento, siga as etapas abaixo:</p> <ol> <li>Abra o Crazyflie Client e conecte-se ao drone.</li> <li>Clique no bot\u00e3o <code>Arm</code>.</li> <li>O motor 1 deve come\u00e7ar a girar com 10% de pot\u00eancia.</li> <li>Ao clicar em <code>Disarm</code>, o motor deve parar imediatamente.</li> </ol> <p>Aten\u00e7\u00e3o</p> <p>O motor vai girar, mas o drone n\u00e3o vai levantar voo, pois estamos controlando apenas um motor isolado com baixa pot\u00eancia.</p> <p>Voc\u00ea acaba de escrever seu primeiro programa que interage com o hardware real do drone \u2014 controlando motores com seguran\u00e7a. Um passo simples, mas poderoso, no caminho do voo aut\u00f4nomo.</p>"},{"location":"sensors_and_actuators/sensors/","title":"Sensores","text":"<p>Nesta sec\u00e7\u00e3o, vamos aprender como ler os dados dos sensores do drone em tempo real. Esses dados s\u00e3o fundamentais para tarefas como estabiliza\u00e7\u00e3o, controle, navega\u00e7\u00e3o e autonomia.</p> <p>Vamos criar um programa que l\u00ea e imprime no console os seguintes sensores:</p> <ul> <li>Aceler\u00f4metro (\\(a_x\\), \\(a_y\\) e \\(a_z\\))</li> <li>Girosc\u00f3pio (\\(g_x\\), \\(g_y\\) e \\(g_z\\))</li> <li>Proximidade (\\(d\\))</li> <li>Fluxo \u00f3ptico (\\(p_x\\) e \\(p_y\\))</li> </ul>"},{"location":"sensors_and_actuators/sensors/#visao-geral","title":"Vis\u00e3o geral","text":"<p>Antes de come\u00e7ar, \u00e9 importante entender alguns conceitos:</p> <ul> <li>Os sensores no Crazyflie s\u00e3o processados por um sistema de estima\u00e7\u00e3o que envia os dados via uma fila interna. Usamos a fun\u00e7\u00e3o <code>estimatorDequeue(&amp;m)</code>, para preencher a estrutura <code>measurement_t m</code>, que cont\u00e9m diferentes tipos de leitura, identificados por <code>m.type</code>.</li> <li>O sistema coleta dados continuamente em alta frequ\u00eancia, que v\u00eam da IMU (aceler\u00f4metro e girosc\u00f3pio), do lidar (proximidade) e da c\u00e2mera (fluxo \u00f3ptico).</li> <li>Usamos <code>DEBUG_PRINT()</code> para exibir os valores no console serial.</li> </ul>"},{"location":"sensors_and_actuators/sensors/#codigo","title":"C\u00f3digo","text":"<p>Crie um arquivo chamado <code>sensors.c</code> dentro da pasta <code>src/examples</code> com o seguinte c\u00f3digo:</p> sensors.c<pre><code>#include \"FreeRTOS.h\"   // FreeRTOS core definitions (needed for task handling and timing)\n#include \"task.h\"       // FreeRTOS task functions (e.g., vTaskDelay)\n#include \"supervisor.h\" // Functions to check flight status (e.g., supervisorIsArmed)\n#include \"debug.h\"      // Debug printing functions (e.g., DEBUG_PRINT)\n#include \"estimator.h\"  // Estimator functions (e.g., estimatorDequeue)\n\n// Sensors data\nfloat ax, ay, az; // Accelerometer [m/s^2]\nfloat gx, gy, gz; // Gyroscope [rad/s]\nfloat d;          // Range [m]\nfloat px, py;     // Optical flow [pixels]\n\n// Main application loop\nvoid appMain(void *param)\n{\n    // Infinite loop (runs continuously while the drone is powered on)\n    while (true)\n    {\n        // Get sensor data from queue\n        measurement_t m;\n        while (estimatorDequeue(&amp;m))\n        {\n            switch (m.type)\n            {\n            case MeasurementTypeGyroscope:\n                gx = m.data.gyroscope.gyro.x;\n                gy = m.data.gyroscope.gyro.y;\n                gz = m.data.gyroscope.gyro.z;\n                break;\n            case MeasurementTypeAcceleration:\n                ax = m.data.acceleration.acc.x;\n                ay = m.data.acceleration.acc.y;\n                az = m.data.acceleration.acc.z;\n                break;\n            case MeasurementTypeTOF:\n                d = m.data.tof.distance;\n                break;\n            case MeasurementTypeFlow:\n                px = m.data.flow.dpixelx;\n                py = m.data.flow.dpixely;\n                break;\n            default:\n                break;\n            }\n        }\n        // Print sensor data to console\n        DEBUG_PRINT(\"Acc: %4.2f %4.2f %4.2f | Gyr: %6.2f %6.2f %6.2f | Dis: %4.2f | Flow: %2.0f %2.0f\\n\",(double)ax,(double)ay,(double)az,(double)gx,(double)gy,(double)gz,(double)d,(double)px,(double)py);\n        // Wait for 100 milliseconds before checking again (10 Hz loop)\n        vTaskDelay(pdMS_TO_TICKS(100));\n    }\n}\n</code></pre> <p>Voc\u00ea pode simplesmente copiar e colar o c\u00f3digo acima. Mas \u00e9 importante que voc\u00ea leia e entenda o que cada linha est\u00e1 fazendo (o c\u00f3digo est\u00e1 bem comentado).</p>"},{"location":"sensors_and_actuators/sensors/#compilando","title":"Compilando","text":"<p>Para que o firmware compile seu novo programa, modifique o arquivo <code>Kbuild</code>:</p> Kbuild<pre><code>obj-y += src/examples/sensors.o\n</code></pre> <p>Em seguida, compile e programe o quadricoptero.</p>"},{"location":"sensors_and_actuators/sensors/#testando","title":"Testando","text":"<p>Para testar o funcionamento, siga as etapas abaixo:</p> <ol> <li>Abra o Crazyflie Client e conecte-se ao drone.</li> <li>Clique em <code>View</code> &gt; <code>Toolboxes</code> &gt; <code>Console</code></li> <li>Verifique se os dados dos sensores est\u00e3o sendo impressos</li> </ol> <p>Aten\u00e7\u00e3o</p> <p>Movimente o drone com a m\u00e3o e observe a varia\u00e7\u00e3o dos sensores em tempo real.</p> <p>Agora voc\u00ea sabe como acessar dados brutos dos sensores do drone. Esses dados s\u00e3o a base para algoritmos de controle, filtros e navega\u00e7\u00e3o. A partir daqui, voc\u00ea ter\u00e1 todo o poder necess\u00e1rio para construir sistemas embarcados inteligentes \u2014 do jeito que quiser!</p>"}]}